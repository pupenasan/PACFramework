<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<STExchangeFile>
	<fileHeader company="Schneider Automation" product="Unity Pro XL V13.1 - 180823C" dateTime="date_and_time#2022-9-13-0:32:23" content="Structured source file" DTDVersion="41"></fileHeader>
	<contentHeader name="Project" version="0.0.31" dateTime="date_and_time#2022-4-26-17:49:42"></contentHeader>
	<program>
		<identProgram name="mainPFW" type="section" task="MAST">
			<comment>1.1.0</comment>
		</identProgram>
		<STSource>(* PACFramework SEControlExpertLIB V1.1.0 
https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro/CHANGELOG.md 
*)
PLCFN (PLC := PLC);
(*виклик при старті*)
IF PLC.STA_SCN1 THEN
  A_plcmaps();
  A_initvars();
  A_initacts();
END_IF;

(*обробка входів*)
A_dichs();
A_aichs();
A_ndichs();
A_naichs();
A_divars ();
A_aivars ();
A_write_parahmi();

(*обробка процедурного керування*)
A_procexmpl();

(*обробка виконавчих механізмів*)
A_resolution();
A_actrs();

(*обробка виходів*)
A_dovars();
A_aovars();
A_dochs();
A_aochs();
A_ndochs();
A_naochs();

A_moduls();
</STSource>
	</program>
	<program>
		<identProgram name="A_initacts" type="SR" task="MAST"></identProgram>
		<STSource>ACT.VLVD1.ID:=1; ACT.VLVD1.CLSID:=16#2011;
ACT.VLVA1.ID:=2; ACT.VLVA1.CLSID:=16#2020;
ACT.DRV1.ID:=3; ACT.DRV1.CLSID:=16#2110;
</STSource>
	</program>
	<dataBlock>
		<variables name="ACT" typeName="ACT"></variables>
		<variables name="PFWV" typeName="PFWV"></variables>
		<variables name="PARASTOHMI" typeName="PARASTOHMI">
			<attribute name="TimeStampSource" value="0"></attribute>
		</variables>
		<variables name="AIVARFN" typeName="AIVARFN">
			<instanceElementDesc name="IDMIN">
				<value>65000</value>
			</instanceElementDesc>
			<instanceElementDesc name="IDMAX">
				<value>0</value>
			</instanceElementDesc>
		</variables>
		<variables name="tmpreal" typeName="REAL"></variables>
		<variables name="PLC" typeName="PLC_CFG">
			<instanceElementDesc name="DICNT">
				<value>32</value>
			</instanceElementDesc>
			<instanceElementDesc name="DOCNT">
				<value>32</value>
			</instanceElementDesc>
			<instanceElementDesc name="AICNT">
				<value>8</value>
			</instanceElementDesc>
			<instanceElementDesc name="AOCNT">
				<value>4</value>
			</instanceElementDesc>
		</variables>
		<variables name="CHDO_HMI" typeName="ARRAY[0..32] OF CH_HMI"></variables>
		<variables name="CHAO" typeName="ARRAY[0..4] OF CH_CFG"></variables>
		<variables name="CHDI_HMI" typeName="ARRAY[0..32] OF CH_HMI"></variables>
		<variables name="j" typeName="INT"></variables>
		<variables name="CHNDO" typeName="ARRAY[0..1] OF CH_CFG"></variables>
		<variables name="CHDI" typeName="ARRAY[0..32] OF CH_CFG"></variables>
		<variables name="CHNAO" typeName="ARRAY[0..1] OF CH_CFG"></variables>
		<variables name="CHNDI_HMI" typeName="ARRAY[0..1] OF CH_HMI"></variables>
		<variables name="SUBMODULE" typeName="SUBMODULE"></variables>
		<variables name="i" typeName="INT"></variables>
		<variables name="CHNDO_HMI" typeName="ARRAY[0..1] OF CH_HMI"></variables>
		<variables name="CHDO" typeName="ARRAY[0..32] OF CH_CFG"></variables>
		<variables name="MODULES" typeName="ARRAY[0..3] OF MODULE"></variables>
		<variables name="CHNDI" typeName="ARRAY[0..1] OF CH_CFG"></variables>
		<variables name="CHAI_HMI" typeName="ARRAY[0..8] OF CH_HMI"></variables>
		<variables name="CHAO_HMI" typeName="ARRAY[0..4] OF CH_HMI"></variables>
		<variables name="CHAI" typeName="ARRAY[0..8] OF CH_CFG"></variables>
		<variables name="CHNAO_HMI" typeName="ARRAY[0..1] OF CH_HMI"></variables>
		<variables name="k" typeName="INT"></variables>
		<variables name="CHNAI_HMI" typeName="ARRAY[0..1] OF CH_HMI"></variables>
		<variables name="CHNAI" typeName="ARRAY[0..1] OF CH_CFG"></variables>
		<variables name="PRCBUF" typeName="PROC_CFG">
			<attribute name="TimeStampSource" value="0"></attribute>
		</variables>
		<variables name="PHHMI_EXMPL1" typeName="PROC_HMI">
			<attribute name="TimeStampSource" value="0"></attribute>
		</variables>
		<variables name="PHINOUT_EXMPL1" typeName="PHINOUT_EXMPL"></variables>
		<variables name="PHCTRL_EXMPL1" typeName="PROC_CTRL"></variables>
		<variables name="PH_EXMPL1" typeName="PH_EXMPL"></variables>
		<variables name="PHCFG_EXMPL1" typeName="PROC_CFG"></variables>
		<variables name="PHPARA_EXMPL1" typeName="PRC_PARA4">
			<attribute name="TimeStampSource" value="0"></attribute>
			<instanceElementDesc name="PARA1">
				<value>20.0</value>
			</instanceElementDesc>
			<instanceElementDesc name="PARA2">
				<value>30.0</value>
			</instanceElementDesc>
			<instanceElementDesc name="PARA3">
				<value>40.0</value>
			</instanceElementDesc>
		</variables>
		<variables name="ACTH" typeName="ACTH"></variables>
		<variables name="VLVDFN" typeName="VLVDFN"></variables>
		<variables name="VLVAFN" typeName="VLVAFN"></variables>
		<variables name="ACTBUF" typeName="ACTTR_CFG"></variables>
		<variables name="DRVFN" typeName="DRVFN"></variables>
		<variables name="PLCFN" typeName="PLCFN"></variables>
		<variables name="CH_BUF" typeName="CH_BUF"></variables>
		<variables name="CHDOFN" typeName="CHDOFN"></variables>
		<variables name="VARBUF" typeName="VARBUF"></variables>
		<variables name="VARS" typeName="VARS">
			<instanceElementDesc name="T1_LT1">
				<instanceElementDesc name="ID">
					<value>1</value>
				</instanceElementDesc>
			</instanceElementDesc>
			<instanceElementDesc name="T1_VRHEA_CPOS">
				<instanceElementDesc name="ID">
					<value>5001</value>
				</instanceElementDesc>
			</instanceElementDesc>
			<instanceElementDesc name="T1_VSLD_SOPN">
				<instanceElementDesc name="ID">
					<value>10001</value>
				</instanceElementDesc>
			</instanceElementDesc>
			<instanceElementDesc name="T1_VSLD_COPN">
				<instanceElementDesc name="ID">
					<value>20001</value>
				</instanceElementDesc>
			</instanceElementDesc>
		</variables>
		<variables name="DOVARFN" typeName="DOVARFN">
			<instanceElementDesc name="IDMIN">
				<value>65000</value>
			</instanceElementDesc>
			<instanceElementDesc name="IDMAX">
				<value>0</value>
			</instanceElementDesc>
		</variables>
		<variables name="DOH" typeName="DOH"></variables>
		<variables name="DIH" typeName="DIH"></variables>
		<variables name="DIVARFN" typeName="DIVARFN">
			<instanceElementDesc name="IDMIN">
				<value>65000</value>
			</instanceElementDesc>
			<instanceElementDesc name="IDMAX">
				<value>0</value>
			</instanceElementDesc>
		</variables>
		<variables name="AOVARFN" typeName="AOVARFN">
			<instanceElementDesc name="IDMIN">
				<value>65000</value>
			</instanceElementDesc>
			<instanceElementDesc name="IDMAX">
				<value>0</value>
			</instanceElementDesc>
		</variables>
		<variables name="AOH" typeName="AOH"></variables>
		<variables name="AIH" typeName="AIH"></variables>
		<variables name="CHAIFN" typeName="CHAIFN"></variables>
		<variables name="CHDIFN" typeName="CHDIFN"></variables>
		<variables name="CHAOFN" typeName="CHAOFN"></variables>
	</dataBlock>
	<DDTSource DDTName="ACT" version="0.01" dateTime="dt#2022-06-25-18:41:47">
		<comment>PFW екземпляри ACTCFG</comment>
		<attribute name="TypeSignatureCheckSumString" value="5E87"></attribute>
		<structure>
			<variables name="VLVD1" typeName="VLVD_CFG"></variables>
			<variables name="VLVA1" typeName="VLVA_CFG"></variables>
			<variables name="DRV1" typeName="DRV_CFG"></variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="VLVD_CFG" version="0.05" dateTime="dt#2022-06-25-18:41:47">
		<comment>PFW структура VLVD</comment>
		<attribute name="TypeSignatureCheckSumString" value="3F77"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>біти статусу</comment>
			</variables>
			<variables name="STA_IMSTPD" typeName="BOOL">
				<comment>=1 зупинився в проміжному стані</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_MANRUNING" typeName="BOOL">
				<comment>=1 рухається в невизначеному напрямку (ручний зі щита)</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_DBLCKACT" typeName="BOOL">
				<comment>=1 Включено режим ігнорування блокування керування {A.MSG.2} </comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_OPNING" typeName="BOOL">
				<comment>=1 Відкривається</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_CLSING" typeName="BOOL">
				<comment>=1 Закривається</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_OPND" typeName="BOOL">
				<comment>=1 Відкритий (16#0080)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_CLSD" typeName="BOOL">
				<comment>=1 Закритий (16#0100)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_MANBXOUT" typeName="BOOL">
				<comment>=1 Включення ручного зі щита</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_WRKED" typeName="BOOL">
				<comment>=1 В роботі</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_DISP" typeName="BOOL">
				<comment>=1 Включено ручний режим з ПК/ОП {A.MSG.9}</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_MANBX" typeName="BOOL">
				<comment>=1 Включений ручний зі щита {A.MSG.10}</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INIOTBUF" typeName="BOOL">
				<comment>=1 У бефері IoT</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 - змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 хоча би одна зі змінних в об’єкті форсована (для зручності відображення при наладці)</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 режим симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_BLCK" typeName="BOOL">
				<comment>=1 Привід заблоковано {A.MSG.15}</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти тривог</comment>
			</variables>
			<variables name="ALM_ALMOPN" typeName="BOOL">
				<comment>=1 Не відкрився (Несправність схеми управління) {A.ALM.0}</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_ALMCLS" typeName="BOOL">
				<comment>=1 Не закрився (Несправність схеми управління) {A.ALM.1}</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_ALMSHFT" typeName="BOOL">
				<comment>=1 Порушення стану приводу {A.ALM.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_ALMOPN2" typeName="BOOL">
				<comment>=1 Не відкрився (Несправність обладнання по місцю) {A.ALM.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_ALMCLS2" typeName="BOOL">
				<comment>=1 Не закрився (Несправність обладнання по місцю) {A.ALM.4}</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_ALM" typeName="BOOL">
				<comment>=1 Помилка приводу (по OR)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_WRN" typeName="BOOL">
				<comment>=1 Попередження приводу (по OR)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_ALMSTP" typeName="BOOL">
				<comment>=1 Не зупинився {A.ALM.7}</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_ALMBELL" typeName="BOOL">
				<comment>=1 Команда включення дзвоника (на один цикл ПЛК)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_ALMPWR1" typeName="BOOL">
				<comment>=1 Немає живлення у привода {A.ALM.9}</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_ALMSTPBTN" typeName="BOOL">
				<comment>=1 Натиснута кнопка СТОП по місцю {A.ALM.10}</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_STOPING" typeName="BOOL">
				<comment>=1 Зупиняється</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_SEN" typeName="BOOL">
				<comment>=1 Помилка датчика</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_b14" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<comment>біти команди</comment>
			</variables>
			<variables name="PRM" typeName="ACTTR_PRM">
				<comment>біти параметрів</comment>
			</variables>
			<variables name="T_DEASP" typeName="UINT">
				<comment>Час затримки тривоги в 0.1 секунди</comment>
			</variables>
			<variables name="T_OPNSP" typeName="UINT">
				<comment>Час повного переміщення в 0.1 секундах</comment>
			</variables>
			<variables name="POS" typeName="REAL">
				<comment>позиціяВМ (0-100%)</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>крок</comment>
			</variables>
			<variables name="CNTPER" typeName="UINT">
				<comment>Кількість змін положення</comment>
			</variables>
			<variables name="CNTALM" typeName="UINT">
				<comment>Кількість аварій</comment>
			</variables>
			<variables name="tmp" typeName="UINT">
				<comment>вирівнювання</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="ACTTR_CMD" version="0.03" dateTime="dt#2022-06-23-20:36:25">
		<comment>PFW біти команд для універсального ВМ </comment>
		<attribute name="TypeSignatureCheckSumString" value="AD59"></attribute>
		<structure>
			<variables name="CMD1" typeName="INT"></variables>
			<variables name="CMD_OPN" typeName="BOOL">
				<comment>Відкрити 16#0001</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="CMD_CLS" typeName="BOOL">
				<comment>Закрити  16#0002</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="CMD_TOGGLE" typeName="BOOL">
				<comment>Переключити (відкрити&lt;-&gt;закрити, включити &lt;-&gt; відключити) 16#0003</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="CMD_ALMACK" typeName="BOOL">
				<comment>Підтвердити тривогу 16#0004</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="CMD_ALMRESET" typeName="BOOL">
				<comment>Скинути тривоги 16#0005</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="CMD_BLCK" typeName="BOOL">
				<comment>Заблокувати 16#0006</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="CMD_DBLCK" typeName="BOOL">
				<comment>Розблокувати 16#0007</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="CMD_STOPTUN" typeName="BOOL">
				<comment>Зупинити автоналаштування 16#0008</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="CMD_TUNING" typeName="BOOL">
				<comment>Запустити автоналаштування 16#0009</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="CMD_MAN" typeName="BOOL">
				<comment>Перевести в ручний з SCADA/HMI 16#0301</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="CMD_AUTO" typeName="BOOL">
				<comment>Перевести в автоматичний з SCADA/HMI 16#0302</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="CMD_PROTECT" typeName="BOOL">
				<comment>Включити алгоритм захисту 16#000A</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="CMD_START" typeName="BOOL">
				<comment>Запустити 16#0011</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="CMD_STOP" typeName="BOOL">
				<comment>Зупинити 16#0012</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="CMD_UP" typeName="BOOL">
				<comment>Більше 16#0021</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="CMD_DWN" typeName="BOOL">
				<comment>Менше 16#0022</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD2" typeName="INT"></variables>
			<variables name="CMD_CRMT" typeName="BOOL">
				<comment>Відключити локальне керування (по місцю) 16#0314</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="CMD_RESOLUTION" typeName="BOOL">
				<comment>=1 дозвіл на керування 16#000B</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="CMD_REVERS" typeName="BOOL">
				<comment>Включити реверс 16#0013</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="CMD_CLCL" typeName="BOOL">
				<comment>Включити локальне керування (по місцю) 16#0313</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="CMD_DBLCKACTTOGGLE" typeName="BOOL">
				<comment>Переключення дозволу на ігнорування CMRESOLUTION 16#000C</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="CMD_STARTDELAY" typeName="BOOL">
				<comment>запуск з затримкою (тільки автомат)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="CMD_STOPDELAY" typeName="BOOL">
				<comment>зупин з затримкою (тільки автомат)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="CMD_P_RESOLUTION" typeName="BOOL">
				<comment>дозвіл по наявності тиску в системі</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="CMD_BUFLOAD" typeName="BOOL">
				<comment>завантажити в буфер</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="CMD_OUTSRVC" typeName="BOOL">
				<comment>вивести з експлуатації</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="CMD_INSRVC" typeName="BOOL">
				<comment>ввести в експлуатацію</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="CMD_b27" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="CMD_b28" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="CMD_b29" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="CMD_b30" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="CMD_b31" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="ACTTR_PRM" version="0.03" dateTime="dt#2022-01-17-11:17:16">
		<comment>PFW біти парамертів для універсального ВМ </comment>
		<attribute name="TypeSignatureCheckSumString" value="0FE1"></attribute>
		<structure>
			<variables name="PRM1" typeName="INT"></variables>
			<variables name="PRM_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_ZWRKENBL" typeName="BOOL">
				<comment>=1 є звонішній вхід - зворотній звязок про роботу</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_ZPOSENBL" typeName="BOOL">
				<comment>=1 є аналоговий зворотній звязок частоти/позиції</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_PWRENBL" typeName="BOOL">
				<comment>=1 є звонішній вхід по стану живлення</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_MANCFG" typeName="BOOL">
				<comment>=1 ручне керування налаштуванням</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_ZOPNENBL" typeName="BOOL">
				<comment>=1 є датчик відкритості</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_ZCLSENBL" typeName="BOOL">
				<comment>=1 є датчик закритості</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_AUTOACK" typeName="BOOL">
				<comment>=1, автоматичне підтвердження тривог</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_BTNSTPENBL" typeName="BOOL">
				<comment>=1 є зовнішній вхід - включена кнопка STOP</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_ALMENBL" typeName="BOOL">
				<comment>=1 є зовнішній вхід - сигнал аварії від приводу</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_SELLCLENBL" typeName="BOOL">
				<comment>=1 є зовнішній вхід - сигнал включення місцевого керування</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_PULSCTRLENBL" typeName="BOOL">
				<comment>=1 схема керування імпулсами (команди на 2с)</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_ZRUNENBL" typeName="BOOL">
				<comment>=1 є зовнішній вхід про рух приводу</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_ZSPDENBL" typeName="BOOL">
				<comment>=1 є зовнішній вхід про датчику швидкості приводу</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_CRVRSENBL" typeName="BOOL">
				<comment>=1 ВМ з виходом керування реверсом</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_BLCKOFSPD" typeName="BOOL">
				<comment>=1 зупиняти по зниженні швидкості</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="PRM2" typeName="INT"></variables>
			<variables name="PRM_NOPRES" typeName="BOOL">
				<comment>=1 довзолити рух без включеного маслонасоса</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_b17" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_b18" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_b19" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_b20" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_b21" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_b22" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_b23" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_b24" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_b25" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_b26" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_b27" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_b28" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_b29" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_b30" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_b31" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="VLVA_CFG" version="0.02" dateTime="dt#2022-06-25-18:41:46">
		<comment>PFW структура VLVA</comment>
		<attribute name="TypeSignatureCheckSumString" value="1285"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>біти статусів</comment>
			</variables>
			<variables name="STA_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_b2" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_OPND" typeName="BOOL">
				<comment>=1 Відкритий (16#0080)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_CLSD" typeName="BOOL">
				<comment>=1 Закритий (16#0100)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_b7" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_DISP" typeName="BOOL">
				<comment>=1 дистанційний режим (з ПК/ОП) (16#0200)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_MANBX" typeName="BOOL">
				<comment>=1 Ручний зі щита (за зворотнім зв'язком)</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INIOTBUF" typeName="BOOL">
				<comment>=1 - змінна в IOT буфері</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 - змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 хоча би одна зі змінних в об’єкті форсована (для зручності відображення при наладці)</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 режим симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_BLCK" typeName="BOOL">
				<comment>=1 Заблокований</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти алармів</comment>
			</variables>
			<variables name="ALM_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_b2" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_b5" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_b6" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_b7" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_b14" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<comment>команда</comment>
			</variables>
			<variables name="PRM" typeName="ACTTR_PRM">
				<comment>параметри</comment>
			</variables>
			<variables name="POS" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗВОРОТНІЙ ЗВЯЗОК</comment>
			</variables>
			<variables name="CPOS" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗАДАНЕ ЗНАЧЕННЯ</comment>
			</variables>
			<variables name="T_DEASP" typeName="UINT">
				<comment>Час затримки тривоги в 0.1 секунди</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>крок</comment>
			</variables>
			<variables name="CNTPER" typeName="UINT">
				<comment>Кількість змін положення</comment>
			</variables>
			<variables name="CNTALM" typeName="UINT">
				<comment>Кількість аварій</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DRV_CFG" version="0.04" dateTime="dt#2022-06-23-20:36:35">
		<comment>PFW структура DRV</comment>
		<attribute name="TypeSignatureCheckSumString" value="DBE8"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="STA_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_MAINT" typeName="BOOL">
				<comment>=1 виведений з обслуговування</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_STOPING" typeName="BOOL">
				<comment>=1 Зупиняється</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_STRTING" typeName="BOOL">
				<comment>=1 Запускається</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_STOPED" typeName="BOOL">
				<comment>=1 Зупинений(16#0100)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_ISANALOG" typeName="BOOL">
				<comment>=1 з аналоговим керуванням (для зурнчості відображення)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_ISREVERS" typeName="BOOL">
				<comment>=1 - пуск з реверсом</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_WRKED" typeName="BOOL">
				<comment>=1 В роботі</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_DISP" typeName="BOOL">
				<comment>=1 дистанційний режим (з ПК/ОП) (16#0200)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_MANBX" typeName="BOOL">
				<comment>=1 Ручний зі щита (за зворотнім зв'язком)</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INIOTBUF" typeName="BOOL">
				<comment>=1 - змінна в IOT буфері</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 - змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 хоча би одна зі змінних в об’єкті форсована (для зручності відображення при наладці)</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 режим симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_BLCK" typeName="BOOL">
				<comment>=1 Заблокований</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти тривог</comment>
			</variables>
			<variables name="ALM_ALMSTRT" typeName="BOOL">
				<comment>=1 Не включився (скидається при зміні команди або стану) датчика)</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_ALMSTP" typeName="BOOL">
				<comment>=1 Не відключився (скидається при зміні команди або стану) датчика)</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_ALMSHFT" typeName="BOOL">
				<comment>=1 Порушення стану</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_ALMINVRTR" typeName="BOOL">
				<comment>=1 помилка перетворювача частоти</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_ALMPWR" typeName="BOOL">
				<comment>=1 відсутнє живлення контактора</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_b5" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_ALM" typeName="BOOL">
				<comment>=1 Помилка приводу (по OR)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_WRN" typeName="BOOL">
				<comment>=1 Попередження приводу (по OR)</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_ALMBELL" typeName="BOOL">
				<comment>=1 Команда включення дзвоника (на один цикл ПЛК)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_b14" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<comment>команда</comment>
			</variables>
			<variables name="PRM" typeName="ACTTR_PRM">
				<comment>біти параметрів</comment>
			</variables>
			<variables name="SPD" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗВОРОТНІЙ ЗВЯЗОК</comment>
			</variables>
			<variables name="CSPD" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗАДАНЕ ЗНАЧЕННЯ</comment>
			</variables>
			<variables name="T_DEASP" typeName="UINT">
				<comment>час затримки тривоги 0.1 с</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>крок</comment>
			</variables>
			<variables name="CNTPER" typeName="UINT">
				<comment>кількість перестановок</comment>
			</variables>
			<variables name="CNTALM" typeName="UINT">
				<comment>кількість тривог</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
			<variables name="TQ_TOTAL" typeName="UDINT">
				<comment>Загальний час напрацювання в хв</comment>
			</variables>
			<variables name="TQ_LAST" typeName="UDINT">
				<comment>Час роботи з останнього пуску в с</comment>
			</variables>
		</structure>
	</DDTSource>
	<program>
		<identProgram name="A_resolution" type="SR" task="MAST"></identProgram>
		<STSource>(*ACT.T1_VSLD.CMD.CMD_RESOLUTION:=TRUE;*)

</STSource>
	</program>
	<program>
		<identProgram name="A_write_parahmi" type="SR" task="MAST"></identProgram>
		<STSource>(*дана секція призначена для мультиплексування AIVARFN.BUF2 та заповнення ним PARASTOHMI 
передбачається що ідентифікатори AIVAR починаються з 1*)

AIVARFN.VARBUFIN.CLSID := 16#1030;
 
if (PLC.TQMS - PFWV.writepara_prevtime)&gt;600 then
	PFWV.writepara_prevtime := PLC.TQMS;
	PARASTOHMI.ID := AIVARFN.VARBUFOUT.ID;
	PARASTOHMI.CLSID := AIVARFN.VARBUFOUT.CLSID;
	tmpreal := abs(AIVARFN.VARBUFOUT.HIENG); 
	if abs (AIVARFN.VARBUFOUT.LOENG)&gt; tmpreal then
		tmpreal:=AIVARFN.VARBUFOUT.LOENG;
	end_if;
	if tmpreal&gt;=3276800.0 then PARASTOHMI.K:=-1000;
		elsif tmpreal&gt;=327680.0 then PARASTOHMI.K:=-100;
		elsif tmpreal&gt;=32768.0 then PARASTOHMI.K:=-10;
		elsif tmpreal&gt;=3276.8 then PARASTOHMI.K:=1;
		elsif tmpreal&gt;=327.68 then PARASTOHMI.K:=10;
		elsif tmpreal&gt;=32.768 then PARASTOHMI.K:=100;
		elsif tmpreal&gt;=3.2768 then PARASTOHMI.K:=1000;
		elsif tmpreal&gt;=0.32768 then PARASTOHMI.K:=10000;
		elsif tmpreal&gt;=0.03276 then PARASTOHMI.K:=32000;
		else PARASTOHMI.K:=1;
	end_if;
	if PARASTOHMI.K &gt;= 0 then 
	 tmpreal := int_to_real(PARASTOHMI.K);
	else 
         tmpreal :=1.0/abs(int_to_real(PARASTOHMI.K));
	end_if;
	PARASTOHMI.INTS[4] := AIVARFN.VARBUFOUT.PRM;
	PARASTOHMI.INTS[5] := real_to_int(AIVARFN.VARBUFOUT.LOENG*tmpreal);
	PARASTOHMI.INTS[6] := real_to_int(AIVARFN.VARBUFOUT.HIENG*tmpreal);
	PARASTOHMI.INTS[7] := real_to_int(AIVARFN.VARBUFOUT.LOSP*tmpreal);
	PARASTOHMI.INTS[8] := real_to_int(AIVARFN.VARBUFOUT.HISP*tmpreal);
	PARASTOHMI.INTS[9] := real_to_int(AIVARFN.VARBUFOUT.LOLOSP*tmpreal);
	PARASTOHMI.INTS[10] := real_to_int(AIVARFN.VARBUFOUT.HIHISP*tmpreal);
	PARASTOHMI.INTS[11] := uint_to_int(AIVARFN.VARBUFOUT.ID);
 	PARASTOHMI.I := PARASTOHMI.I + 1;
       if int_to_uint(PARASTOHMI.I)&gt;=AIVARFN.IDMAX then PARASTOHMI.I:=0; end_if; (*максимальна кількість AIVAR*)      
	AIVARFN.VARBUFIN.ID := int_to_uint(PARASTOHMI.I) + AIVARFN.IDMIN;
	AIVARFN.VARBUFIN.CMD := 16#100;
	
end_if;
</STSource>
	</program>
	<DDTSource DDTName="PFWV" version="0.11" dateTime="dt#2022-07-16-10:24:46">
		<comment>PFW різні змінні для роботи PACFramework</comment>
		<attribute name="TypeSignatureCheckSumString" value="F489"></attribute>
		<structure>
			<variables name="bits" typeName="INT"></variables>
			<variables name="cmdLoadch" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="cmdLoadsbm" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="hasfrc" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="hasfree" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="inbuf" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="sbmbad" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="mask" typeName="INT"></variables>
			<variables name="modSTA" typeName="INT"></variables>
			<variables name="modSTA2" typeName="INT"></variables>
			<variables name="sbmchcnts" typeName="INT"></variables>
			<variables name="sbmCMD" typeName="INT"></variables>
			<variables name="sbmtype" typeName="INT"></variables>
			<variables name="modchcnts" typeName="UINT"></variables>
			<variables name="modtype" typeName="UINT"></variables>
			<variables name="sbmstrtnmb" typeName="UINT"></variables>
			<variables name="zm" typeName="UINT"></variables>
			<variables name="writepara_prevtime" typeName="UDINT">
				<comment>для writeparatimer - час попереднього запису (TQMS)</comment>
			</variables>
			<variables name="DIVAR_TMP" typeName="DIVAR_CFG"></variables>
			<variables name="DOVAR_TMP" typeName="DOVAR_CFG"></variables>
			<variables name="AIVAR_TMP" typeName="AIVAR_CFG"></variables>
			<variables name="AOVAR_TMP" typeName="AOVAR_CFG"></variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DIVAR_CFG" version="0.06" dateTime="dt#2022-07-16-10:24:43">
		<comment>PFW структура DIVAR</comment>
		<attribute name="TypeSignatureCheckSumString" value="87BE"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>16#1010</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>статус (див STC)</comment>
			</variables>
			<variables name="STA_VRAW" typeName="BOOL">
				<comment>=1 – значення дискретного сигналу з DICH</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_VALB" typeName="BOOL">
				<comment>=1 – значення дискретної вхідної змінної після всіх перетворень, в режимі FRC=1 може змінюватися із-зовні</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BAD" typeName="BOOL">
				<comment>=1 - Дані недостовірні {A.BAD.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_ALDIS" typeName="BOOL">
				<comment>=1 - Тривога виведена з експлуатації {A.MSG.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_DLNK" typeName="BOOL">
				<comment>=1 – якщо прив’язаний до каналу</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_ENBL" typeName="BOOL">
				<comment>=1 – змінна задіяна  = (NOT PRM.7 AND  DLNK)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_ALM" typeName="BOOL">
				<comment>=1 - Тривога {A.ALM.6}</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_VALPRV" typeName="BOOL">
				<comment>значення на попередньому циклі</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_ISALM" typeName="BOOL">
				<comment>=1 - задіяна тривога </comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_SPDMONON" typeName="BOOL">
				<comment>=1 - включений контроль швидкості (SPDMON) </comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_ISWRN" typeName="BOOL">
				<comment>=1 - задіяне попередження</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_WRN" typeName="BOOL">
				<comment>=1 - Попередження {A.ALM.11}</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 – змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 - Режим форсування{A.MSG.13}</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 – змінна в режимі симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDLOAD" typeName="BOOL">
				<comment>=1 – команда завантаження в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="VALI" typeName="INT">
				<comment>для відображення значення при не форсуванні, використовується для введення значення з буфера при форсуванні</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>параметри</comment>
			</variables>
			<variables name="PRM_ISALM" typeName="BOOL">
				<comment>=1 – задіяти як технологічну тривогу</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_ISWRN" typeName="BOOL">
				<comment>=1 – задіяти як технологічне попередження</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_INVERSE" typeName="BOOL">
				<comment>=1 – інвертувати сире значення</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_NRMVAL" typeName="BOOL">
				<comment>значення норми</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_QALENBL" typeName="BOOL">
				<comment>=1 – задіяти тривогу недостовірності каналу</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_DSBL" typeName="BOOL">
				<comment>=1 – змінна не задіяна</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_SPEEDENBL" typeName="BOOL">
				<comment>=1 – активація блоку розрахунку швидкості</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_STATICMAP" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CHID" typeName="UINT">
				<comment>Логічний номер дискретного каналу</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>номер кроку</comment>
			</variables>
			<variables name="T_DEASP" typeName="UINT">
				<comment>Час затримки тривоги в 0.1 секундах</comment>
			</variables>
			<variables name="T_FLTSP" typeName="UINT">
				<comment>Заданий час фільтрації в мілісекундах</comment>
			</variables>
			<variables name="CHIDDF" typeName="UINT">
				<comment>Логічний номер дискретного каналу за замовченням</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DOVAR_CFG" version="0.04" dateTime="dt#2022-03-21-18:21:18">
		<comment>PFW структура DOVAR для CFG</comment>
		<attribute name="TypeSignatureCheckSumString" value="8EAF"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>16#1010</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>статус (див STC)</comment>
			</variables>
			<variables name="STA_VRAW" typeName="BOOL">
				<comment>=1 – значення дискретного сигналу з DOCH</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_VALB" typeName="BOOL">
				<comment>=1 – значення дискретної вихідної змінної після всіх перетворень, в режимі FRC=1 може змінюватися із-зовні</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BAD" typeName="BOOL">
				<comment>=1 – Дані недостовірні {A.BAD.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_ALDIS" typeName="BOOL">
				<comment>=1 - Тривога виведена з експлуатації {A.MSG.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_DLNK" typeName="BOOL">
				<comment>=1 – якщо прив’язаний до каналу</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_ENBL" typeName="BOOL">
				<comment>=1 – змінна задіяна = (NOT PRM.7 AND DLNK)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_b6" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_VALPRV" typeName="BOOL">
				<comment>значення на попередньому циклі</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_MVAL" typeName="BOOL">
				<comment>=1 – ручне (форсоване) значення</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 – змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 - Режим форсування{A.MSG.13}</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 – змінна в режимі симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDLOAD" typeName="BOOL">
				<comment>=1 – команда завантаження в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="VALI" typeName="INT">
				<comment>для відображення значення при не форсуванні, використовується для введення значення з буфера при форсуванні</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>параметри</comment>
			</variables>
			<variables name="PRM_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_INVERSE" typeName="BOOL">
				<comment>=1 – інвертувати сире значення</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_b5" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_QALENBL" typeName="BOOL">
				<comment>=1 – задіяти тривогу недостовірності каналу</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_DSBL" typeName="BOOL">
				<comment>=1 – змінна не задіяна</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_STATICMAP" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CHID" typeName="UINT">
				<comment>Логічний номер дискретного каналу</comment>
			</variables>
			<variables name="CHIDDF" typeName="UINT">
				<comment>Логічний номер дискретного каналу за замовченням</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>номер кроку</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="AIVAR_CFG" version="0.03" dateTime="dt#2022-03-21-18:21:26">
		<comment>PFW структура AIVAR </comment>
		<attribute name="TypeSignatureCheckSumString" value="320D"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>16#1030</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>статус (див STC)</comment>
			</variables>
			<variables name="STA_BRK" typeName="BOOL">
				<comment>=1 – Обрив каналу {A.BAD.0}</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_OVRLD" typeName="BOOL">
				<comment>=1 – КЗ або перевантаження каналу {A.BAD.1}</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BAD" typeName="BOOL">
				<comment>=1 – Дані недостовірні {A.BAD.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_ALDIS" typeName="BOOL">
				<comment>=1 – Тривога виведена з експлуатації {A.MSG.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_DLNK" typeName="BOOL">
				<comment>=1 – якщо прив’язаний до каналу</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_ENBL" typeName="BOOL">
				<comment>=1 – змінна задіяна = (NOT PRM.7 AND DLNK)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_ALM" typeName="BOOL">
				<comment>=1 – активна технологічна тривога і не активна BAD</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_LOLO" typeName="BOOL">
				<comment>=1 – Критично низьке значення {A.ALM.7}</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_LO" typeName="BOOL">
				<comment>=1 – Низьке значення {A.WRN.8}</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_HI" typeName="BOOL">
				<comment>=1 – Високе значення {A.WRN.9}</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_HIHI" typeName="BOOL">
				<comment>=1 – Критично високе значення {A.ALM.10}</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_WRN" typeName="BOOL">
				<comment>=1 – активне технологічне попередження і не активні BAD та ALM</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 – змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 – Режим форсування{A.MSG.13}</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 – змінна в режимі симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDLOAD" typeName="BOOL">
				<comment>=1 – команда завантаження в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="VALPRCSTA2" typeName="INT">
				<comment>значення у % від шкали вимірювання (0-10000)</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>параметри</comment>
			</variables>
			<variables name="PRM_LOENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога LO /MASK 16#1</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_HIENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога HI /MASK 16#2</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_LOLOENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога LOLO /MASK 16#4</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_HIHIENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога HIHI/MASK 16#8</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_BRKENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога обриву</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_OVRLENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога перевантаження</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_QALENBL" typeName="BOOL">
				<comment>=1 – задіяна тривога перевірки якості даних</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_DSBL" typeName="BOOL">
				<comment>=1 – змінна не задіяна</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_PWLENBL" typeName="BOOL">
				<comment>=1 – задіяна кусочно-лінійна інтерполяція (не використовувати разом з TOTALON)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_TOTALON" typeName="BOOL">
				<comment>=1 – задіяне інтегрування (не використовувати разом з PWLENBL)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_SQRT" typeName="BOOL">
				<comment>=1 - задіяне квадратичне (квадратний корінь) масштабування</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_PARAISPROC" typeName="BOOL">
				<comment>=1 - параметри налаштування (гістерезис, нечутл) задається в процентах</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_AFRZENBL" typeName="BOOL">
				<comment>=1 - активна тривога нечутливості контролю зависання</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_ASPDENBL" typeName="BOOL">
				<comment>=1 - активна тривога допуску контролю швидкості</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_STATICMAP" typeName="BOOL">
				<comment>=1 - статична привязка каналів</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_NORAW" typeName="BOOL">
				<comment>=1 - джерело даних змінюється ззовні, відсутність масштабування (для мережних і внутрішніх змінних)</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CHID" typeName="UINT">
				<comment>Логічний номер дискретного каналу</comment>
			</variables>
			<variables name="LORAW" typeName="INT">
				<comment>Сире (немасштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIRAW" typeName="INT">
				<comment>Сире (немасштабоване) значення максимуму</comment>
			</variables>
			<variables name="VAL" typeName="REAL">
				<comment>масштабоване значення</comment>
			</variables>
			<variables name="VALFRC" typeName="REAL">
				<comment>зберігає форсоване значення</comment>
			</variables>
			<variables name="LOENG" typeName="REAL">
				<comment>Інженерне (масштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIENG" typeName="REAL">
				<comment>Інженерне (масштабоване) значення максимуму</comment>
			</variables>
			<variables name="LOSP" typeName="REAL">
				<comment>Уставка тривоги HI</comment>
			</variables>
			<variables name="HISP" typeName="REAL">
				<comment>Уставка тривоги LO</comment>
			</variables>
			<variables name="LOLOSP" typeName="REAL">
				<comment>Уставка тривоги LOLO</comment>
			</variables>
			<variables name="HIHISP" typeName="REAL">
				<comment>Уставка тривоги HIHI</comment>
			</variables>
			<variables name="THSP" typeName="REAL">
				<comment>Технологічна уставка HI (для регулятора)</comment>
			</variables>
			<variables name="TLSP" typeName="REAL">
				<comment>Технологічна уставка LO (для регулятора)</comment>
			</variables>
			<variables name="T_FLT" typeName="UINT">
				<comment>час фільтрації в мілісекундах (фільтр - аперіодична ланка)</comment>
			</variables>
			<variables name="VRAW" typeName="INT">
				<comment>сире значення</comment>
			</variables>
			<variables name="STA2" typeName="INT">
				<comment>додаткові біти статусу та тривоги</comment>
			</variables>
			<variables name="STA2_ASPD" typeName="BOOL">
				<comment>Шивдка зміна сигналу {A.BAD.0}</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA2_AFRZ" typeName="BOOL">
				<comment>Сигнал не змінюється {A.BAD.1}</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA2_AOVRFL" typeName="BOOL">
				<comment>Перехід через верхнє значення {A.BAD.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA2_AUNDRFL" typeName="BOOL">
				<comment>Перехід через нижнє значення  {A.BAD.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA2_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA2_b5" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA2_b6" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA2_b7" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA2_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA2_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA2_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA2_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA2_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA2_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA2_b14" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA2_b15" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="tmp" typeName="INT"></variables>
			<variables name="HYST" typeName="REAL">
				<comment>гістерезис в реальних одиницях або % (PRM_PARAISPROC)</comment>
			</variables>
			<variables name="T_DEALL" typeName="UINT">
				<comment>Час затримки на виникнення тривоги LL в 0.1 секундах</comment>
			</variables>
			<variables name="T_DEAL" typeName="UINT">
				<comment>Час затримки на виникнення тривоги L в 0.1 секундах (за необхідністю)</comment>
			</variables>
			<variables name="T_DEAH" typeName="UINT">
				<comment>Час затримки на виникнення тривоги H в 0.1 секундах (за необхідністю)</comment>
			</variables>
			<variables name="T_DEAHH" typeName="UINT">
				<comment>Час затримки на виникнення тривоги HH в 0.1 секундах (за необхідністю)</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>номер кроку</comment>
			</variables>
			<variables name="CHIDDF" typeName="UINT">
				<comment>Логічний номер каналу за замовченням</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
			<variables name="VALPRV" typeName="REAL">
				<comment>значення на попередньому циклі (для реалізації фільтрації)</comment>
			</variables>
			<variables name="VALPRV_AFRZ" typeName="REAL">
				<comment>значення на попередньому перерахунку контролю зависання (Енікон)</comment>
			</variables>
			<variables name="VALPRV_ASPD" typeName="REAL">
				<comment>значення на попередньому перерахунку контролю скачку (Енікон)</comment>
			</variables>
			<variables name="DEASP_AFRZ" typeName="REAL">
				<comment>уставка нечутливості контролю зависання (Енікон)</comment>
			</variables>
			<variables name="DOPSP_ASPD" typeName="REAL">
				<comment>уставка допуску контролю швидкості (Енікон)</comment>
			</variables>
			<variables name="ZERO_CUT_VAL" typeName="REAL">
				<comment>відсічка нуля </comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="AOVAR_CFG" version="0.03" dateTime="dt#2022-03-21-19:38:02">
		<comment>PFW структура AOVAR</comment>
		<attribute name="TypeSignatureCheckSumString" value="482E"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>16#1040</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>статус (див STC)</comment>
			</variables>
			<variables name="STA_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BAD" typeName="BOOL">
				<comment>=1 – Дані недостовірні {A.BAD.2}</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_ALDIS" typeName="BOOL">
				<comment>=1 – Тривога виведена з експлуатації {A.MSG.3}</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_DLNK" typeName="BOOL">
				<comment>=1 – якщо прив’язаний до каналу</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_ENBL" typeName="BOOL">
				<comment>=1 – змінна задіяна</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_b6" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_b7" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_b8" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 – змінна в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 – Режим форсування{A.MSG.13}</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 – змінна в режимі симуляції</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDLOAD" typeName="BOOL">
				<comment>=1 – команда завантаження в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="VRAW" typeName="INT">
				<comment>сирі значення</comment>
			</variables>
			<variables name="VAL" typeName="REAL">
				<comment>масштабоване значення</comment>
			</variables>
			<variables name="VALFRC" typeName="REAL">
				<comment>зберігає форсоване значення</comment>
			</variables>
			<variables name="VALPRV" typeName="REAL">
				<comment>зберігає попереднє значення</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>параметри</comment>
			</variables>
			<variables name="PRM_b0" typeName="BOOL">
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PRM_b1" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PRM_b2" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PRM_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PRM_b4" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PRM_b5" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PRM_QALENBL" typeName="BOOL">
				<comment>=1 – задіяти тривогу недостовірності каналу</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PRM_DSBL" typeName="BOOL">
				<comment>=1 – змінна не задіяна</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PRM_PWLENBL" typeName="BOOL">
				<comment>=1 – задіяна кусочно-лінійна інтерполяція (не використовувати разом з TOTALON)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PRM_b9" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PRM_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PRM_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PRM_b12" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PRM_b13" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PRM_STATICMAP" typeName="BOOL">
				<comment>=1 -  статична привязка каналів</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PRM_NORAW" typeName="BOOL">
				<comment>=1 - джерело даних змінюється ззовні</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CHID" typeName="UINT">
				<comment>Логічний номер вихідного аналогового каналу CH</comment>
			</variables>
			<variables name="LORAW" typeName="INT">
				<comment>Сире (немасштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIRAW" typeName="INT">
				<comment>Сире (немасштабоване) значення максимуму</comment>
			</variables>
			<variables name="LOENG" typeName="REAL">
				<comment>Інженерне (масштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIENG" typeName="REAL">
				<comment>Інженерне (масштабоване) значення максимуму</comment>
			</variables>
			<variables name="MVAL" typeName="REAL">
				<comment>ручне(форсоване) значення</comment>
			</variables>
			<variables name="T_FLT" typeName="UINT">
				<comment>час фільтрації в мілісекундах (фільтр - аперіодична ланка)</comment>
			</variables>
			<variables name="VALPROC" typeName="INT">
				<comment>значення у відсотках</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>номер кроку</comment>
			</variables>
			<variables name="CHIDDF" typeName="UINT">
				<comment>Логічний номер дискретного каналу за замовченням</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="PARASTOHMI" version="0.07" dateTime="dt#2022-03-22-15:47:09">
		<comment>PFW структура для фонової передачі на HMI параметрів</comment>
		<attribute name="TypeSignatureCheckSumString" value="E952"></attribute>
		<structure>
			<variables name="ID" typeName="UINT"></variables>
			<variables name="CLSID" typeName="UINT"></variables>
			<variables name="K" typeName="INT"></variables>
			<variables name="I" typeName="INT"></variables>
			<variables name="INTS" typeName="ARRAY[4..11] OF INT"></variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="AIVARFN" version="0.30" dateTime="dt#2022-09-04-21:13:32">
		<comment>PFW обробка AI</comment>
		<attribute name="TypeCodeCheckSumString" value="AE43"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="317E"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="AIVARCFG" typeName="AIVAR_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="AIVARHMI" typeName="AIVAR_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="VARBUF" typeName="VARBUF">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="CHAI" typeName="ARRAY[0..8] OF CH_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="IDMIN" typeName="UINT"></variables>
			<variables name="IDMAX" typeName="UINT"></variables>
			<variables name="VARBUFIN" typeName="VARBUF"></variables>
			<variables name="VARBUFOUT" typeName="VARBUF"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="VRAW" typeName="INT"></variables>
			<variables name="BRK" typeName="BOOL"></variables>
			<variables name="OVRLD" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="ALDIS" typeName="BOOL"></variables>
			<variables name="DLNK" typeName="BOOL"></variables>
			<variables name="ENBL" typeName="BOOL"></variables>
			<variables name="ALM" typeName="BOOL"></variables>
			<variables name="LOLO" typeName="BOOL"></variables>
			<variables name="LO" typeName="BOOL"></variables>
			<variables name="HI" typeName="BOOL"></variables>
			<variables name="HIHI" typeName="BOOL"></variables>
			<variables name="WRN" typeName="BOOL"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="CMD" typeName="UINT"></variables>
			<variables name="VARENBL" typeName="BOOL"></variables>
			<variables name="T_STEPMS" typeName="UDINT"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="VAL" typeName="REAL"></variables>
			<variables name="LORAW" typeName="INT"></variables>
			<variables name="HIRAW" typeName="INT"></variables>
			<variables name="LOENG" typeName="REAL"></variables>
			<variables name="HIENG" typeName="REAL"></variables>
			<variables name="LOSP" typeName="REAL"></variables>
			<variables name="HISP" typeName="REAL"></variables>
			<variables name="LOLOSP" typeName="REAL"></variables>
			<variables name="HIHISP" typeName="REAL"></variables>
			<variables name="T_FLT" typeName="UDINT"></variables>
			<variables name="T_DEALL" typeName="UDINT"></variables>
			<variables name="T_DEAL" typeName="UDINT"></variables>
			<variables name="T_DEAH" typeName="UDINT"></variables>
			<variables name="T_DEAHH" typeName="UDINT"></variables>
			<variables name="HYST" typeName="REAL"></variables>
			<variables name="tmpDWORD" typeName="DWORD"></variables>
			<variables name="VAL1PROC" typeName="REAL"></variables>
			<variables name="VALNOFLT" typeName="REAL"></variables>
			<variables name="tmpOVRLD" typeName="BOOL"></variables>
			<variables name="tmpBRK" typeName="BOOL"></variables>
			<variables name="tmpHI" typeName="BOOL"></variables>
			<variables name="tmpHIHI" typeName="BOOL"></variables>
			<variables name="tmpLO" typeName="BOOL"></variables>
			<variables name="tmpLOLO" typeName="BOOL"></variables>
			<variables name="tmpAFRZ" typeName="BOOL"></variables>
			<variables name="tmpASPD" typeName="BOOL"></variables>
			<variables name="tmpAOVRFL" typeName="BOOL"></variables>
			<variables name="tmpAUNDRFL" typeName="BOOL"></variables>
			<variables name="T_DEAQALSP" typeName="INT"></variables>
			<variables name="VALPROC" typeName="REAL"></variables>
			<variables name="VALPRV" typeName="REAL"></variables>
			<variables name="tmpuint" typeName="INT"></variables>
			<variables name="PRM_SCL" typeName="INT"></variables>
			<variables name="STA_SCL" typeName="INT"></variables>
			<variables name="SCALING" typeName="SCALING"></variables>
			<variables name="A_FLTR" typeName="A_FLTR"></variables>
			<variables name="INT_TO_SIGU" typeName="INT_TO_SIGU"></variables>
		</privateLocalVariables>
		<FBProgram name="AIVARFN">
			<STSource>(*ініціалізація змінної на першому циклі обробки*)
IF PLCCFG.STA_SCN1 THEN
    AIVARCFG.CLSID := 16#1030; (*присвоєння ідентифікатора класу*)
    AIVARCFG.PRM_DSBL := FALSE; (*активація змінної*)
    AIVARCFG.PRM_QALENBL := true; (*активація тривог перевірки якості даних*)
    AIVARCFG.PRM_BRKENBL := TRUE; (*активаці тривог обриву*)
    AIVARCFG.PRM_OVRLENBL := TRUE; (*активаці тривог КЗ*)
    AIVARCFG.T_PREV := PLCCFG.TQMS; (*збереження часу виклику*)
    IF AIVARCFG.CHID = 0 THEN (*якщо логіний номер каналу на заданий - записати значення по замовчування *)
        AIVARCFG.CHID := AIVARCFG.CHIDDF;
    END_IF;

    (*запис сирого значення з каналу для подальшої обробки*)
    IF CHCFG.ID &gt; 0 THEN
        VRAW := CHCFG.VAL;
    ELSE
        VRAW := 0;
    END_IF;
    AIVARCFG.VALPRV := INT_TO_REAL(VRAW);
    AIVARCFG.VRAW := REAL_TO_INT(AIVARCFG.VALPRV);
    AIVARCFG.VAL := INT_TO_REAL(AIVARCFG.VRAW) ;

    AIVARCFG.T_STEP1 := 0; (*онулення часу кроку*)
    AIVARCFG.STEP1 := 400; (*переведення на крок норми*)

    (*визначення діапазонів ідентифікаторів змінної*)
    IF AIVARCFG.ID&gt;0 THEN
    	IF AIVARCFG.ID&lt;IDMIN THEN IDMIN:=AIVARCFG.ID; END_IF;
    	IF AIVARCFG.ID&gt;IDMAX THEN IDMAX:=AIVARCFG.ID; END_IF;
    END_IF;	
    RETURN;
END_IF;

(*зчитування статусних бітів з технологічної змінної у внутрішні змінні*)
BRK := AIVARCFG.STA_BRK;
OVRLD := AIVARCFG.STA_OVRLD;
BAD := AIVARCFG.STA_BAD;
ALDIS := AIVARCFG.STA_ALDIS;
ENBL := AIVARCFG.STA_ENBL;
ALM := AIVARCFG.STA_ALM;
LOLO := AIVARCFG.STA_LOLO;
LO := AIVARCFG.STA_LO;
HI := AIVARCFG.STA_HI;
HIHI := AIVARCFG.STA_HIHI;
WRN := AIVARCFG.STA_WRN;
FRC := AIVARCFG.STA_FRC;
SML := AIVARCFG.STA_SML;
CMDLOAD := AIVARCFG.STA_CMDLOAD;

INBUF := (AIVARCFG.ID = VARBUF.ID) AND (AIVARCFG.CLSID = VARBUF.CLSID); (*змінна в буфері якщо співпадає ідентифікатор змінної та ідентифікатор класу*)
CMDLOAD := AIVARHMI.STA.15; (*команда запису в буфер з НМІ змінної*)
CMD := 0; (*онулення внутрішньої команда*)
DLNK := (CHCFG.ID &gt; 0); (*змінна привязана до каналу якщо канал має реальний ідентифікатор (не 0 - не молоко)*)
VARENBL := NOT AIVARCFG.PRM_DSBL AND DLNK; (*змінна задіяна якщо привязана до каналу і не активний параметр змінна не задіяна*)

(*зчитування параметрів з технологічної змінної у внутрішні змінні*)
LORAW := AIVARCFG.LORAW;
HIRAW := AIVARCFG.HIRAW;
LOENG := AIVARCFG.LOENG;
HIENG := AIVARCFG.HIENG;
LOSP := AIVARCFG.LOSP;
HISP := AIVARCFG.HISP;
LOLOSP := AIVARCFG.LOLOSP;
HIHISP := AIVARCFG.HIHISP;
IF AIVARCFG.T_FLT &lt;= 0 THEN (*час фільтрації не може бути нульовим*)
   AIVARCFG.T_FLT := 1;
END_IF;
T_FLT := UINT_TO_UDINT(AIVARCFG.T_FLT);
T_DEALL := UINT_TO_UDINT(AIVARCFG.T_DEALL*100);
T_DEAL := UINT_TO_UDINT(AIVARCFG.T_DEAL*100);
T_DEAH := UINT_TO_UDINT(AIVARCFG.T_DEAH*100);
T_DEAHH := UINT_TO_UDINT(AIVARCFG.T_DEAHH*100);

VRAW := CHCFG.VAL; (*зчитування сирого значення з каналу*)
T_STEPMS := AIVARCFG.T_STEP1; (*запамятовування часу циклу в мс*)
VAL := AIVARCFG.VAL; (*зчитування значення з технологічної змінної у внутрішню дляя подальшої обробки*)
VALPRV := AIVARCFG.VALPRV; (*зчитування попереднього значення з технологічної змінної у внутрішню дляя подальшої обробки*)

(*якщо попереднього значення виходить за діапазон вводимо обмеження діапазону*)
IF VALPRV &lt;= AIVARCFG.LOENG THEN 
   VALPRV:=AIVARCFG.LOENG;
ELSIF VALPRV&gt;AIVARCFG.HIENG THEN 
   VALPRV:=AIVARCFG.HIENG; 
END_IF;

(*реалізація алгоритму ping-pong*)
IF DLNK THEN
    CHCFG.STA_PNG := true;
    CHCFG.VARID := AIVARCFG.ID;
END_IF;

(*визначення часу між викликами функції по різниці між мілісікундним лічильником та часом який пройшов з попереднього виклику *)
dT1 := PLCCFG.TQMS - AIVARCFG.T_PREV;

(*перевірка NaN*)
IF NOT (VALPRV&lt;AIVARCFG.LOENG OR VALPRV&gt;=AIVARCFG.LOENG) THEN 
   VALPRV:=AIVARCFG.LOENG;
END_IF;

(*визначення 1% від шкали*)
VAL1PROC := (AIVARCFG.HIENG - AIVARCFG.LOENG) / 100.0; (* 1 % EU*)
IF VAL1PROC = 0.0 THEN
   VAL1PROC := 1.0;
END_IF;

(*гістерезис в залежності від параметра вказівки гістерезису*)
IF AIVARCFG.PRM_PARAISPROC THEN (*%*)
   HYST := AIVARCFG.HYST * VAL1PROC;
ELSE (*real units*)
   HYST := AIVARCFG.HYST;
END_IF;

(*перевірка на коректність діапазонів*)
IF ABS(AIVARCFG.HIRAW - AIVARCFG.LORAW) &lt; 1 THEN
   AIVARCFG.LORAW := 0;
   AIVARCFG.HIRAW := 10000;
END_IF;
IF ABS(AIVARCFG.HIENG - AIVARCFG.LOENG) &lt; 0.00001 THEN
   AIVARCFG.LOENG := 0.0;
   AIVARCFG.HIENG := 100.0;
END_IF;

(*обнулення некоректних значень + infinity (INF)  - infinity (-INF)  SNAN QNAN *)
(*коли експонента (23-30 біти) = 255 *)
tmpDWORD := SHR(IN := REAL_TO_DWORD(AIVARCFG.VAL), N := 23) AND 16#00FF;
IF tmpDWORD = 16#00ff THEN
   AIVARCFG.VAL := 0.0;
END_IF;

(*масштабування*)
PRM_SCL:=0;STA_SCL:=0;
PRM_SCL.0 := AIVARCFG.PRM_SQRT;(*квадратнокоренева залежність, X0  *)
PRM_SCL.1 := true; (*обмежувати вихідну величину, X1*)
SCALING (IN := INT_TO_REAL(VRAW),
         in_min := INT_TO_REAL(LORAW),
         in_max := INT_TO_REAL(HIRAW),
         out_min := LOENG,
         out_max := HIENG,
         STA := STA_SCL,
         PRM := PRM_SCL,
         SCALING =&gt; VALNOFLT);

(* якщо відсічка нуля активна(більше нуля) і значення менше то значення нуль, інакше маштабуєм значення*)
IF AIVARCFG.ZERO_CUT_VAL &gt; 0.0 AND (LOENG + INT_TO_REAL(VRAW - LORAW) * (HIENG - LOENG) / INT_TO_REAL(HIRAW - LORAW)) &lt;= AIVARCFG.ZERO_CUT_VAL THEN
   VALNOFLT := 0.0;
END_IF;

(*фільтрація*)
A_FLTR (IN := VALNOFLT, dT1 := dT1, T_FLT := T_FLT, PRM := tmpuint, STA := tmpuint, VALPRV := VALPRV, A_FLTR =&gt; VAL);
 
(* широкомовне дефорсування*) 
IF PLCCFG.CMD = 16#4302 THEN
   FRC := false; (*дефорсувати об'єкт типу*)
END_IF;

(*вибір джерела конфігураційної/керівної команди згідно пріоритету якщо команди надійшли одночасно*)
IF CMDLOAD THEN (*команда запису в буфер - команда з НМІ*)
   CMD := 16#0100;
ELSIF INBUF AND VARBUF.CMD &lt;&gt; 0 THEN (*команда з буферу*)
   CMD := VARBUF.CMD;
END_IF;

(*commands*)
CASE CMD OF
    16#0001: (*записати максимум діапазону*)
        IF FRC AND INBUF THEN
            AIVARCFG.VALFRC := AIVARCFG.HIENG;
            VAL := AIVARCFG.HIENG;
            AIVARCFG.STEP1 := 400;
            AIVARCFG.T_STEP1 := 0;
        END_IF;
    16#0002: (*записати мінімум діапазону*)
        IF FRC AND INBUF THEN
            AIVARCFG.VALFRC := AIVARCFG.LOENG;
            VAL := AIVARCFG.LOENG;
            AIVARCFG.STEP1 := 400;
            AIVARCFG.T_STEP1 := 0;
        END_IF;
    16#0003: (*записати середину діапазону*)
        IF FRC AND INBUF THEN
            AIVARCFG.VALFRC := (AIVARCFG.HIENG - AIVARCFG.LOENG) / 2.0;
            VAL := (AIVARCFG.HIENG - AIVARCFG.LOENG) / 2.0;
            AIVARCFG.STEP1 := 400;
            AIVARCFG.T_STEP1 := 0;
        END_IF;
    16#0100: (*прочитати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів *)
        VARBUF.MSG := 201; 

	(*зчитати ідентифікатор змінної та ідентифікатор класу*)
        VARBUF.ID := AIVARCFG.ID;
        VARBUF.CLSID := AIVARCFG.CLSID;

	(*зчитати бітові параметри*)
        VARBUF.PRM.0 := AIVARCFG.PRM_LOENBL;
        VARBUF.PRM.1 := AIVARCFG.PRM_HIENBL;
        VARBUF.PRM.2 := AIVARCFG.PRM_LOLOENBL;
        VARBUF.PRM.3 := AIVARCFG.PRM_HIHIENBL;
        VARBUF.PRM.4 := AIVARCFG.PRM_BRKENBL;
        VARBUF.PRM.5 := AIVARCFG.PRM_OVRLENBL;
        VARBUF.PRM.6 := AIVARCFG.PRM_QALENBL;
        VARBUF.PRM.7 := AIVARCFG.PRM_DSBL;
        VARBUF.PRM.8 := AIVARCFG.PRM_PWLENBL;
        VARBUF.PRM.9 := AIVARCFG.PRM_TOTALON;
        VARBUF.PRM.10 := AIVARCFG.PRM_SQRT;
        VARBUF.PRM.11 := AIVARCFG.PRM_PARAISPROC;
        VARBUF.PRM.12 := AIVARCFG.PRM_AFRZENBL;        
        VARBUF.PRM.13 := AIVARCFG.PRM_ASPDENBL;
        VARBUF.PRM.14 := AIVARCFG.PRM_STATICMAP;
        VARBUF.PRM.15 := AIVARCFG.PRM_NORAW;
   
        (*зчитати параметри*)
        VARBUF.CHID := AIVARCFG.CHID;
        VARBUF.LORAW := AIVARCFG.LORAW;
        VARBUF.HIRAW := AIVARCFG.HIRAW;
        VARBUF.LOENG := AIVARCFG.LOENG;
        VARBUF.HIENG := AIVARCFG.HIENG;
        VARBUF.HIHISP := AIVARCFG.HIHISP;
        VARBUF.HISP := AIVARCFG.HISP;
        VARBUF.LOSP := AIVARCFG.LOSP;
        VARBUF.LOLOSP := AIVARCFG.LOLOSP;
        VARBUF.T_FLTSP := AIVARCFG.T_FLT;
        VARBUF.HYST := AIVARCFG.HYST;
        VARBUF.T_DEAHH := AIVARCFG.T_DEAHH;
        VARBUF.T_DEAH := AIVARCFG.T_DEAH;
        VARBUF.T_DEAL := AIVARCFG.T_DEAL;
        VARBUF.T_DEALL := AIVARCFG.T_DEALL;
        VARBUF.VALPRV_AFRZ :=AIVARCFG.VALPRV_AFRZ;
        VARBUF.VALPRV_ASPD :=AIVARCFG.VALPRV_ASPD;
        VARBUF.DEASP_AFRZ :=AIVARCFG.DEASP_AFRZ;
        VARBUF.DOPSP_ASPD := AIVARCFG.DOPSP_ASPD;
        VARBUF.ZERO_CUT_VAL := AIVARCFG.ZERO_CUT_VAL;
        
	(*зчитати значення змінної для безударного форсування*)    
	VARBUF.VALR := AIVARCFG.VALFRC;

    16#0101: (*записати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів*)
        VARBUF.MSG:=200; 

	(*записати бітові параметри*)	    
        AIVARCFG.PRM_LOENBL := VARBUF.PRM.0;
        AIVARCFG.PRM_HIENBL := VARBUF.PRM.1;
        AIVARCFG.PRM_LOLOENBL := VARBUF.PRM.2;
        AIVARCFG.PRM_HIHIENBL := VARBUF.PRM.3;
        AIVARCFG.PRM_BRKENBL := VARBUF.PRM.4;
        AIVARCFG.PRM_OVRLENBL := VARBUF.PRM.5;
        AIVARCFG.PRM_QALENBL := VARBUF.PRM.6;
        AIVARCFG.PRM_DSBL := VARBUF.PRM.7;
        AIVARCFG.PRM_PWLENBL := VARBUF.PRM.8;
        AIVARCFG.PRM_TOTALON := VARBUF.PRM.9;
        AIVARCFG.PRM_SQRT := VARBUF.PRM.10;
        AIVARCFG.PRM_PARAISPROC := VARBUF.PRM.11;
        AIVARCFG.PRM_AFRZENBL := VARBUF.PRM.12;
        AIVARCFG.PRM_ASPDENBL := VARBUF.PRM.13;
        AIVARCFG.PRM_STATICMAP := VARBUF.PRM.14;
        AIVARCFG.PRM_NORAW := VARBUF.PRM.15;
    
        (*записати параметри*)
        AIVARCFG.LORAW := VARBUF.LORAW;
        AIVARCFG.HIRAW := VARBUF.HIRAW;
        AIVARCFG.LOENG := VARBUF.LOENG;
        AIVARCFG.HIENG := VARBUF.HIENG;
        AIVARCFG.HIHISP := VARBUF.HIHISP;
        AIVARCFG.HISP := VARBUF.HISP;
        AIVARCFG.LOSP := VARBUF.LOSP;
        AIVARCFG.LOLOSP := VARBUF.LOLOSP;
        AIVARCFG.T_FLT := VARBUF.T_FLTSP;
        AIVARCFG.HYST := VARBUF.HYST;
        AIVARCFG.T_DEAHH := VARBUF.T_DEAHH;
        AIVARCFG.T_DEAH := VARBUF.T_DEAH;
        AIVARCFG.T_DEAL := VARBUF.T_DEAL;
        AIVARCFG.T_DEALL := VARBUF.T_DEALL;
        AIVARCFG.VALPRV_AFRZ := VARBUF.VALPRV_AFRZ ;
        AIVARCFG.VALPRV_ASPD := VARBUF.VALPRV_ASPD ;
        AIVARCFG.DEASP_AFRZ := VARBUF.DEASP_AFRZ ;
        AIVARCFG.DOPSP_ASPD :=  VARBUF.DOPSP_ASPD ;
        AIVARCFG.ZERO_CUT_VAL := VARBUF.ZERO_CUT_VAL  ;       
          
        (*алгоритм для зміни номера логічного каналу при перевірці його на коректність*)
        IF NOT AIVARCFG.PRM_STATICMAP THEN (* зміна логічного номеру каналу тільки при неактивна статичн адресація*)
           IF VARBUF.CHID&gt;=0 AND VARBUF.CHID &lt;= INT_TO_UINT(PLCCFG.AICNT) THEN (* якщо логічний номер канал менший за кількість каналів*)
               IF CHAI[VARBUF.CHID].VARID = 0 THEN (* якщо логічний номер канал нульовий - вільний *)
                   AIVARCFG.CHID := VARBUF.CHID; (* змінити логічний номер каналу *)
               ELSIF VARBUF.CHID &lt;&gt; AIVARCFG.CHID THEN  (* інакше вивести помилку про зайнятість каналу *)
                   VARBUF.MSG := 403;(* канал вже зайнятий*)
               END_IF;
           ELSE 
               VARBUF.MSG := 404; (*номер каналу не відповідає діапазону*)
           END_IF;
        ELSIF VARBUF.CHID &lt;&gt; AIVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
           VARBUF.MSG := 405;(* активна статична адресація каналів*)
        END_IF;
        IF INBUF THEN (*оновити логічний номер каналу після запису якщо змінна ще в буфері*)
            VARBUF.CHID := AIVARCFG.CHID;
        END_IF;
    16#0102: (*записати значення за замовченням*)
        AIVARCFG.CHID := AIVARCFG.CHIDDF;
    16#0160: (*інвертувати LOENBL*)
        AIVARCFG.PRM_LOENBL := NOT AIVARCFG.PRM_LOENBL;
    16#0161: (*інвертувати HIENBL*)
        AIVARCFG.PRM_HIENBL := NOT AIVARCFG.PRM_HIENBL;
    16#0162: (*інвертувати LOLOENBL*)
        AIVARCFG.PRM_LOLOENBL := NOT AIVARCFG.PRM_LOLOENBL;
    16#0163: (*інвертувати HIHIENBL*)
        AIVARCFG.PRM_HIHIENBL := NOT AIVARCFG.PRM_HIHIENBL;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*ввімкнути форсування*)
        FRC := true;
    16#0302: (*вимкнути форсування*)
        FRC := false;
    16#0311: (* імітувати*)
        SML := true;
    16#0312: (* зняти режим імітації*)
        SML := false;
END_CASE;

(*обробка значень*)
IF FRC THEN (*при форсуванні берем значення з буфера*)
    IF INBUF THEN
        AIVARCFG.VAL := VARBUF.VALR;
        AIVARCFG.VALFRC := VARBUF.VALR;
    END_IF;
    VAL := AIVARCFG.VALFRC;
ELSIF SML OR AIVARCFG.PRM_NORAW THEN (* режим симуляції або джерело даних змінюється ззовні  - значення змінюється ззовні *)
    VAL := AIVARCFG.VAL;
ELSE  (*обробка нефорсованого значення - нормальна обробка змінної*)
    AIVARCFG.VALFRC := VAL; 
END_IF;



(*обробка тривог*)
BRK := false;
LO := false;
LOLO := false;
HI := false;
HIHI := false;
OVRLD := false;
T_DEAQALSP := 10;     (* час затримки на виникнення тривог обривів і кз в 0.1 с*)
    
(*не алармувати*)
IF VARENBL THEN (*тільки при активності змінної обробляються тривоги*)
   (*перевірка на спрацювання*)
   tmpOVRLD := CHCFG.VAL&gt;=11000;
   tmpBRK := CHCFG.VAL&lt;=-1000;  
   tmpHI := (VAL &gt;= AIVARCFG.HISP);
   tmpHIHI := (VAL &gt;= AIVARCFG.HIHISP);
   tmpLO := (VAL &lt;= AIVARCFG.LOSP);
   tmpLOLO := (VAL &lt;= AIVARCFG.LOLOSP);
   
   (*якщо активована перевірка якості то PRM_BRKENBL та PRM_OVRLENBL ставимо насильно*)
   IF NOT AIVARCFG.PRM_QALENBL THEN
      AIVARCFG.PRM_BRKENBL := false;
      AIVARCFG.PRM_OVRLENBL := false;
   END_IF;
   
   (*обробка автомату станів*)     
   CASE AIVARCFG.STEP1 OF
      100:  (*BRK - обрив каналу*)
          LO := AIVARCFG.PRM_LOENBL;
          LOLO := AIVARCFG.PRM_LOLOENBL;
          IF NOT tmpBRK OR NOT AIVARCFG.PRM_BRKENBL THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 200;
          ELSIF T_STEPMS &gt;= INT_TO_UDINT(T_DEAQALSP)*100 THEN (*тривога*)
             BRK := true;
          END_IF;
      200: (*LOLO*)
          LO := AIVARCFG.PRM_LOENBL;
          LOLO :=  AIVARCFG.PRM_LOLOENBL AND T_STEPMS &gt;= T_DEALL;
          IF (NOT LOLO AND NOT tmpLOLO OR NOT AIVARCFG.PRM_LOLOENBL)
             OR VAL &gt; (AIVARCFG.LOLOSP + HYST) THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 300;
	     AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF LOLO AND tmpBRK AND AIVARCFG.PRM_BRKENBL THEN
             AIVARCFG.STEP1 := 100;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
      300: (*LO*)
          LO := AIVARCFG.PRM_LOENBL AND T_STEPMS &gt;=T_DEAL;
          IF (NOT tmpLO AND NOT LO OR NOT AIVARCFG.PRM_LOENBL)   (*вихід із зони*)
             OR VAL &gt; (AIVARCFG.LOSP + HYST) THEN
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF LO AND tmpLOLO AND AIVARCFG.PRM_LOLOENBL THEN
             AIVARCFG.STEP1 := 200;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF LO AND tmpBRK AND AIVARCFG.PRM_BRKENBL THEN
             AIVARCFG.STEP1 := 100;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
      400: (*norma*)
          IF tmpHI AND AIVARCFG.PRM_HIENBL THEN
             AIVARCFG.STEP1 := 500;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF tmpLO AND AIVARCFG.PRM_LOENBL THEN
             AIVARCFG.STEP1 := 300;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF tmpHIHI AND AIVARCFG.PRM_HIHIENBL THEN
             AIVARCFG.STEP1 := 460;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF tmpLOLO AND AIVARCFG.PRM_LOLOENBL THEN
             AIVARCFG.STEP1 := 420;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF tmpBRK AND AIVARCFG.PRM_BRKENBL THEN
             AIVARCFG.STEP1 := 410;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF tmpOVRLD AND AIVARCFG.PRM_OVRLENBL THEN
             AIVARCFG.STEP1 := 470;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
      410: (*norma -&gt; break*)
          IF NOT tmpBRK OR NOT AIVARCFG.PRM_BRKENBL THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          ELSIF T_STEPMS &gt;= INT_TO_UDINT(T_DEAQALSP)*100 THEN (*тривога*)
             AIVARCFG.STEP1 := 100;
          END_IF;
      420: (*norma -&gt; LOLO*)
          IF NOT tmpLOLO OR NOT AIVARCFG.PRM_LOLOENBL THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          ELSIF T_STEPMS &gt;= T_DEALL THEN (*тривога*)
             AIVARCFG.STEP1 := 200;
          END_IF;
      460: (*norma -&gt; HIHI*)
          IF NOT tmpHIHI OR NOT AIVARCFG.PRM_HIHIENBL THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          ELSIF T_STEPMS &gt;= T_DEAHH THEN (*тривога*)
             AIVARCFG.STEP1 := 600;
          END_IF;
      470: (*norma -&gt; OVRLD*)
          IF NOT tmpOVRLD OR NOT AIVARCFG.PRM_OVRLENBL THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          ELSIF T_STEPMS &gt;= INT_TO_UDINT(T_DEAQALSP)*100 THEN (*тривога*)
             AIVARCFG.STEP1 := 700;
          END_IF;
      500: (*HI*)
          HI := AIVARCFG.PRM_HIENBL AND T_STEPMS &gt;= T_DEAH;
          IF NOT tmpHI AND NOT HI
             OR NOT AIVARCFG.PRM_HIENBL (*вихід із зони*)
             OR VAL &lt; (AIVARCFG.HISP - HYST) THEN
             AIVARCFG.STEP1 := 400;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF HI AND tmpHIHI AND AIVARCFG.PRM_HIHIENBL THEN
             AIVARCFG.STEP1 := 600;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
          IF HI AND tmpOVRLD AND AIVARCFG.PRM_OVRLENBL THEN
             AIVARCFG.STEP1 := 700;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
      600: (*HIHI*)
          HI := AIVARCFG.PRM_HIENBL;
          HIHI := AIVARCFG.PRM_HIHIENBL AND T_STEPMS &gt;= T_DEAHH;
          IF NOT tmpHIHI AND NOT HIHI OR
             NOT AIVARCFG.PRM_HIHIENBL OR
             VAL &lt; (AIVARCFG.HIHISP - HYST) THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 500;
          END_IF;
          IF HI AND tmpOVRLD AND AIVARCFG.PRM_OVRLENBL THEN
             AIVARCFG.STEP1 := 700;
             AIVARCFG.T_STEP1 := 0;
          END_IF;
      700: (*OVRLD - КЗ*)
          HI := AIVARCFG.PRM_HIENBL;
          HIHI := AIVARCFG.PRM_HIHIENBL;
          IF (NOT tmpOVRLD OR NOT AIVARCFG.PRM_OVRLENBL) THEN (*вихід із зони*)
             AIVARCFG.STEP1 := 600;
          ELSIF T_STEPMS &gt;= INT_TO_UDINT(T_DEAQALSP)*100 THEN (*тривога*)
             OVRLD := true;
          END_IF;
   ELSE
      AIVARCFG.STEP1 := 400;
   END_CASE;
ELSE 
   AIVARCFG.VRAW := VRAW;
   AIVARCFG.VAL := VALNOFLT;
   AIVARCFG.T_STEP1 := 0;
   AIVARCFG.STEP1 := 400;
   BAD := false;
   BRK := false;
   LO := false;
   LOLO := false;
   HI := false;
   HIHI := false;
   OVRLD := false;
   ENBL := false;
END_IF;

(*ініціалізація змінних для контролю зависання та стрибків*)
IF PLCCFG.STA_SCN1 THEN
   AIVARCFG.VALPRV_AFRZ := VAL;
   AIVARCFG.VALPRV_ASPD := VAL;
END_IF;

(* Перевірка на зависання *)
(*протягом 20 сек значення повинно змінитися більш ніж на задану уставку у од.вимір якщо уставка 0 - по дефолту*)
IF AIVARCFG.PRM_AFRZENBL THEN
   tmpAFRZ:=AIVARCFG.STA2_AFRZ;
   (*перевіряти на кожній 20 сек на один цикл*)
   IF (PLCCFG.TQ MOD 20) = 0 AND PLCCFG.PLS_P1S THEN
      IF ABS(AIVARCFG.VALPRV_AFRZ - VAL) &lt; AIVARCFG.DEASP_AFRZ THEN
         tmpAFRZ:=true;
      ELSE 
         tmpAFRZ:=false; (*самоскидання*)
      END_IF; 
      AIVARCFG.VALPRV_AFRZ := VAL;
   END_IF;
   (*якщо значення зміниться у будь який час оновити його (відкидання помилки випадкової рівності через вказаний час)  *)
   IF  ABS(VAL - AIVARCFG.VALPRV) &gt; AIVARCFG.DEASP_AFRZ THEN
       AIVARCFG.VALPRV_AFRZ := VAL;
   END_IF; 
   AIVARCFG.STA2_AFRZ := tmpAFRZ;
END_IF;

(* Перевірка на скачок *)
IF AIVARCFG.PRM_ASPDENBL THEN 
  (* аларм швидкості зміни, якщо через заданий час значення скочило більше ніж допуск - помилка WRN*)
  tmpASPD:=false;
  AIVARCFG.STA2_ASPD := tmpASPD;
  (*перевіряти на кожній 5 сек на один цикл*)
  IF (PLCCFG.TQ MOD 5) = 0 AND PLCCFG.PLS_P1S THEN
     IF ABS(AIVARCFG.VALPRV_ASPD - VAL) &gt; AIVARCFG.DOPSP_ASPD THEN
        tmpASPD:=true;
     ELSE 
        tmpASPD:=false; (*самоскидання*)
     END_IF; 
     AIVARCFG.VALPRV_ASPD := VAL;
  END_IF;
  AIVARCFG.STA2_AOVRFL:=VRAW&gt;10100 AND VRAW&lt;10999;
  AIVARCFG.STA2_AUNDRFL:=VRAW&lt;-100 AND VRAW&gt;-999;
  tmpAOVRFL:=AIVARCFG.STA2_AOVRFL;
  tmpAUNDRFL:=AIVARCFG.STA2_AUNDRFL;
END_IF;

(*обробка тривог - визначення загального статусу*)
BAD := (CHCFG.STA_BAD OR BRK OR OVRLD OR tmpAOVRFL OR tmpAUNDRFL OR tmpAFRZ) AND AIVARCFG.PRM_QALENBL AND VARENBL AND NOT SML AND NOT FRC;
ALM := (LOLO OR HIHI) AND NOT BAD;
WRN := (LO OR HI OR tmpASPD) AND NOT ALM AND NOT BAD;

(*передача тривог для змінної PLCCFG для формування загального статусного біта і визначення нової тривоги*)
IF BAD THEN
   PLCCFG.ALM_BAD := true;
   PLCCFG.CNTBAD := PLCCFG.CNTBAD + 1;
   IF NOT AIVARCFG.STA_BAD THEN
      PLCCFG.ALM_NWBAD := true;
   END_IF;
END_IF;

IF ALM THEN
   PLCCFG.ALM_ALM := true;
   PLCCFG.CNTALM := PLCCFG.CNTALM + 1;
   IF NOT AIVARCFG.STA_ALM THEN
      PLCCFG.ALM_NWALM := true;
   END_IF;
END_IF;

IF WRN THEN
   PLCCFG.ALM_WRN := true;
   PLCCFG.CNTWRN := PLCCFG.CNTWRN + 1;
   IF NOT AIVARCFG.STA_WRN THEN
      PLCCFG.ALM_NWWRN := true;
   END_IF;
END_IF;

(*передача статусних бітів для змінної PLCCFG для формування загального статусного біта*)
IF FRC THEN
   PLCCFG.STA_FRC1 := true;
   PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;
IF SML THEN
   PLCCFG.STA_SML := true;
END_IF;

(*передача статусних бітів з внутрішніх змінних в технологічну змінну*)
AIVARCFG.STA_BRK := BRK;
AIVARCFG.STA_OVRLD := OVRLD;
AIVARCFG.STA_BAD := BAD;
AIVARCFG.STA_ALDIS := ALDIS;
AIVARCFG.STA_DLNK := DLNK;
AIVARCFG.STA_ENBL := VARENBL;
AIVARCFG.STA_ALM := ALM;
AIVARCFG.STA_LOLO := LOLO;
AIVARCFG.STA_LO := LO;
AIVARCFG.STA_HI := HI;
AIVARCFG.STA_HIHI := HIHI;
AIVARCFG.STA_WRN := WRN;
AIVARCFG.STA_INBUF := INBUF;
AIVARCFG.STA_FRC := FRC;
AIVARCFG.STA_SML := SML;
AIVARCFG.STA_CMDLOAD := FALSE;

(*значення у % та обмеження*)
VALPROC := (VAL - AIVARCFG.LOENG) / VAL1PROC;
IF VALPROC &lt; 0.0 THEN
   VALPROC := 0.0;
END_IF;
IF VALPROC &gt; 100.0 THEN
   VALPROC := 100.0;
END_IF;

(*передача значення з внутрішніх змінних в технологічну змінну*)
AIVARCFG.VAL := VAL;
AIVARCFG.VRAW := VRAW;
AIVARCFG.VALPRV := VALPRV;

(*VALPROC: старший байт вміщує значення від 0-100%, молодший - біти STA2*)
AIVARCFG.VALPRCSTA2 := REAL_TO_INT(VALPROC)*256 AND 16#FF00;
AIVARCFG.VALPRCSTA2.0 := AIVARCFG.STA2_ASPD;
AIVARCFG.VALPRCSTA2.1 := AIVARCFG.STA2_AFRZ;
AIVARCFG.VALPRCSTA2.2 := AIVARCFG.STA2_AOVRFL;
AIVARCFG.VALPRCSTA2.3 := AIVARCFG.STA2_AUNDRFL;

AIVARCFG.T_PREV := PLCCFG.TQMS; (*запамятовування часу останнього виклику екземпляра функції*)

(*передача значення в HMI частину*)
AIVARHMI.STA := AIVARCFG.STA;
AIVARHMI.VAL := VAL;
AIVARHMI.VALPRCSTA2 := AIVARCFG.VALPRCSTA2;

(*підрахунок часу стану та обмеження його по верхній межі діапазону*)
AIVARCFG.T_STEP1 := AIVARCFG.T_STEP1 + dT1;
IF AIVARCFG.T_STEP1 &gt; 16#7FFF_FFFF THEN
    AIVARCFG.T_STEP1 := 16#7FFF_FFFF;
END_IF;

(*автоматичне оновлення якщо змінна записана в буфер*)
IF INBUF THEN
    VARBUF.CMD := 0;
    VARBUF.VALR := AIVARCFG.VAL;
    VARBUF.STA := AIVARCFG.STA;
    VARBUF.VRAWR := INT_TO_REAL(VRAW);
    IF NOT FRC THEN
        VARBUF.VALR := VAL;
    END_IF;
    VARBUF.STEP1 := AIVARCFG.STEP1;
    VARBUF.T_STEP1 := AIVARCFG.T_STEP1;
    VARBUF.VALPROC := AIVARCFG.VALPRCSTA2;
    VARBUF.LOLOSP_PRC := REAL_TO_INT(AIVARCFG.LOLOSP / VAL1PROC * 100.0);
    VARBUF.LOSP_PRC := REAL_TO_INT(AIVARCFG.LOSP / VAL1PROC * 100.0);
    VARBUF.HISP_PRC := REAL_TO_INT(AIVARCFG.HISP / VAL1PROC * 100.0);
    VARBUF.HIHISP_PRC := REAL_TO_INT(AIVARCFG.HIHISP / VAL1PROC * 100.0);

(*зчитування статусних бітів фізичного каналу технологічної змінної*)
    VARBUF.CH_CLSID := CHCFG.CLSID;
    VARBUF.CH_STA.0 := CHCFG.STA_VRAW;
    VARBUF.CH_STA.1 := CHCFG.STA_VALB;
    VARBUF.CH_STA.2 := CHCFG.STA_BAD;
    VARBUF.CH_STA.3 := CHCFG.STA_b3;
    VARBUF.CH_STA.4 := CHCFG.STA_PNG;
    VARBUF.CH_STA.5 := CHCFG.STA_ULNK;
    VARBUF.CH_STA.6 := CHCFG.STA_MERR;
    VARBUF.CH_STA.7 := CHCFG.STA_BRK;
    VARBUF.CH_STA.8 := CHCFG.STA_SHRT;
    VARBUF.CH_STA.9 := CHCFG.STA_NBD;
    VARBUF.CH_STA.10 := CHCFG.STA_b10;
    VARBUF.CH_STA.11 := CHCFG.STA_INIOTBUF;
    VARBUF.CH_STA.12 := CHCFG.STA_INBUF;
    VARBUF.CH_STA.13 := CHCFG.STA_FRC;
    VARBUF.CH_STA.14 := CHCFG.STA_SML;
    VARBUF.CH_STA.15 := CHCFG.STA_CMDLOAD;

    (*функція обрахунку фізичного значення сигналу в мА,В і т.д*)
    INT_TO_SIGU (CLSID := CHCFG.CLSID, VALINT := VRAW, INT_TO_SIGU =&gt; VARBUF.CH_VALSIG);
END_IF;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(AIVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND AIVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   VARBUFOUT.MSG := 201; 
   VARBUFOUT.PRM.0 := AIVARCFG.PRM_LOENBL;
   VARBUFOUT.PRM.1 := AIVARCFG.PRM_HIENBL;
   VARBUFOUT.PRM.2 := AIVARCFG.PRM_LOLOENBL;
   VARBUFOUT.PRM.3 := AIVARCFG.PRM_HIHIENBL;
   VARBUFOUT.PRM.4 := AIVARCFG.PRM_BRKENBL;
   VARBUFOUT.PRM.5 := AIVARCFG.PRM_OVRLENBL;
   VARBUFOUT.PRM.6 := AIVARCFG.PRM_QALENBL;
   VARBUFOUT.PRM.7 := AIVARCFG.PRM_DSBL;
   VARBUFOUT.PRM.8 := AIVARCFG.PRM_PWLENBL;
   VARBUFOUT.PRM.9 := AIVARCFG.PRM_TOTALON;
   VARBUFOUT.PRM.10 := AIVARCFG.PRM_SQRT;
   VARBUFOUT.PRM.11 := AIVARCFG.PRM_PARAISPROC;
   VARBUFOUT.PRM.12 := AIVARCFG.PRM_AFRZENBL;        
   VARBUFOUT.PRM.13 := AIVARCFG.PRM_ASPDENBL;
   VARBUFOUT.PRM.14 := AIVARCFG.PRM_STATICMAP;
   VARBUFOUT.PRM.15 := AIVARCFG.PRM_NORAW;
    
   VARBUFOUT.ID := AIVARCFG.ID;
   VARBUFOUT.CLSID := AIVARCFG.CLSID;
   VARBUFOUT.CHID := AIVARCFG.CHID;
   VARBUFOUT.VALR := AIVARCFG.VALFRC;
            
   VARBUFOUT.LORAW := AIVARCFG.LORAW;
   VARBUFOUT.HIRAW := AIVARCFG.HIRAW;
   VARBUFOUT.LOENG := AIVARCFG.LOENG;
   VARBUFOUT.HIENG := AIVARCFG.HIENG;
   VARBUFOUT.HIHISP := AIVARCFG.HIHISP;
   VARBUFOUT.HISP := AIVARCFG.HISP;
   VARBUFOUT.LOSP := AIVARCFG.LOSP;
   VARBUFOUT.LOLOSP := AIVARCFG.LOLOSP;
   VARBUFOUT.T_FLTSP := AIVARCFG.T_FLT;
   VARBUFOUT.HYST := AIVARCFG.HYST;
   VARBUFOUT.T_DEAHH := AIVARCFG.T_DEAHH;
   VARBUFOUT.T_DEAH := AIVARCFG.T_DEAH;
   VARBUFOUT.T_DEAL := AIVARCFG.T_DEAL;
   VARBUFOUT.T_DEALL := AIVARCFG.T_DEALL;
            
   VARBUFOUT.VALPRV_AFRZ :=AIVARCFG.VALPRV_AFRZ;
   VARBUFOUT.VALPRV_ASPD :=AIVARCFG.VALPRV_ASPD;
   VARBUFOUT.DEASP_AFRZ :=AIVARCFG.DEASP_AFRZ;
   VARBUFOUT.DOPSP_ASPD := AIVARCFG.DOPSP_ASPD;
   VARBUFOUT.ZERO_CUT_VAL := AIVARCFG.ZERO_CUT_VAL;

   VARBUFIN.CMD :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(AIVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND AIVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   
   VARBUFOUT:=VARBUFIN;
    
   AIVARCFG.PRM_LOENBL := VARBUFIN.PRM.0;
   AIVARCFG.PRM_HIENBL := VARBUFIN.PRM.1;
   AIVARCFG.PRM_LOLOENBL := VARBUFIN.PRM.2;
   AIVARCFG.PRM_HIHIENBL := VARBUFIN.PRM.3;
   AIVARCFG.PRM_BRKENBL := VARBUFIN.PRM.4;
   AIVARCFG.PRM_OVRLENBL := VARBUFIN.PRM.5;
   AIVARCFG.PRM_QALENBL := VARBUFIN.PRM.6;
   AIVARCFG.PRM_DSBL := VARBUFIN.PRM.7;
   AIVARCFG.PRM_PWLENBL := VARBUFIN.PRM.8;
   AIVARCFG.PRM_TOTALON := VARBUFIN.PRM.9;
   AIVARCFG.PRM_SQRT := VARBUFIN.PRM.10;
   AIVARCFG.PRM_PARAISPROC := VARBUFIN.PRM.11;
   AIVARCFG.PRM_AFRZENBL := VARBUFIN.PRM.12;
   AIVARCFG.PRM_ASPDENBL := VARBUFIN.PRM.13;
   AIVARCFG.PRM_STATICMAP := VARBUFIN.PRM.14;
   AIVARCFG.PRM_NORAW := VARBUFIN.PRM.15;
    
   AIVARCFG.LORAW := VARBUFIN.LORAW;
   AIVARCFG.HIRAW := VARBUFIN.HIRAW;
   AIVARCFG.LOENG := VARBUFIN.LOENG;
   AIVARCFG.HIENG := VARBUFIN.HIENG;
   AIVARCFG.HIHISP := VARBUFIN.HIHISP;
   AIVARCFG.HISP := VARBUFIN.HISP;
   AIVARCFG.LOSP := VARBUFIN.LOSP;
   AIVARCFG.LOLOSP := VARBUFIN.LOLOSP;
   AIVARCFG.T_FLT := VARBUFIN.T_FLTSP;
   AIVARCFG.HYST := VARBUFIN.HYST;
   AIVARCFG.T_DEAHH := VARBUFIN.T_DEAHH;
   AIVARCFG.T_DEAH := VARBUFIN.T_DEAH;
   AIVARCFG.T_DEAL := VARBUFIN.T_DEAL;
   AIVARCFG.T_DEALL := VARBUFIN.T_DEALL;
     
   AIVARCFG.VALPRV_AFRZ := VARBUFIN.VALPRV_AFRZ ;
   AIVARCFG.VALPRV_ASPD := VARBUFIN.VALPRV_ASPD ;
   AIVARCFG.DEASP_AFRZ := VARBUFIN.DEASP_AFRZ ;
   AIVARCFG.DOPSP_ASPD :=  VARBUFIN.DOPSP_ASPD ;
   AIVARCFG.ZERO_CUT_VAL := VARBUFIN.ZERO_CUT_VAL  ;       
            
   VARBUFOUT.MSG:=200; 

   IF NOT AIVARCFG.PRM_STATICMAP THEN 
      IF VARBUFIN.CHID&gt;=0 AND VARBUFIN.CHID &lt;= INT_TO_UINT(PLCCFG.AICNT) THEN
         IF CHAI[VARBUFIN.CHID].VARID = 0 THEN 
            AIVARCFG.CHID := VARBUFIN.CHID;
         ELSIF VARBUFIN.CHID &lt;&gt; AIVARCFG.CHID THEN 
            VARBUFOUT.MSG := 403;(* канал вже зайнятий*)
         END_IF;
      ELSE 
         VARBUFOUT.MSG := 404; (*номер каналу не відповідає діапазону*)
      END_IF;
   ELSIF VARBUFIN.CHID &lt;&gt; AIVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
      VARBUFOUT.MSG := 405;(* активна статична адресація каналів*)
   END_IF;

   VARBUFIN.CMD :=0; 
end_if;  
</STSource>
		</FBProgram>
	</FBSource>
	<DDTSource DDTName="CH_CFG" version="0.03" dateTime="dt#2022-01-14-11:13:50">
		<comment>PFW конфігураційна змінна для каналів</comment>
		<attribute name="TypeSignatureCheckSumString" value="7228"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="INT"></variables>
			<variables name="STA_VRAW" typeName="BOOL">
				<comment>=1 – значення дискретного сигналу з дискретного входу</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_VALB" typeName="BOOL">
				<comment>=1 – значення дискретного сигналу для CM верхнього рівня, в режимі FRC=1 може змінюватися із-зовні</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BAD" typeName="BOOL">
				<comment>=1 – є помилка каналу</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_b3" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_PNG" typeName="BOOL">
				<comment>=1 прийшла відповідь від володаря, обнуляється каналом</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_ULNK" typeName="BOOL">
				<comment>=1 – якщо використовується в змінній DIVAR/AIVAR/DOVAR/AOVAR</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_MERR" typeName="BOOL">
				<comment>=1 – є помилка модулю (діагностична інформація)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_BRK" typeName="BOOL">
				<comment>=1 – помилка обриву каналу</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_SHRT" typeName="BOOL">
				<comment>=1 – помилка КЗ</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_NBD" typeName="BOOL">
				<comment>=1 – фізично канал не існує; наприклад, для відображення в буфері модуля MODULS, для використання резерву каналів не прив’язаних до фізичних</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INIOTBUF" typeName="BOOL">
				<comment>=1 - в буфері IoT </comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 – в буфері</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 – значення форсоване</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 – значення імітується</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDLOAD" typeName="BOOL">
				<comment>=1 - запит на зчитування в буфер (тільки з HMI)</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>командне слово</comment>
			</variables>
			<variables name="VAL" typeName="INT">
				<comment>значення змінної</comment>
			</variables>
			<variables name="VARID" typeName="UINT">
				<comment>ID привязаної змінної</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="AIVAR_HMI" version="0.01" dateTime="dt#2022-01-06-17:21:54">
		<comment>PFW структура AIVAR для HMI  </comment>
		<attribute name="TypeSignatureCheckSumString" value="3237"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="VALPRCSTA2" typeName="INT">
				<comment>значення у % від шкали вимірювання (0-10000) + додаткові біти статусу</comment>
			</variables>
			<variables name="VAL" typeName="REAL">
				<comment>масштабоване значення</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="VARBUF" version="0.03" dateTime="dt#2022-01-08-17:23:40">
		<comment>PFW буфер для VARs</comment>
		<attribute name="TypeSignatureCheckSumString" value="0E8F"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор завантаженої в буфер змінної</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>CLSID завантаженої в буфер змінної</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>статус + біт команди завантаження в буфер</comment>
			</variables>
			<variables name="CMD" typeName="UINT">
				<comment>команда</comment>
			</variables>
			<variables name="VALPROC" typeName="INT">
				<comment>значення у % від шкали вимірювання (0-10000)</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>номер кроку</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>бітові параметри</comment>
			</variables>
			<variables name="CHID" typeName="UINT">
				<comment>Логічний номер вхідного аналогового каналу CH</comment>
			</variables>
			<variables name="VALR" typeName="REAL">
				<comment>масштабоване значення</comment>
			</variables>
			<variables name="VRAWR" typeName="REAL">
				<comment>сире значення</comment>
			</variables>
			<variables name="LORAW" typeName="INT">
				<comment>AI/AO – Сире (немасштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIRAW" typeName="INT">
				<comment>AI/AO – Сире (немасштабоване) значення максимуму</comment>
			</variables>
			<variables name="LOENG" typeName="REAL">
				<comment>AI/AO – Інженерне (масштабоване) значення мінімуму</comment>
			</variables>
			<variables name="HIENG" typeName="REAL">
				<comment>AI/AO – Інженерне (масштабоване) значення максимуму</comment>
			</variables>
			<variables name="TMPR" typeName="REAL">
				<comment>резерв</comment>
			</variables>
			<variables name="MVAL" typeName="REAL">
				<comment>AO – значення форсування</comment>
			</variables>
			<variables name="HIHISP" typeName="REAL">
				<comment>AI  - Уставка тривоги HIHI</comment>
			</variables>
			<variables name="HISP" typeName="REAL">
				<comment>AI – Уставка тривоги HI</comment>
			</variables>
			<variables name="LOSP" typeName="REAL">
				<comment>AI – Уставка тривоги LO</comment>
			</variables>
			<variables name="LOLOSP" typeName="REAL">
				<comment>AI  - Уставка тривоги LOLO</comment>
			</variables>
			<variables name="HIHISP_PRC" typeName="INT">
				<comment>AI – Уставка тривоги HIHI у 0.01 % (для відображення)</comment>
			</variables>
			<variables name="HISP_PRC" typeName="INT">
				<comment>AI – Уставка тривоги HI у 0.01 % (для відображення)</comment>
			</variables>
			<variables name="LOSP_PRC" typeName="INT">
				<comment>AI – Уставка тривоги LO у 0.01 % (для відображення)</comment>
			</variables>
			<variables name="LOLOSP_PRC" typeName="INT">
				<comment>AI – Уставка тривоги LOLO у 0.01 % (для відображення)</comment>
			</variables>
			<variables name="T_FLTSP" typeName="UINT">
				<comment>AI – заданий час фільтрації для експоненціального фільтру 0 – не фільтрувати; DI – час фільтрації для дискретного фільтру 0 – не фільтрувати</comment>
			</variables>
			<variables name="MSG" typeName="UINT">
				<comment>повідомлення</comment>
			</variables>
			<variables name="HYST" typeName="REAL">
				<comment>AI – гістерезис в реальних одиницях або % (PRM_PARAISPROC)</comment>
			</variables>
			<variables name="T_DEAHH" typeName="UINT">
				<comment>AI  Час затримки на виникнення тривоги HH в 0.1 секундах</comment>
			</variables>
			<variables name="T_DEAH" typeName="UINT">
				<comment>AI  Час затримки на виникнення тривоги H в 0.1 секундах</comment>
			</variables>
			<variables name="T_DEAL" typeName="UINT">
				<comment>AI  Час затримки на виникнення тривоги L в 0.1 секундах</comment>
			</variables>
			<variables name="T_DEALL" typeName="UINT">
				<comment>AI – Час затримки на виникнення тривоги LL в 0.1 секундах; DI – Час затримки на виникнення тривоги в секундах</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Час кроку в мілісекундах</comment>
			</variables>
			<variables name="OPTR" typeName="ARRAY[0..3] OF REAL">
				<comment>Масив додаткових змінних REAL</comment>
			</variables>
			<variables name="OPTD" typeName="ARRAY[0..3] OF DINT">
				<comment>Масив додаткових змінних UDINT</comment>
			</variables>
			<variables name="VALPRV_AFRZ" typeName="REAL">
				<comment>значення на попередньому перерахунку контролю зависання (Енікон)</comment>
			</variables>
			<variables name="VALPRV_ASPD" typeName="REAL">
				<comment>значення на попередньому перерахунку контролю скачку (Енікон)</comment>
			</variables>
			<variables name="DEASP_AFRZ" typeName="REAL">
				<comment>уставка нечутливості контролю зависання (Енікон)</comment>
			</variables>
			<variables name="DOPSP_ASPD" typeName="REAL">
				<comment>уставка допуску контролю швидкості (Енікон)</comment>
			</variables>
			<variables name="ZERO_CUT_VAL" typeName="REAL">
				<comment>відсічка нуля </comment>
			</variables>
			<variables name="CH_CLSID" typeName="UINT">
				<comment>ідентифікатор класу каналу</comment>
			</variables>
			<variables name="CH_STA" typeName="INT">
				<comment>стани каналу</comment>
			</variables>
			<variables name="CH_VALSIG" typeName="REAL">
				<comment>значення каналу в одиницях вимірювання</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="PLC_CFG" version="0.12" dateTime="dt#2022-07-25-11:17:57">
		<comment>PFW структура для системної інфи</comment>
		<attribute name="TypeSignatureCheckSumString" value="1691"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>16#21xx</comment>
			</variables>
			<variables name="STA" typeName="UINT"></variables>
			<variables name="STA_CON2ERR" typeName="BOOL">
				<comment>є помилка звязку з сусідні ПЛК в парі (для теплого резерування)</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_PLC2STOP" typeName="BOOL">
				<comment>спарений ПЛК в стопі (для теплого резерування)</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_BLK" typeName="BOOL">
				<comment>є хоча б один заблокований ВМ</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_ALDIS" typeName="BOOL">
				<comment>є хоча б одна відключена тривога</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_DIOON" typeName="BOOL">
				<comment>йде опитування по мережі (MODBUS або аналогічній) засобів віддаленого вводу/виводу</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_DIOERR" typeName="BOOL">
				<comment>є помилка на DIO</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_DBLCKALL" typeName="BOOL">
				<comment>усі приводи розблоковані</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>хоча б одна змінна форсована на будь якому рівні</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_SMLALL" typeName="BOOL">
				<comment>все в режимі в імітації, примушує усі CM перейти в режим імітації</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_DISP" typeName="BOOL">
				<comment>хоча б один елемент в режимі ручного управління</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_FRC2" typeName="BOOL">
				<comment>є хоча б один форсований керівний елемент (рівня 2), клапан, двигун</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_FRC1" typeName="BOOL">
				<comment>хоча б одна змінна форсована (рівня 1)</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_SCN1" typeName="BOOL">
				<comment>перший скан</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_FRC0" typeName="BOOL">
				<comment>хоча б одна змінна форсована (рівня 0)</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment> хоча б один об’єкт в режимі імітації</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_CMDACK" typeName="BOOL">
				<comment>підтвердження команди, команда пройшла через весь цикл задачі і отримана усіма</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="UINT">
				<comment>Команди з HMI</comment>
			</variables>
			<variables name="CMDPRG" typeName="UINT">
				<comment>Команди з програмного керування (побітові)</comment>
			</variables>
			<variables name="PRM1" typeName="UINT">
				<comment>дискретні параметри</comment>
			</variables>
			<variables name="PRM2" typeName="UINT">
				<comment>дискретні параметри</comment>
			</variables>
			<variables name="PLS" typeName="UINT">
				<comment>бітові міандри та імпульси по часу</comment>
			</variables>
			<variables name="PLS_P100MS" typeName="BOOL">
				<comment>100 мс</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PLS_P200MS" typeName="BOOL">
				<comment>200 мс</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="PLS_P500MS" typeName="BOOL">
				<comment>500 мс</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="PLS_P1S" typeName="BOOL">
				<comment>1 с</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="PLS_P2S" typeName="BOOL">
				<comment>2 с</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="PLS_P5S" typeName="BOOL">
				<comment>5 с</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="PLS_P10S" typeName="BOOL">
				<comment>10 с</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="PLS_P60S" typeName="BOOL">
				<comment>1 хв</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="PLS_M1S" typeName="BOOL">
				<comment>меандр з періодом 1 с (0.5 с + 0.5 с)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="PLS_M2S" typeName="BOOL">
				<comment>меандр з періодом 2 с (1 с + 1 с)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="PLS_b10" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="PLS_b11" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="PLS_NEWMIN" typeName="BOOL">
				<comment>=1 на один цикл основної задачі – початок хвилини</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="PLS_NEWHR" typeName="BOOL">
				<comment>=1 на один цикл основної задачі – початок години</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="PLS_NEWDAY" typeName="BOOL">
				<comment>=1 на один цикл основної задачі – початок доби</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="PLS_NEWSHIFT" typeName="BOOL">
				<comment>=1 на один цикл основної задачі – початок зміни</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM1" typeName="UINT"></variables>
			<variables name="ALM_ALM" typeName="BOOL">
				<comment>активна технологічна тривога</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_NWALM" typeName="BOOL">
				<comment>зявилась нова технологічна тривога</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_ALMNACK" typeName="BOOL">
				<comment>квітування технологічної тривоги</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_WRN" typeName="BOOL">
				<comment>активне технологічне попередження</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_NWWRN" typeName="BOOL">
				<comment>зявилось нове технологічне попередження</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_WRNNACK" typeName="BOOL">
				<comment>квітування технологічного попередження</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_BAD" typeName="BOOL">
				<comment>активна тривога недостовірності даних</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_NWBAD" typeName="BOOL">
				<comment>нова тривога недостовірності даних</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_BADNACK" typeName="BOOL">
				<comment>квітування тривоги недостовірності даних</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_EMCYSTP" typeName="BOOL">
				<comment>швидкий зупин</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_STP2RUN" typeName="BOOL">
				<comment>є перехід з стану стоп в стан ран</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_CON2ERR" typeName="BOOL">
				<comment>є помилка звязку з сусідні ПЛК в парі (для теплого резерування)</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_PLC2STOP" typeName="BOOL">
				<comment>спарений ПЛК в стопі (для теплого резерування)</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_DIOERR" typeName="BOOL">
				<comment>є помилка на DIO </comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_PLCERR" typeName="BOOL">
				<comment>є апаратна помилка (ПЛК)</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_CONHIERR" typeName="BOOL">
				<comment>є помилка звязку з верхнім рівнем</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM2" typeName="INT">
				<comment>біти алармів</comment>
			</variables>
			<variables name="STEP1" typeName="INT">
				<comment>крок основної програми</comment>
			</variables>
			<variables name="T_STEP1" typeName="INT">
				<comment>час кроку основної програми обробки, в (с)</comment>
			</variables>
			<variables name="MSG" typeName="UDINT">
				<comment>час кроку основної програми обробки, в (с)</comment>
			</variables>
			<variables name="TQ" typeName="UDINT">
				<comment>загальний час з початку 1-го циклу контролера (в секундах)</comment>
			</variables>
			<variables name="TQM" typeName="UDINT">
				<comment>загальний час роботи ПЛК з моменту пуску (в хвилинах)</comment>
			</variables>
			<variables name="DICNT" typeName="INT">
				<comment>кількість наявних каналів DI</comment>
			</variables>
			<variables name="DOCNT" typeName="INT">
				<comment>кількість наявних каналів DO</comment>
			</variables>
			<variables name="AICNT" typeName="INT">
				<comment>кількість наявних каналів AI</comment>
			</variables>
			<variables name="AOCNT" typeName="INT">
				<comment>кількість наявних каналів AO</comment>
			</variables>
			<variables name="NOW" typeName="ARRAY[0..3] OF INT">
				<comment>плинний час астрономічний час в BCD форматі</comment>
				<instanceElementDesc name="[1]">
					<comment>hour  minute (16#hhmm)</comment>
				</instanceElementDesc>
				<instanceElementDesc name="[0]">
					<comment>seconds,-- (16#ss,--)</comment>
				</instanceElementDesc>
				<instanceElementDesc name="[2]">
					<comment>month, day (16#mmdd)</comment>
				</instanceElementDesc>
				<instanceElementDesc name="[3]">
					<comment>year (16#yyyy)</comment>
				</instanceElementDesc>
			</variables>
			<variables name="SHIFTPARA" typeName="ARRAY[0..3] OF INT">
				<comment>Години передачі змін (максимум 3 зміни): SHIFT[0] – кількість змін SHIFT[1] – передача 1-ї зміни (BCD 16#hhmm) SHIFT[2] – передача 2-ї зміни (BCD 16#hhmm)  SHIFT[3] – передача 3-ї зміни (BCD 16#hhmm)</comment>
			</variables>
			<variables name="SHIFTNMB" typeName="UINT">
				<comment>номер активної зміни</comment>
			</variables>
			<variables name="CNTALM" typeName="UINT">
				<comment>лічильник кількості активних тривог "аварія"</comment>
			</variables>
			<variables name="CNTWRN" typeName="UINT">
				<comment>лічильник кількостіактивних тривог "попередження"</comment>
			</variables>
			<variables name="CNTBAD" typeName="UINT">
				<comment>лічильник кількостіактивних тривог "недостовірність"</comment>
			</variables>
			<variables name="CNTFRC" typeName="UINT">
				<comment>лічильник кількостіфорсованих об'єктів</comment>
			</variables>
			<variables name="CNTMAN" typeName="UINT">
				<comment>лічильник кількості ВМ в ручному режимі</comment>
			</variables>
			<variables name="TSK_LTIME" typeName="UINT">
				<comment>плинний (останній) час задачі в мілісекундах</comment>
			</variables>
			<variables name="TSK_MAXTIME" typeName="UINT">
				<comment>максимальний час задачі в мілісекундах</comment>
			</variables>
			<variables name="STA_PERM" typeName="INT">
				<comment>повторює STA, який був на початку виклику функції</comment>
			</variables>
			<variables name="ALM1_PERM" typeName="INT">
				<comment>повторює ALM1, який був на початку виклику функції</comment>
			</variables>
			<variables name="CNTALM_PERM" typeName="UINT">
				<comment>лічильник кількості активних тривог "аварія"</comment>
			</variables>
			<variables name="CNTWRN_PERM" typeName="UINT">
				<comment>лічильник кількостіактивних тривог "попередження"</comment>
			</variables>
			<variables name="CNTBAD_PERM" typeName="UINT">
				<comment>лічильник кількостіактивних тривог "недостовірність"</comment>
			</variables>
			<variables name="CNTFRC_PERM" typeName="UINT">
				<comment>лічильник кількостіфорсованих об'єктів</comment>
			</variables>
			<variables name="CNTMAN_PERM" typeName="UINT">
				<comment>лічильник кількості ВМ в ручному режимі</comment>
			</variables>
			<variables name="MODULSCNT" typeName="INT">
				<comment>кількість модулів</comment>
			</variables>
			<variables name="NOWns" typeName="UDINT">
				<comment>нс (наносекунди) для плинного астрономічного часу</comment>
			</variables>
			<variables name="TQMS" typeName="UDINT">
				<comment>мілісекундний лічильник, скидається при старті або після переповнення</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="SCALING" version="0.03" dateTime="dt#2022-07-16-10:19:09">
		<comment>PFW масштабування</comment>
		<attribute name="TypeCodeCheckSumString" value="77C7"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="CCDF"></attribute>
		<inputParameters>
			<variables name="IN" typeName="REAL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="in_min" typeName="REAL">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="in_max" typeName="REAL">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="out_min" typeName="REAL">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="out_max" typeName="REAL">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="STA" typeName="INT">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="PRM" typeName="INT">
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="SCALING" typeName="REAL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="PRM_SQRT" typeName="BOOL"></variables>
			<variables name="PRM_CUT" typeName="BOOL"></variables>
			<variables name="STA_ERR" typeName="BOOL"></variables>
			<variables name="STA_EQINLIMS" typeName="BOOL"></variables>
			<variables name="STA_EQOUTLIMS" typeName="BOOL"></variables>
			<variables name="tmpOUT" typeName="REAL"></variables>
			<variables name="tmpIN" typeName="REAL"></variables>
		</privateLocalVariables>
		<FBProgram name="SCALING">
			<STSource>PRM_SQRT := PRM.0;
PRM_CUT := PRM.1;
STA_ERR :=0;
STA_EQINLIMS :=0;
STA_EQOUTLIMS :=0;
SCALING:=out_min;

IF ABS(out_max - out_min)&lt;0.00001 THEN
    STA_EQOUTLIMS:=true; STA_ERR:=true;
END_IF; 
IF ABS(in_max - in_min)&lt;0.00001 THEN
    STA_EQINLIMS:=true; STA_ERR:=true;
END_IF;

IF NOT STA_ERR THEN  
    tmpIN := IN; 
    IF PRM_SQRT THEN (*квадратичне масштабування*)
        IF tmpIN&gt;0.0 and out_max&gt;0.0 THEN    
        	tmpIN:=SQRT(tmpIN)*SQRT(out_max);
	else
		tmpIN:=0.0;
	END_IF;
    ELSE (*лінійне масштабування*)
        tmpIN:=IN;
    END_IF;  
    
    tmpOUT := out_min + (tmpIN - in_min) * (out_max - out_min) / (in_max - in_min);
    IF PRM_CUT THEN
        IF tmpOUT &gt; out_max THEN
            tmpOUT:=out_max; 
        END_IF;
        IF tmpOUT &lt; out_min THEN
            tmpOUT:=out_min; 
        END_IF;
    END_IF;
    SCALING:=tmpOUT;
ELSE 
    ;
END_IF;

STA.0:= STA_ERR;
STA.1:= STA_EQINLIMS;
STA.2:= STA_EQOUTLIMS;
</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="A_FLTR" version="0.04" dateTime="dt#2022-07-16-19:36:14">
		<comment>PFW фільтрація</comment>
		<attribute name="TypeCodeCheckSumString" value="E59A"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="C4BD"></attribute>
		<inputParameters>
			<variables name="IN" typeName="REAL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="dT1" typeName="UDINT">
				<comment>час між викликами в мс</comment>
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="T_FLT" typeName="UDINT">
				<comment>час фільтрації</comment>
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="PRM" typeName="INT">
				<comment>бітові параметри</comment>
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>стан</comment>
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="VALPRV" typeName="REAL">
				<comment>значення з поепереднього та для наступного виклику</comment>
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="A_FLTR" typeName="REAL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="SaveVal" typeName="REAL"></variables>
			<variables name="dTr" typeName="REAL"></variables>
			<variables name="T_FLTr" typeName="REAL"></variables>
		</privateLocalVariables>
		<FBProgram name="A_FLTR">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0
https://github.com/pupenasan/PACFramework/tree/master/platforms/unitypro/A_FLTR.md *)
(*експоненційна фільтрація*)
dTr:=UDINT_TO_REAL(dT1);
T_FLTr:=UDINT_TO_REAL(T_FLT);
SaveVal := VALPRV;
A_FLTR := dTr / (2.0 * T_FLTr + (dTr)) * (IN - SaveVal) + SaveVal;
VALPRV := IN - (2.0 * T_FLTr - (dTr)) / (2.0 * T_FLTr + (dTr)) * (IN - SaveVal); 
</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="INT_TO_SIGU" version="0.02" dateTime="dt#2022-07-16-10:19:09">
		<comment>PFW перетворення одиниць ПЛК в вимірювальні одиниці</comment>
		<attribute name="TypeCodeCheckSumString" value="57B7"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="9477"></attribute>
		<inputParameters>
			<variables name="CLSID" typeName="UINT">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="VALINT" typeName="INT">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
		</inputParameters>
		<outputParameters>
			<variables name="INT_TO_SIGU" typeName="REAL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="RAWMIN" typeName="REAL"></variables>
			<variables name="RAWMAX" typeName="REAL"></variables>
			<variables name="SIGMIN" typeName="REAL"></variables>
			<variables name="SIGMAX" typeName="REAL"></variables>
			<variables name="VALREAL" typeName="REAL"></variables>
		</privateLocalVariables>
		<FBProgram name="INT_TO_SIGU">
			<STSource>(*перетворення одиниць ПЛК в вимірювальні одиниці
 CHAI
- 16#0030 - загальний клас без означення типу сигналу
- 16#0031 - 4..20 mA
- 16#0032 - 0..20 mA
- 16#0033 - 0..10 V
- 16#0034 - термометр опору (без означення типу)
- 16#0035 - термопара (без означення типу)
 CHAO
- 16#0040 - загальний клас без означення типу сигналу
- 16#0041 - 4..20 mA
- 16#0042 - 0..20 mA
- 16#0043 - 0..10 V

Інші класи задаються при необхідності.
*)
(*10000*)
RAWMIN := 0.0;
RAWMAX := 10000.0;
VALREAL := INT_TO_REAL (VALINT);
CASE CLSID OF
  16#0031,16#0041 :  (*// 4..20 mA*)
    SIGMIN := 4.0; SIGMAX := 20.0;
  16#0032,16#0042 :  (*// 0..20 mA*)
    SIGMIN := 0.0; SIGMAX := 20.0;
  16#0033, 16#0043:  (*// 0..10 V*)
    SIGMIN := 0.0; SIGMAX := 10.0;

ELSE  (*%*)
    SIGMIN := 0.0; SIGMAX := 100.0;
END_CASE;

INT_TO_SIGU := SIGMIN + (INT_TO_REAL(VALINT) - RAWMIN)*(SIGMAX-SIGMIN)/(RAWMAX - RAWMIN);
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_ndichs" type="SR" task="MAST"></identProgram>
		<STSource>
		</STSource>
	</program>
	<program>
		<identProgram name="A_moduls" type="SR" task="MAST"></identProgram>
		<STSource>(*перебір усіх модулів*)
FOR i := 0 TO PLC.MODULSCNT - 1 DO
    PFWV.modtype := MODULES[i].TYPE1; (*//тип модуля*)
    PFWV.modchcnts := MODULES[i].CHCNTS;(*//кількість каналів в кожному підмодулі*)
    PFWV.modSTA := 0; (*стан*)
    PFWV.modSTA2:=0; (*стан2*)
    (*проходження по підмодулям*)
    FOR j := 0 TO 3 DO
        PFWV.zm := int_to_uint(12 - 4 * j); (*зміщення для SHIFT*)
        (*тип підмодуля*)
        PFWV.sbmtype := SHR(IN := UINT_TO_INT(PFWV.modtype), N := PFWV.zm) AND 16#000F;
        (*кількість каналів у підмодулі*)
        PFWV.sbmchcnts:= (SHR(IN := UINT_TO_INT(PFWV.modchcnts), N := PFWV.zm) AND 16#000F) +1;
        (*початковий індекс каналу *)
        PFWV.sbmstrtnmb := MODULES[i].STRTNMB[j];
        (*перевірка бітових команд*)
        PFWV.mask := 16#0800; (*маска для зміщення біту команди*)
        PFWV.cmdLoadsbm := (MODULES[i].STA AND SHR(IN := PFWV.mask, N :=INT_TO_UINT(j)))&lt;&gt;0 AND PFWV.sbmtype&lt;&gt;0;
        (*завантаження в буфер підмодуля*)
        IF PFWV.cmdLoadsbm THEN
            SUBMODULE.TYPE1 := PFWV.sbmtype;
            SUBMODULE.CNT := PFWV.sbmchcnts;
            SUBMODULE.STRTNMB := UINT_TO_INT(PFWV.sbmstrtnmb);
        END_IF;
        (*визначення помилки на модулі по біту MERR першого каналу в модулі*)
        CASE PFWV.sbmtype OF
            1:  (*DI*)
                PFWV.sbmbad := CHDI_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            2:  (*DQ*)
                PFWV.sbmbad := CHDO_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            3:  (*AI*)
                PFWV.sbmbad := CHAI_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            4:  (*AO*)
                PFWV.sbmbad := CHAO_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            6:  (*NDI*)
                PFWV.sbmbad := CHNDI_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            7:  (*NDQ*)
                PFWV.sbmbad := CHNDO_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            8:  (*NAI*)
                PFWV.sbmbad := CHNAI_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
            9:  (*NAO*)
                PFWV.sbmbad := CHNAO_HMI[PFWV.sbmstrtnmb].STA.6; (*MERR*)
        END_CASE;
        PFWV.mask := 16#0008; (*маска для зміщення біту помилки*)
        IF PFWV.sbmbad THEN
            PFWV.modSTA := PFWV.modSTA OR SHR(IN := PFWV.mask, N := INT_TO_UINT(j));
        END_IF;
        (*визначення того, що цей підмодуль в буфері*)  
        PFWV.inbuf := PFWV.sbmtype&lt;&gt;0 AND (SUBMODULE.TYPE1 = PFWV.sbmtype) AND (SUBMODULE.STRTNMB = UINT_TO_INT(PFWV.sbmstrtnmb));
        PFWV.mask := 16#0080;
        IF PFWV.inbuf THEN
            PFWV.modSTA := PFWV.modSTA OR SHR(IN := PFWV.mask, N := INT_TO_UINT(j));
        END_IF;
        (*визначення що є хоча б один форсований канал hasfrc і хоча б один вільний канал hasfree 11.10.21*)
        PFWV.hasfrc:=false; 
	PFWV.hasfree:=false;
        FOR k := 0 TO PFWV.sbmchcnts-1 DO
            CASE PFWV.sbmtype OF
                1:  (*DI*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHDI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := PFWV.hasfree OR NOT CHDI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_ULNK;
                2:  (*DQ*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHDO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := PFWV.hasfree OR NOT CHDO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_ULNK;
                3:  (*AI*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHAI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := PFWV.hasfree OR NOT CHAI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_ULNK;
                4:  (*AO*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHAO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := PFWV.hasfree OR NOT CHAO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_ULNK;
                6:  (*NDI*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHNDI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := false;
                7:  (*NDQ*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHNDO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := false;
                8:  (*NAI*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHNAI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := false;
                9:  (*NAO*)
                    PFWV.hasfrc := PFWV.hasfrc OR CHNAO[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA_FRC;
                    PFWV.hasfree := false;
            END_CASE;
        END_FOR;
        PFWV.mask := 16#0008;
        IF PFWV.hasfrc THEN
            PFWV.modSTA2 := PFWV.modSTA2 OR SHR(IN := PFWV.mask, N := INT_TO_UINT(j));
        END_IF;
        PFWV.mask := 16#0080;
        IF PFWV.hasfree THEN
            PFWV.modSTA2 := PFWV.modSTA2 OR SHR(IN := PFWV.mask, N := INT_TO_UINT(j));
        END_IF;

        (*робота підмодулем в буфері*)
        IF PFWV.inbuf THEN
            PFWV.sbmCMD := SUBMODULE.CMD; (*команда для підмодуля*)
            (*перевірка команди і завантаження значення каналів в буфер *)
            FOR k := 0 TO PFWV.sbmchcnts-1 DO
                PFWV.cmdLoadch := PFWV.sbmCMD = (k + 1); (*завантажити канал*)
                CASE PFWV.sbmtype OF
                    1:  (*DI*)
                        CHDI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHDI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    2:  (*DQ*)
                        CHDO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHDO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    3:  (*AI*)
                        CHAI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHAI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    4:  (*AO*)
                        CHAO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHAO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    6:  (*NDI*)
                        CHNDI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHNDI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    7:  (*NDQ*)
                        CHNDO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHNDO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    8:  (*NAI*)
                        CHNAI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHNAI_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                    9:  (*NAO*)
                        CHNAO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k].STA.15 := PFWV.cmdLoadch;
                        SUBMODULE.CH[k] := CHNAO_HMI[UINT_TO_INT(PFWV.sbmstrtnmb) + k];
                END_CASE;
            END_FOR;
            SUBMODULE.CMD := 0;
        END_IF;
    END_FOR;
    
    (*запис стану в модуль*)
    MODULES[i].STA := PFWV.modSTA;
    MODULES[i].STA2:= PFWV.modSTA2;
    
END_FOR;

FOR i := 0 TO 15 DO
  SUBMODULE.CH[i].STA.9:=SUBMODULE.CNT-1&lt;i;
END_FOR;
</STSource>
	</program>
	<DDTSource DDTName="CH_HMI" version="0.03" dateTime="dt#2022-01-14-11:13:56">
		<comment>PFW структура каналу для HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="0154"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти статусу STA+CMD (X15 - CMDLOAD)</comment>
			</variables>
			<variables name="VAL" typeName="INT">
				<comment>значення змінної</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="SUBMODULE" version="0.01" dateTime="dt#2022-01-04-12:39:59">
		<comment>PFW відображення підмодуля</comment>
		<attribute name="TypeSignatureCheckSumString" value="A13C"></attribute>
		<structure>
			<variables name="STRTNMB" typeName="INT">
				<comment>номер початкового каналу для відображення конкретного підмодуля</comment>
			</variables>
			<variables name="CNT" typeName="INT">
				<comment>кількість каналів</comment>
			</variables>
			<variables name="TYPE1" typeName="INT">
				<comment>тип каналів</comment>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда: 1..16 - завантажити канал в буфер</comment>
			</variables>
			<variables name="CH" typeName="ARRAY[0..15] OF CH_HMI">
				<comment>канали вибраного модуля</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="MODULE" version="0.02" dateTime="dt#2022-01-04-15:01:13">
		<comment>PFW структура для карти модуля </comment>
		<attribute name="TypeSignatureCheckSumString" value="FEAB"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>стан/команда модуля для HMI</comment>
			</variables>
			<variables name="TYPE1" typeName="UINT">
				<comment>типи Submodule, комбінація в 16-комвому форматі BCD (0 - відсутній, 1- DICH, 2- DOCH, 3- AICH, 4 – AOCH, 5 - COM)</comment>
			</variables>
			<variables name="CHCNTS" typeName="UINT">
				<comment>кількість каналів на кожен Submodule, комбінація в 16-ковому форматі + 1 (16#XYZQ) X - для першого субмодуля</comment>
			</variables>
			<variables name="STA2" typeName="INT">
				<comment>додаткові стани модуля для HMI</comment>
			</variables>
			<variables name="STRTNMB" typeName="ARRAY[0..3] OF UINT">
				<comment>номер початкового каналу для відображення конкретного підмодуля</comment>
			</variables>
		</structure>
	</DDTSource>
	<program>
		<identProgram name="A_naochs" type="SR" task="MAST"></identProgram>
		<STSource>
		</STSource>
	</program>
	<program>
		<identProgram name="A_procexmpl" type="SR" task="MAST"></identProgram>
		<STSource>(* приклад процедурного керування, 
потрібен для автоматичного пітягування зв'язаних бібліотечних елементів
за непотрбіності - видалити*)


PH_EXMPL1 (ID := 1,
           CFG := PHCFG_EXMPL1,
           HMI := PHHMI_EXMPL1,
           CTRL := PHCTRL_EXMPL1,
           PRCBUF := PRCBUF,
           PLCCFG := PLC,
           PARA := PHPARA_EXMPL1,
           INOUT := PHINOUT_EXMPL1);
</STSource>
	</program>
	<DDTSource DDTName="PROC_CFG" version="0.03" dateTime="dt#2022-09-10-21:46:10">
		<comment>PFW конфігураційна змінна PROC</comment>
		<attribute name="TypeSignatureCheckSumString" value="E7D4"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>ІДЕНТИФІКАТОР</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>КЛАС</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>стани</comment>
			</variables>
			<variables name="ENCMD_START" typeName="BOOL">
				<comment>=1, дозвіл на команду HMI START</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ENCMD_PAUSE" typeName="BOOL">
				<comment>дозвіл на команду HMI PAUSE</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ENCMD_RESET" typeName="BOOL">
				<comment>дозвіл на команду HMI RESET</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ENCMD_HOLD" typeName="BOOL">
				<comment>дозвіл на команду HMI HOLD</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ENCMD_STOP" typeName="BOOL">
				<comment>дозвіл на команду HMI STOP</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ENCMD_CANCEL" typeName="BOOL">
				<comment>дозвіл на команду HMI негативне підтвердження (відміна) ручної операції</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ENCMD_NEXT" typeName="BOOL">
				<comment>дозвіл на команду HMI перейти до наступного кроку</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ENCMD_OK" typeName="BOOL">
				<comment>дозвіл на команду HMI  підтвердити дію</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="TMAXERR" typeName="BOOL">
				<comment>помилка максимуму часу виконання, час більше максимуму</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="TMINERR" typeName="BOOL">
				<comment>помилка мінімуму часу виконання, час менше мінімуму</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_ALM" typeName="BOOL">
				<comment>наявність помилки процедури</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="SEMI" typeName="BOOL">
				<comment>=1 напівавтоматичний режим</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="INBUF" typeName="BOOL">
				<comment>зайнятість буферу</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="MAN" typeName="BOOL">
				<comment>=1, ручний режим</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ENBL" typeName="BOOL">
				<comment>дозвіл на запуск</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="CMD_BUF" typeName="BOOL">
				<comment>завантажити в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда з іншого джерела</comment>
			</variables>
			<variables name="PRM" typeName="INT">
				<comment>БІТОВІ ПАРАМЕТРИ</comment>
			</variables>
			<variables name="rez1" typeName="INT"></variables>
			<variables name="STEP1" typeName="UINT">
				<comment>КРОК ВСІЄЇ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="STEP2" typeName="UINT">
				<comment>КРОК В СЕРЕДИНІ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>ЧАС КРОКУ ВСІЄЇ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="T_STEP2" typeName="UDINT">
				<comment>ЧАС КРОКУ В СЕРЕДИНІ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="T_DELAY" typeName="UDINT">
				<comment>ЗАТРИМКА</comment>
			</variables>
			<variables name="TMIN" typeName="UDINT">
				<comment>МІНІМАЛЬНИЙ ЧАС АКТИВНОСТІ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="TMAX" typeName="UDINT">
				<comment>МАКСИМАЛЬНИЙ ЧАС АКТИВНОСТІ ПРОЦЕДУРИ</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="PROC_HMI" version="0.03" dateTime="dt#2022-09-10-21:46:05">
		<comment>PFW змінна HMI для PROC</comment>
		<attribute name="TypeSignatureCheckSumString" value="0ECE"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>стани</comment>
			</variables>
			<variables name="ENCMD_START" typeName="BOOL">
				<comment>=1, дозвіл на команду HMI START</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ENCMD_PAUSE" typeName="BOOL">
				<comment>дозвіл на команду HMI PAUSE</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ENCMD_RESET" typeName="BOOL">
				<comment>дозвіл на команду HMI RESET</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ENCMD_HOLD" typeName="BOOL">
				<comment>дозвіл на команду HMI HOLD</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ENCMD_STOP" typeName="BOOL">
				<comment>дозвіл на команду HMI STOP</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ENCMD_CANCEL" typeName="BOOL">
				<comment>дозвіл на команду HMI негативне підтвердження (відміна) ручної операції</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ENCMD_NEXT" typeName="BOOL">
				<comment>дозвіл на команду HMI перейти до наступного кроку</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ENCMD_OK" typeName="BOOL">
				<comment>дозвіл на команду HMI  підтвердити дію</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="TMAXERR" typeName="BOOL">
				<comment>помилка максимуму часу виконання, час більше максимуму</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="TMINERR" typeName="BOOL">
				<comment>помилка мінімуму часу виконання, час менще мінімуму</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_ALM" typeName="BOOL">
				<comment>наявність помилки процедури</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="SEMI" typeName="BOOL">
				<comment>=1 напівавтоматичний режим</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="INBUF" typeName="BOOL">
				<comment>зайнятість буферу</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="MAN" typeName="BOOL">
				<comment>=1, ручний режим</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ENBL" typeName="BOOL">
				<comment>дозвіл на запуск</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="CMD_BUF" typeName="BOOL">
				<comment>завантажити в буфер</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда з HMI</comment>
			</variables>
			<variables name="STEP1" typeName="UINT">
				<comment>стан</comment>
			</variables>
			<variables name="STEP2" typeName="UINT">
				<comment>крок</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>час стану в с</comment>
			</variables>
			<variables name="T_STEP2" typeName="UDINT">
				<comment>час кроку в с</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="PHINOUT_EXMPL" version="0.01" dateTime="dt#2022-08-23-14:18:54">
		<comment>PFW для прикладу вх/вих PROC</comment>
		<attribute name="TypeSignatureCheckSumString" value="B7A9"></attribute>
		<structure>
			<variables name="IN1" typeName="REAL"></variables>
			<variables name="IN2" typeName="REAL"></variables>
			<variables name="OUT1" typeName="REAL"></variables>
			<variables name="OUT2" typeName="REAL"></variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="PROC_CTRL" version="0.02" dateTime="dt#2022-08-25-15:58:47">
		<comment>PFW змінна керування для PROC</comment>
		<attribute name="TypeSignatureCheckSumString" value="7665"></attribute>
		<structure>
			<variables name="W1" typeName="INT"></variables>
			<variables name="ENBL" typeName="BOOL">
				<comment>IN дозвіл на активацію етапу</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="PAUSING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на PAUSED виконана</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="RUNING_CMPLT" typeName="BOOL">
				<comment>IN етап завершився (спрацювала внутрішня умова завершення)</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="HL_RUNNING_CMPLT" typeName="BOOL">
				<comment>IN cпрацювала зовнішня умова завершення, треба опрацьовувати</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="RESTARTING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на RUNNING з HOLD виконана</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="HOLDING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на HOLD з RUNNING виконана</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STOPPING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на STOP виоконана</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ABORTING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на ABORT виконана</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STARTING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на START виконана</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="COMPLETING_CMPLT" typeName="BOOL">
				<comment>IN умова переходу на COMPLITE виконана</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="W2" typeName="INT"></variables>
			<variables name="CMD_START" typeName="BOOL">
				<comment>IN програмна команда START</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="CMD_RESUME" typeName="BOOL">
				<comment>IN програмна команда RESUME</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="CMD_RESTART" typeName="BOOL">
				<comment>IN програмна команда RESTART</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="CMD_PAUSE" typeName="BOOL">
				<comment>IN програмна команда PAUSE</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="CMD_HOLD" typeName="BOOL">
				<comment>IN програмна команда HOLD</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="CMD_STOP" typeName="BOOL">
				<comment>IN програмна команда STOP</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="CMD_ABORT" typeName="BOOL">
				<comment>IN програмна команда ABORT</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="CMD_RESET" typeName="BOOL">
				<comment>IN програмна команда RESET</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="W3" typeName="INT"></variables>
			<variables name="STA_RUNNING" typeName="BOOL">
				<comment>OUT стан RUNNING</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_IDLE" typeName="BOOL">
				<comment>OUT стан IDLE</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_PAUSING" typeName="BOOL">
				<comment>OUT стан PAUSING</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_PAUSED" typeName="BOOL">
				<comment>OUT стан PAUSED</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_HOLDING" typeName="BOOL">
				<comment>OUT стан HOLDING</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_HELD" typeName="BOOL">
				<comment>OUT стан HOLD</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_RESTARTING" typeName="BOOL">
				<comment>OUT стан RESTARTING</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_COMPLETE" typeName="BOOL">
				<comment>OUT стан COMPLETE</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_STOPPING" typeName="BOOL">
				<comment>OUT стан STOPPING</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_STOPPED" typeName="BOOL">
				<comment>OUT стан STOPPED</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_ABORTING" typeName="BOOL">
				<comment>OUT стан ABORTING</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_ABORTED" typeName="BOOL">
				<comment>OUT стан ABORTED</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_STARTING" typeName="BOOL">
				<comment>OUT стан STARTING</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_COMPLETING" typeName="BOOL">
				<comment>OUT стан COMPLETING</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_WRK" typeName="BOOL">
				<comment>OUT  будь яких з робочих станів = STA_RUNNING OR  STA_STARTING OR </comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_NOTWRK" typeName="BOOL">
				<comment>OUT будь з яких кінцевих станів = STA_COMPLETE OR  STA_STOPPED OR </comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="PH_EXMPL" version="0.27" dateTime="dt#2022-09-12-21:02:36">
		<comment>PFW приклад процедурного елементу</comment>
		<attribute name="TypeCodeCheckSumString" value="9604"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="3D8A"></attribute>
		<inputParameters>
			<variables name="ID" typeName="UINT">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="CFG" typeName="PROC_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="HMI" typeName="PROC_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="CTRL" typeName="PROC_CTRL">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PRCBUF" typeName="PROC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="PARA" typeName="PRC_PARA4">
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
			<variables name="INOUT" typeName="PHINOUT_EXMPL">
				<attribute name="PositionPin" value="8"></attribute>
			</variables>
		</inOutParameters>
		<privateLocalVariables>
			<variables name="PROC_MACH" typeName="PROC_MACH"></variables>
			<variables name="CMD_NEXT" typeName="BOOL"></variables>
			<variables name="PROC_TRANS" typeName="PROC_TRANS_A"></variables>
			<variables name="PROC_TRANS_M" typeName="PROC_TRANS_M"></variables>
		</privateLocalVariables>
		<FBProgram name="PROC">
			<STSource>(* приклад етапу:
- IDLE - нічого не робить
- STARTING - очікує ручного підтвердження: 
	ок -&gt; RUNNING
	CANCEL -&gt; COMPLETING   
- RUNNING 
  1 - інкрементує INOUT.OUT1, очікує INOUT.IN1&gt;PARA.PARA1 -&gt; 2
  2 - інкрементує INOUT.OUT2, очікує ручного підтвердження:
	ok -&gt; 3
	CANCEL -&gt; HOLDING 
  3 - декрементує INOUT.OUT1, INOUT.OUT2, очікує INOUT.OUT1&lt;=PARA.PARA2 -&gt; COMPLETING
- COMPLETING, STOPPING, і в кінцеве положення
  INOUT.OUT1=0, INOUT.OUT2 = 0
- COMPLET, STOP: через 5 с RESET 
*)

(* {PFWEXPORTSTART}{}{PFWEXPORTEND} *)


(* виставити умову дозволу*)
CTRL.ENBL := true;

(*за необхідності фіксації переходів в БД на перехідних коках ставити затримки*)
(*за необхідності дій в простої, можна вписати в стан*)
IF CTRL.STA_IDLE THEN
    CFG.STEP2 := 0; 
END_IF;
(*--------------- NORM ------------------*)
IF CTRL.STA_STARTING THEN
    CASE CFG.STEP2 OF
        13000:
            CFG.STEP2 := 13001; CFG.T_STEP2 := 0;
        13001: (*крок штатного завершення STARTING*)
	    PROC_TRANS (COND := true, TOSTEP := 1, CFG := CFG, HMI := HMI, CTRL:=CTRL);
        ELSE (*перехід на STARTING*)
            CFG.STEP2 := 13000; CFG.T_STEP2 := 0;
    END_CASE;
    (*умова нормального завершення етапу навіть в STARTING*)
    CTRL.RUNING_CMPLT := CTRL.HL_RUNNING_CMPLT OR CTRL.RUNING_CMPLT;
END_IF;
IF CTRL.STA_RUNNING THEN   
    CASE CFG.STEP2 OF
        2000:
            CFG.STEP2 := 2001; CFG.T_STEP2 := 0;
        2001: (* збільшуємо OUT1, чекаю IN1&gt;PARA1 *)  
            INOUT.OUT1:=INOUT.OUT1+0.1; 
	    if INOUT.OUT1&gt;100000.0 then INOUT.OUT1:=100.0; end_if;
	    PROC_TRANS (COND := INOUT.in1&gt;PARA.PARA1, TOSTEP := 2002, CFG := CFG, HMI := HMI, CTRL:=CTRL); 
	2002: (* збільшуємо OUT2, перейти до іншого кроку? *)
	    INOUT.OUT2:=INOUT.OUT2+0.1;
	    if INOUT.OUT2&gt;100000.0 then INOUT.OUT2:=100.0; end_if;
	    PROC_TRANS_M (TOSTEPOK := 2003, TOSTEPCANCEL := 0, CFG := CFG, HMI := HMI, CTRL:=CTRL);
	2003: (* зменшую OUT1,OUT2, чекаю OUT1&lt;=PARA2 *)
	    INOUT.OUT1:=INOUT.OUT1-0.1;
	    INOUT.OUT2:=INOUT.OUT2-0.1;  
	    if INOUT.OUT1&lt;0.0 then INOUT.OUT1:=0.0; end_if;
	    if INOUT.OUT2&lt;0.0 then INOUT.OUT2:=0.0; end_if;
            PROC_TRANS (COND := INOUT.OUT2&lt;PARA.PARA2, TOSTEP := 1, CFG := CFG, HMI := HMI, CTRL:=CTRL);
        ELSE
	    CTRL.RUNING_CMPLT:=true;
    END_CASE;
    
    (*умова нормального завершення етапу*)
    CTRL.RUNING_CMPLT := CTRL.HL_RUNNING_CMPLT OR CTRL.RUNING_CMPLT;
    CTRL.RESTARTING_CMPLT := false;
END_IF;
IF CTRL.STA_COMPLETING THEN
    CASE CFG.STEP2 OF
        14000:
            CFG.STEP2 := 14001; CFG.T_STEP2 := 0; (* ініціалізація*)
        14001:
            CTRL.COMPLETING_CMPLT := TRUE;
        ELSE
            CFG.STEP2 := 14000; CFG.T_STEP2 := 0;
    END_CASE;
END_IF;
IF CTRL.STA_COMPLETE THEN
    CASE CFG.STEP2 OF
        8000:
            CFG.STEP2 := 8001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        8001:
            IF CFG.T_STEP2 &gt; 5000 THEN
                CTRL.CMD_RESET := TRUE;
            END_IF;
        ELSE
            CFG.STEP2 := 8000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;

(*------------- pause -------------- *)
IF CTRL.STA_PAUSING THEN
    CASE CFG.STEP2 OF
        3000:
            CFG.STEP2 := 3001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        3001:
            CTRL.PAUSING_CMPLT := TRUE;
            CFG.T_STEP2 := 0;
        ELSE
            CFG.STEP2 := 3000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;
IF CTRL.STA_PAUSED THEN
    CASE CFG.STEP2 OF
        4000:
            CFG.STEP2 := 4001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        4001:
            ;
        ELSE
            CFG.STEP2 := 4000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;

(*----------- stop --------------------*)
IF CTRL.STA_STOPPING THEN
    CASE CFG.STEP2 OF
        9000:
            CFG.STEP2 := 9001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        9001:
            CTRL.STOPPING_CMPLT := TRUE; CFG.T_STEP2 := 0;
        ELSE
            CFG.STEP2 := 9000; CFG.T_STEP2 := 0;
	   
    END_CASE;
END_IF;
IF CTRL.STA_STOPPED THEN
    CASE CFG.STEP2 OF
        10000:
            CFG.STEP2 := 10001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        10001:
            IF CFG.T_STEP2 &gt; 5000 THEN
                CTRL.CMD_RESET := TRUE;
            END_IF;
        ELSE
            CFG.STEP2 := 10000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;

(*------------ HOLD -------------------*)
IF CTRL.STA_HOLDING THEN
    CASE CFG.STEP2 OF
        5000:
            CFG.STEP2 := 5001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        5001:
            CTRL.HOLDING_CMPLT := TRUE;
            CFG.T_STEP2 := 0;
        ELSE
            CFG.STEP2 := 5000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;
IF CTRL.STA_HELD THEN
    CASE CFG.STEP2 OF
        6000:
            CFG.STEP2 := 6001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        6001:
            ;
        ELSE
            CFG.STEP2 := 6000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;
IF CTRL.STA_RESTARTING THEN
    CASE CFG.STEP2 OF
        7000:
            CFG.STEP2 := 7001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        7001:
            CTRL.RESTARTING_CMPLT := TRUE;
            CFG.T_STEP2 := 0;
        ELSE
            CFG.STEP2 := 7000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;

(*---------------- abort --------------*)
IF CTRL.STA_ABORTING THEN
    CASE CFG.STEP2 OF
        11000:
            CFG.STEP2 := 11001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        11001:
            CTRL.ABORTING_CMPLT := TRUE;
            CFG.T_STEP2 := 0;
        ELSE
            CFG.STEP2 := 11000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;
IF CTRL.STA_ABORTED THEN
    CASE CFG.STEP2 OF
        12000:
            CFG.STEP2 := 12001;
            CFG.T_STEP2 := 0; (* ініціалізація*)
        12001:
            IF CFG.T_STEP2 &gt; 5000 THEN
                CTRL.CMD_RESET := TRUE;
            END_IF;
        ELSE
            CFG.STEP2 := 12000;
            CFG.T_STEP2 := 0;
    END_CASE;
END_IF;


PROC_MACH (ID := ID,
           PRCCFG := CFG,
           PRCHMI := HMI,
           PRCCTRL := CTRL,
           PRCBUF := PRCBUF,
           PLCCFG := PLCCFG);

(*
0 – ініціалізація (тільки при старті ПЛК)
1000 – Idle (очікує)
13000 – Starting (запускається)
2000 - Running (виконується) 
14000- Completing (завершується)
3000 – Pausing (призупиняється)
4000 – Paused (призупинено)
5000 – Holding (утримується)
6000 – Hold (утримуване)
7000 – Restarting (перезапускається)
8000 – Complete (завершено)
9000 – Stopping (зупиняється)
10000 – Stopped (зупинено)
11000 – Aborting (переривається)
12000 – Aborted (перервано)

STA x0-x7 для маскування кнопок керування: TRUE - кнопка активна/видима, дія дозволена, FALSE - кнопка неактивна/невидима, дія не дозволена
- X5 CANCEL - негативне пітвердження (відміна) ручної операції, керування зовн функцією
- X6 NEXT - перейти до наступного кроку, керування зовн функцією
- X7 OK - підтвердити дію, керування зовн функцією
..інші в стандартній PRC

*)
</STSource>
		</FBProgram>
	</FBSource>
	<DDTSource DDTName="PRC_PARA4" version="0.02" dateTime="dt#2022-09-12-15:54:17">
		<comment>PFW для прикладу 4 параметрів PROC</comment>
		<attribute name="TypeSignatureCheckSumString" value="F97F"></attribute>
		<structure>
			<variables name="PARA1" typeName="REAL">
				<comment>параметр 1</comment>
			</variables>
			<variables name="PARA2" typeName="REAL">
				<comment>параметр 2</comment>
			</variables>
			<variables name="PARA3" typeName="REAL">
				<comment>параметр 3</comment>
			</variables>
			<variables name="PARA4" typeName="REAL">
				<comment>параметр 4</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="PROC_MACH" version="0.23" dateTime="dt#2022-09-11-23:34:02">
		<comment>PFW рушій автомату стану проц.елементу</comment>
		<attribute name="TypeCodeCheckSumString" value="BA1E"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="CC19"></attribute>
		<inputParameters>
			<variables name="ID" typeName="UINT">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="PRCCFG" typeName="PROC_CFG">
				<attribute name="PositionPin" value="2"></attribute>
				<instanceElementDesc name="STEP1">
					<comment>стан процедури</comment>
				</instanceElementDesc>
				<instanceElementDesc name="STEP2">
					<comment>крок процедури</comment>
				</instanceElementDesc>
				<instanceElementDesc name="T_STEP1">
					<comment>час стану процедури</comment>
				</instanceElementDesc>
				<instanceElementDesc name="T_STEP2">
					<comment>час кроку процедури</comment>
				</instanceElementDesc>
			</variables>
			<variables name="PRCHMI" typeName="PROC_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PRCCTRL" typeName="PROC_CTRL">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PRCBUF" typeName="PROC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="PRCBUF_IN" typeName="PROC_CFG"></variables>
			<variables name="PRCBUF_OUT" typeName="PROC_CFG"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="STA" typeName="INT"></variables>
			<variables name="CMD" typeName="INT"></variables>
			<variables name="T_STEPHMI" typeName="UINT"></variables>
			<variables name="AUTO" typeName="BOOL"></variables>
			<variables name="SEMI" typeName="BOOL"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="MAN" typeName="BOOL"></variables>
			<variables name="CMD_ABORT" typeName="BOOL"></variables>
			<variables name="CMD_HOLD" typeName="BOOL"></variables>
			<variables name="CMD_PAUSE" typeName="BOOL"></variables>
			<variables name="CMD_RESET" typeName="BOOL"></variables>
			<variables name="CMD_RESTART" typeName="BOOL"></variables>
			<variables name="CMD_RESUME" typeName="BOOL"></variables>
			<variables name="CMD_START" typeName="BOOL"></variables>
			<variables name="CMD_STOP" typeName="BOOL"></variables>
			<variables name="CMD_BUF" typeName="BOOL"></variables>
			<variables name="CMD_CMPLT" typeName="BOOL"></variables>
			<variables name="TMAXERR" typeName="BOOL"></variables>
			<variables name="TMINERR" typeName="BOOL"></variables>
			<variables name="ALM" typeName="BOOL"></variables>
			<variables name="AMAXENBL" typeName="BOOL"></variables>
			<variables name="AMINENBL" typeName="BOOL"></variables>
			<variables name="dt1" typeName="UDINT"></variables>
		</privateLocalVariables>
		<FBProgram name="PROC">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)

IF PRCCFG.ID=0 THEN
  PRCCFG.ID:=ID;
END_IF;

PRCCFG.CLSID := 16#3000;(*процедура загального вжитку*)

(*пустишка не обробляється*)
IF ID=0 THEN 
   PRCCFG.STA:=0;
   PRCCFG.CMD:=0;
    RETURN; 
END_IF;

(* STA
- x0-x7 для маскування кнопок керування: TRUE - кнопка активна/видима, дія дозволена, FALSE - кнопка неактивна/невидима, дія не дозволена
X0 START - CMD_START
X1 PAUSE - CMD_PAUSE
X2 RESET - CMD_RESET 
X3 HOLD - CMD_HOLD
X4 STOP - CMD_STOP
X5 CANCEL - негативне пітвердження (відміна) ручної операції, керування зовн функцією
X6 NEXT - перейти до наступного кроку, керування зовн функцією
X7 OK - підтвердити дію, керування зовн функцією
- x8-x15 - стани
X8 TMAXERR – помилка максимуму часу виконання, час більше максимуму 
X9 TMINERR – помилка мінімуму часу виконання, час менще мінімуму
X10 ALM – наявність помилки процедури
X11 SEMI - напівавтоматичний
X12 INBUF – зайнятість буферу
X13 MAN – ручний режим
    AUTO = NOT MAN AND NOT SEMI
X14 ENBL – дозвіл на запуск
X15 CMD_BUF (тільки HMI)
*)
(* CMD
1 - CMD_START  
2 - CMD_RESUME not HMI
3 - CMD_PAUSE 
4 - CMD_RESET
5 - CMD_RESTART not HMI
6 - CMD_HOLD
7 - CMD_STOP 
8 - CMD_ABORT 
9 - CMD_CMPLT тільки для наладки
16#100 - прочитати конфігурацію CMD_BUF (256)
16#101 - записати конфігурацію (257)
16#102 - перевести в автоматичний режим
16#103 - перевести в ручний режим
16#104 - переключити ручний режим
16#105 - переключити в напівавтоматичний (програмний) режим
16#0200 – NEXT (HMI - перейти до наступного кроку T_STEP2, пропустити умову переходу) X6 обробляється ззовні  
16#0300 – OK (HMI - команди підтвердження дій) X7
16#0301 - CANCEL (HMI - негативне пітвердження (відміна) ручної операції) X5 
2000...3000 (16#7D0 - 16#BB8) - перейти на відповідний крок 
*)

STA :=PRCCFG.STA;
(*якщо немає дозволу на керування убрати усі активності кнопок *)
IF NOT PRCCTRL.ENBL THEN
   STA :=STA AND 16#FF00;
END_IF;
TMAXERR:=STA.8;
TMINERR:=STA.9;
ALM:=STA.10;
SEMI :=STA.11;
MAN :=STA.13;
CMD_BUF :=PRCHMI.STA.15 OR PRCHMI.CMD=16#0100;
AUTO := NOT MAN AND NOT SEMI;
INBUF:=(PRCCFG.ID=PRCBUF.ID);

(*PRM*)
AMAXENBL:=PRCCFG.PRM.7;
AMINENBL:=PRCCFG.PRM.8;

(*----- обробка команд ------------*)
CMD:=0;
if PRCCFG.CMD&lt;&gt;0 then CMD:=PRCCFG.CMD; end_if;(*команда з іншого джерела*)
if PRCHMI.CMD&lt;&gt;0 then CMD:=PRCHMI.CMD; end_if;(*команда з HMI*)
IF PRCBUF.CMD&lt;&gt;0 and INBUF THEN CMD:=PRCBUF.CMD; END_IF;(*команда з буферу*)
(*команди HMI за умови їх активності*)
IF NOT ((CMD=1 AND STA.0)   (*CMD_START +*)   
 OR CMD=2    (*CMD_RESUME - як правило не використовується*)
 OR (CMD=3 AND STA.1)   (*CMD_PAUSE *)
 OR (CMD=4 AND STA.2) (*CMD_RESET*)
 OR CMD=5 (*CMD_RESTART - як правило не використовується*)
 OR (CMD=6 AND STA.3)  (*CMD_HOLD*)
 OR (CMD=7 AND STA.4) (*CMD_STOP +*)
 (*OR CMD=8 CMD_ABORT - за замовченням відключена з HMI програмно*)
 OR CMD=9 (*CMD_CMPLT - тільки для наладки*)
 OR CMD&gt;10) (* інші команди пропускаються без перевірки*)
     THEN 
     CMD:=0;
END_IF;
IF CMD_BUF THEN CMD:=16#0100; END_IF; (*завнтажити в буфер*) 
(* загальна команда PLC OR HMI*)
CMD_ABORT :=PRCCTRL.CMD_ABORT OR CMD=8;
CMD_HOLD :=PRCCTRL.CMD_HOLD OR CMD=6;
CMD_PAUSE :=PRCCTRL.CMD_PAUSE OR CMD=3;
CMD_RESET :=PRCCTRL.CMD_RESET OR CMD=4 OR CMD=1; (*з HMI по RESET і START*)
CMD_RESTART :=PRCCTRL.CMD_RESTART OR CMD=5 OR CMD=1; (*з HMI по RESTART і START*)
CMD_RESUME :=PRCCTRL.CMD_RESUME OR CMD=2 OR CMD=1; (*з HMI по RESUME і START*)
CMD_START :=PRCCTRL.CMD_START OR CMD=1;
CMD_STOP :=PRCCTRL.CMD_STOP OR CMD=7;
CMD_CMPLT := CMD=9;(*тільки для наладки*)

CASE CMD OF
 16#0100: (*прочитати конфігурацію*)
    PRCBUF:=PRCCFG;
 16#0101: (*записати конфігурацію*)
   PRCCFG.PRM :=PRCBUF.PRM;
   PRCCFG.T_DELAY :=PRCBUF.T_DELAY;
   PRCCFG.TMAX :=PRCBUF.TMAX;
   PRCCFG.TMIN :=PRCBUF.TMIN;
 16#0102:
  MAN:= false;
  SEMI:=false;
 16#0103:
  MAN:= true;
  SEMI:=false;
 16#104:
  MAN:= NOT MAN;
  SEMI:=false;
 16#105:
  MAN:= false;
  SEMI:=true;
END_CASE;
(*----------------------------*)

(*за основу взятий секундний лічильник, як більш точний на великих діапазонах*)
dt1 := (PLCCFG.TQ - PRCCFG.T_PREV)*1000;

(* -------------- обробник автомату станів *)
IF CMD_ABORT THEN PRCCFG.STEP1:=11; END_IF; 
CASE PRCCFG.STEP1 OF   
 0:(* - ініціалізація*)
   PRCCFG.STEP1:=1;    
 1:(* – Idle (очікування)*)
      PRCCFG.T_STEP1:=0;
      TMAXERR:=FALSE;
      TMINERR:=FALSE; 
    IF CMD_START AND PRCCTRL.ENBL THEN 
       PRCCFG.STEP1:=13; PRCCFG.STEP2:=13000;
       PRCCFG.T_STEP2:=0;
    END_IF;
   PRCCTRL.PAUSING_CMPLT := FALSE;
   PRCCTRL.RUNING_CMPLT := FALSE;
   PRCCTRL.STARTING_CMPLT := false;
   PRCCTRL.COMPLETING_CMPLT := false;
   PRCCTRL.HL_RUNNING_CMPLT := FALSE;
   PRCCTRL.RESTARTING_CMPLT := FALSE;
   PRCCTRL.HOLDING_CMPLT := FALSE;
   PRCCTRL.STOPPING_CMPLT := FALSE;
   PRCCTRL.ABORTING_CMPLT := FALSE;
    IF PRCCFG.STEP2&lt;1000 OR PRCCFG.STEP2&gt;1999 THEN  
       PRCCFG.STEP2:=1000; 
    END_IF;
   STA:=STA AND 16#FF00; (*деактивувати усі кнопки*)
   STA.0:= true; (*активувати Пуск, в автоматі скидується нижче*) 
 13:(*13 - Starting*)
    IF PRCCFG.STEP2&lt;13000 OR PRCCFG.STEP2&gt;13999 THEN  
       PRCCFG.STEP2:=13000; 
    END_IF;
    IF PRCCTRL.STARTING_CMPLT OR PRCCTRL.RUNING_CMPLT OR CMD_CMPLT THEN
       PRCCFG.STEP1:=2;PRCCFG.STEP2:=2000;
       PRCCFG.T_STEP2:=0;  
    END_IF;
    IF CMD_HOLD THEN 
    	PRCCFG.STEP1:=5; PRCCFG.STEP2:=5000;
	PRCCFG.T_STEP2:=0;
     END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11; PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна *)
   STA.1:=FALSE;(*1 3 -CMD_PAUSE X1 *)
   STA.2:=FALSE;(*1 4 -CMD_RESET X2 *)
   STA.3:=FALSE;(*1 6 -CMD_HOLD X3 *)
   STA.4:=TRUE;(*1 7 -CMD_STOP X4 *)
 2:(*2 - Running*)  
   PRCCTRL.PAUSING_CMPLT := FALSE;
   PRCCTRL.STARTING_CMPLT := false;
   PRCCTRL.COMPLETING_CMPLT := false;
   PRCCTRL.RESTARTING_CMPLT := FALSE;
   PRCCTRL.HOLDING_CMPLT := FALSE;
   PRCCTRL.STOPPING_CMPLT := FALSE;
   PRCCTRL.ABORTING_CMPLT := FALSE;
    IF PRCCFG.STEP2&lt;2000 OR PRCCFG.STEP2&gt;2999 THEN  
       PRCCFG.STEP2:=2000; 
    END_IF;
    IF PRCCTRL.RUNING_CMPLT  OR CMD_CMPLT THEN
       PRCCFG.STEP1:=14;PRCCFG.STEP2:=14000;
       PRCCFG.T_STEP2:=0;  
        IF AMINENBL AND PRCCFG.T_STEP1&lt;PRCCFG.TMIN THEN
           TMINERR:=TRUE;
        END_IF; 
    END_IF;
    IF CMD_PAUSE THEN 
    	PRCCFG.STEP1:=3; PRCCFG.STEP2:=3000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_HOLD THEN 
    	PRCCFG.STEP1:=5; PRCCFG.STEP2:=5000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11; PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF AMAXENBL AND PRCCFG.T_STEP1&gt;=PRCCFG.TMAX THEN
       TMAXERR:=TRUE;
    END_IF;

   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна *) 
   STA.1:=TRUE;(*3 -CMD_PAUSE X1 *)
   STA.2:=FALSE;(*4 -CMD_RESET X2 *)
   STA.3:=TRUE;(*6 -CMD_HOLD X3 *)
   STA.4:=TRUE;(*7 -CMD_STOP X4 *)
14:(* Completing *)
   PRCCTRL.RUNING_CMPLT:=false;
    IF PRCCFG.STEP2&lt;14000 OR PRCCFG.STEP2&gt;14999 THEN  
       PRCCFG.STEP2:=14000; 
    END_IF;
    IF PRCCTRL.COMPLETING_CMPLT OR CMD_CMPLT  THEN
       PRCCFG.STEP1:=8; PRCCFG.STEP2:=8000;
       PRCCFG.T_STEP2:=0;  
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_START THEN 
       PRCCFG.STEP1:=13;PRCCFG.STEP2:=13000;
       PRCCFG.T_STEP2:=0;
    END_IF;
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна*) 
   STA.1:=FALSE;(*3 -CMD_PAUSE X1 *)
   STA.2:=FALSE;(*4 -CMD_RESET X2 *)
   STA.3:=TRUE;(*6 -CMD_HOLD X3 *)
   STA.4:=TRUE;(*7 -CMD_STOP X4 *)
3:(*3 – Pausing *)
    IF PRCCFG.STEP2&lt;3000 OR PRCCFG.STEP2&gt;3999 THEN  
       PRCCFG.STEP2:=3000; 
    END_IF;
    IF PRCCTRL.PAUSING_CMPLT OR CMD_CMPLT THEN 
       PRCCFG.STEP1:=4;PRCCFG.STEP2:=4000;
       PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_HOLD THEN 
    	PRCCFG.STEP1:=5; PRCCFG.STEP2:=5000;
	PRCCFG.T_STEP2:=0;
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна *)
   STA.1:=FALSE;(*3 -CMD_PAUSE X1 *)
   STA.2:=FALSE;(*4 -CMD_RESET X2 *)
   STA.3:=TRUE;(*6 -CMD_HOLD X3 *)
   STA.4:=TRUE;(*7 -CMD_STOP X4 *)   
4:(*4 – Paused *)
   PRCCTRL.PAUSING_CMPLT:=false;
    IF PRCCFG.STEP2&lt;4000 OR PRCCFG.STEP2&gt;4999 THEN  
       PRCCFG.STEP2:=4000; 
    END_IF;  
   IF CMD_RESUME OR CMD_RESTART OR CMD_START THEN 
   	PRCCFG.STEP1:=2;PRCCFG.STEP2:=2000;
	PRCCFG.T_STEP2:=0;
   END_IF;
   IF PRCCTRL.RUNING_CMPLT THEN (*додано 18.05*)
        PRCCFG.STEP1 := 14; PRCCFG.STEP2:=14000;
        PRCCFG.T_STEP2:=0;
   END_IF;
    IF CMD_HOLD THEN 
    	PRCCFG.STEP1:=5; PRCCFG.STEP2:=5000;
	PRCCFG.T_STEP2:=0;
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9;PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;   
   STA.0:=TRUE; (*1 -CMD_START  X0=1 - кнопка активна *)
   STA.1:=FALSE;(*3 -CMD_PAUSE X1 *)
   STA.2:=FALSE;(*4 -CMD_RESET X2 *)
   STA.3:=TRUE;(*6 -CMD_HOLD X3 *)
   STA.4:=TRUE;(*7 -CMD_STOP X4 *)
5:(*5 – Holding*)
    IF PRCCFG.STEP2&lt;5000 OR PRCCFG.STEP2&gt;5999 THEN  
       PRCCFG.STEP2:=5000; 
    END_IF;   
    IF PRCCTRL.HOLDING_CMPLT  OR CMD_CMPLT THEN 
       PRCCFG.STEP1:=6; PRCCFG.STEP2:=6000;
       PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0;
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
       
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна *)
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=FALSE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=TRUE;(*7 -CMD_STOP X4*)
6:(*6 – Held*)
   PRCCTRL.HOLDING_CMPLT:=false;
   PRCCFG.T_STEP1:=0; 
    IF PRCCFG.STEP2&lt;6000 OR PRCCFG.STEP2&gt;6999 THEN  
       PRCCFG.STEP2:=6000; 
    END_IF;    
    IF CMD_RESTART THEN 
    	PRCCFG.STEP1:=7;PRCCFG.STEP2:=7000;
	PRCCFG.T_STEP2:=0; 
    END_IF;   
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9;PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF PRCCTRL.RUNING_CMPLT  OR CMD_CMPLT THEN
       PRCCFG.STEP1:=14;PRCCFG.STEP2:=14000;
       PRCCFG.T_STEP2:=0;
    END_IF;
 
   STA.0:=TRUE; (*1 -CMD_START  X0=1 - кнопка активна*) 
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=FALSE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=TRUE;(*7 -CMD_STOP X4*)
7:(*7 – Restarting*)
    IF PRCCFG.STEP2&lt;7000 OR PRCCFG.STEP2&gt;7999 THEN  
       PRCCFG.STEP2:=7000; 
    END_IF;
    IF PRCCTRL.RESTARTING_CMPLT  OR CMD_CMPLT THEN 
       PRCCFG.STEP1:=2;PRCCFG.STEP2:=2000;
       PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_HOLD THEN 
    	PRCCFG.STEP1:=5; PRCCFG.STEP2:=5000;
	PRCCFG.T_STEP2:=0;
    END_IF;
    IF CMD_STOP THEN 
    	PRCCFG.STEP1:=9; PRCCFG.STEP2:=9000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;       
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна*) 
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=FALSE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=TRUE;(*7 -CMD_STOP X4*)
8:(*8 – Complete*)
   PRCCTRL.COMPLETING_CMPLT:=false;
    IF PRCCFG.STEP2&lt;8000 OR PRCCFG.STEP2&gt;8999 THEN  
       PRCCFG.STEP2:=8000; 
    END_IF;
    IF CMD_RESET THEN 
    	PRCCFG.STEP1:=1; PRCCFG.STEP2:=1000;
	PRCCFG.T_STEP2:=0; 
    END_IF; 

   STA:=STA AND 16#FF00; (*деактивувати усі кнопки*)
   STA.0:=true; (*1 -як RESET*) 
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=FALSE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=TRUE;(*7 -CMD_STOP X4*)
9:(*9 – Stopping*) 
    IF PRCCFG.STEP2&lt;9000 OR PRCCFG.STEP2&gt;9999 THEN  
       PRCCFG.STEP2:=9000; 
    END_IF; 
    IF CMD_ABORT THEN 
    	PRCCFG.STEP1:=11;PRCCFG.STEP2:=11000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
    IF PRCCTRL.STOPPING_CMPLT OR CMD_CMPLT THEN 
       PRCCFG.STEP1:=10;PRCCFG.STEP2:=10000;
       PRCCFG.T_STEP2:=0;
    END_IF;
    IF CMD_START THEN (* в стопінгу відслідковувати старт для повторного пуску*)
       CMD_STOP:=FALSE;        
       PRCCFG.STEP1:=13;PRCCFG.STEP2:=13000;
       PRCCFG.T_STEP2:=0;
    END_IF;
   STA:=STA AND 16#FF00; (*деактивувати кнопку ПУСК*)   
10:(*10 – Stopped*)
   PRCCTRL.STOPPING_CMPLT:=false;
    IF PRCCFG.STEP2&lt;10000 OR PRCCFG.STEP2&gt;10999 THEN  
       PRCCFG.STEP2:=10000; 
    END_IF;
    IF CMD_RESET THEN 
    	PRCCFG.STEP1:=1;PRCCFG.STEP2:=1000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
   STA.0:=TRUE; (*1 -CMD_START  як RESET *)
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=TRUE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=FALSE;(*7 -CMD_STOP X4*)   
 11:(*11 - Aborting*)
    IF PRCCFG.STEP2&lt;11000 OR PRCCFG.STEP2&gt;11999 THEN  
       PRCCFG.STEP2:=11000; 
    END_IF;
    IF PRCCTRL.ABORTING_CMPLT OR PRCCFG.T_STEP2&gt;3000  OR CMD_CMPLT THEN 
       PRCCFG.STEP1:=12;PRCCFG.STEP2:=12000;
       PRCCFG.T_STEP2:=0; 
    END_IF;
   STA:=STA AND 16#FF00; (*деактивувати кнопку ПУСК *)       
12:(*12 - Aborted*)
    IF PRCCFG.STEP2&lt;11000 OR PRCCFG.STEP2&gt;11999 THEN  
       PRCCFG.STEP2:=11000; 
    END_IF; 
    IF CMD_RESET OR CMD_START THEN 
    	PRCCFG.STEP1:=1;PRCCFG.STEP2:=1000;
	PRCCFG.T_STEP2:=0; 
    END_IF;
   STA.0:=TRUE; (*1 -CMD_START  як RESET *)
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=TRUE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=FALSE;(*7 -CMD_STOP X4*)   
ELSE
   PRCCFG.STEP1:=0;PRCCFG.STEP2:=0;
   STA:=STA AND 16#FF00; (*деактивувати кнопку ПУСК*)
   STA.0:=TRUE; (*1 -CMD_START  X0=1 - кнопка активна*)
   STA.2:=TRUE;(*4 -CMD_RESET X2     *)
END_CASE;
(*---------------- *)

(*деактивування кнопок в автоматичному режимі*) 
IF AUTO THEN
   STA.0:=FALSE; (*1 -CMD_START  X0=1 - кнопка активна*) 
   STA.1:=FALSE;(*3 -CMD_PAUSE X1*)
   STA.2:=FALSE;(*4 -CMD_RESET X2*)
   STA.3:=FALSE;(*6 -CMD_HOLD X3*)
   STA.4:=FALSE;(*7 -CMD_STOP X4*)
END_IF;


PRCCTRL.STA_IDLE:=(PRCCFG.STEP1=1);
PRCCTRL.STA_RUNNING:=(PRCCFG.STEP1=2);
PRCCTRL.STA_PAUSING:=(PRCCFG.STEP1=3);
PRCCTRL.STA_PAUSED:=(PRCCFG.STEP1=4);
PRCCTRL.STA_HOLDING:=(PRCCFG.STEP1=5);
PRCCTRL.STA_HELD:=(PRCCFG.STEP1=6);
PRCCTRL.STA_RESTARTING:=(PRCCFG.STEP1=7);
PRCCTRL.STA_COMPLETE:=(PRCCFG.STEP1=8);
PRCCTRL.STA_STOPPING:=(PRCCFG.STEP1=9);
PRCCTRL.STA_STOPPED:=(PRCCFG.STEP1=10);
PRCCTRL.STA_ABORTING:=(PRCCFG.STEP1=11);
PRCCTRL.STA_ABORTED:=(PRCCFG.STEP1=12);
PRCCTRL.STA_STARTING:=(PRCCFG.STEP1=13);
PRCCTRL.STA_COMPLETING:=(PRCCFG.STEP1=14);
PRCCTRL.STA_WRK :=PRCCTRL.STA_RUNNING OR PRCCTRL.STA_STARTING OR PRCCTRL.STA_COMPLETING OR PRCCTRL.STA_RESTARTING;
PRCCTRL.STA_NOTWRK :=PRCCTRL.STA_COMPLETE OR PRCCTRL.STA_STOPPED OR PRCCTRL.STA_ABORTED OR PRCCTRL.STA_IDLE; 

PRCCTRL.CMD_ABORT := FALSE;
PRCCTRL.CMD_HOLD := FALSE;
PRCCTRL.CMD_PAUSE := FALSE;
PRCCTRL.CMD_RESET := FALSE;
PRCCTRL.CMD_RESTART := FALSE;
PRCCTRL.CMD_RESUME := FALSE;
PRCCTRL.CMD_START := FALSE;
PRCCTRL.CMD_STOP := FALSE;

ALM:=TMINERR OR TMAXERR OR ALM;
STA.8:=TMAXERR;
STA.9:=TMINERR;
STA.10:=ALM;
STA.11:=SEMI;
STA.12:=INBUF;
STA.13:=MAN;
STA.14:=PRCCTRL.ENBL;
STA.15:=false;

IF INBUF THEN
    PRCBUF.STA:=STA;
    PRCBUF.T_STEP1:=PRCCFG.T_STEP1;
    PRCBUF.T_STEP2:=PRCCFG.T_STEP2;
    PRCBUF.STEP1:=PRCCFG.STEP1;
    PRCBUF.STEP2:=PRCCFG.STEP2;
    PRCBUF.CMD :=0;
END_IF;

PRCCFG.CMD:=0; 
PRCHMI.CMD:=0;
PRCCFG.STA:=STA; 
PRCHMI.STA :=STA;
PRCHMI.T_STEP1:=PRCCFG.T_STEP1;
PRCHMI.STEP1 :=PRCCFG.STEP1;

IF NOT (PRCCTRL.STA_IDLE) THEN
   PRCHMI.T_STEP2 :=PRCCFG.T_STEP2;
ELSE
   PRCHMI.T_STEP2 := 0;
END_IF;
PRCHMI.STEP2 :=PRCCFG.STEP2;

PRCCFG.T_PREV := PLCCFG.TQ;

IF PRCCFG.STEP1=2 THEN (*рахувати тільки в стані RUNNING, обнуляється також при холдінгу*)
   PRCCFG.T_STEP1:=PRCCFG.T_STEP1+ dt1;
    IF PRCCFG.T_STEP1&gt;16#7fffffff THEN PRCCFG.T_STEP1:=16#7fffffff;END_IF;
END_IF;


PRCCFG.T_STEP2:=PRCCFG.T_STEP2+dt1;
IF PRCCFG.T_STEP2&gt;16#7fffffff THEN PRCCFG.T_STEP2:=16#7fffffff;END_IF;


IF PRCCTRL.STA_IDLE THEN
   PRCCFG.T_STEP2 := 0;
END_IF;

(*
 0 – ініціалізація (тільки при старті ПЛК)
 1000 – Idle (очікує)
 13000 – Starting (запускається)
 2000 - Running (виконується) 
 14000- Completing (завершується)
 3000 – Pausing (призупиняється)
 4000 – Paused (призупинено)
 5000 – Holding (утримується)
 6000 – Hold (утримуване)
 7000 – Restarting (перезапускається)
 8000 – Complete (завершено)
 9000 – Stopping (зупиняється)
 10000 – Stopped (зупинено)
 11000 – Aborting (переривається)
 12000 – Aborted (перервано)

*)
</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="PROC_TRANS_A" version="0.09" dateTime="dt#2022-09-11-23:52:51">
		<comment>PFW перехід кроку процедурного елементу</comment>
		<attribute name="TypeCodeCheckSumString" value="C036"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="44E7"></attribute>
		<inputParameters>
			<variables name="COND" typeName="BOOL">
				<comment>умова переходу</comment>
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="TOSTEP" typeName="UINT">
				<comment>куди переходити</comment>
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="CFG" typeName="PROC_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="HMI" typeName="PROC_HMI">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CTRL" typeName="PROC_CTRL">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="CMDNEXT" typeName="BOOL">
				<comment>умова спрацювала</comment>
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<FBProgram name="PROC_TRANS_A">
			<STSource>(*Дана функція реалізовує перехід при спрацюванні умови в автоматичному режимі або/та при команді `CMD_NEXT` в ручному/напівавтоматичному режимі:
- повертає логічну одиницю, якщо перехід спрацьовує, і переходить на крок, вказаний в полі `TOSTEP`
- керує видимістю біту `ENCMD_NEXT` в залежності від режимів
- відключає включає видимість кнопок `CMD_OK` та `CMD_CANCEL`
*)
CFG.ENCMD_NEXT:=false;

if HMI.MAN then 
   CMDNEXT:= HMI.CMD = 16#200;
elsif HMI.SEMI then
   CMDNEXT:= COND OR HMI.CMD = 16#200;
else (*AUTO*)
   CMDNEXT:= COND;
end_if;

CFG.ENCMD_NEXT:=HMI.MAN or HMI.SEMI;
CFG.ENCMD_OK := false; CFG.ENCMD_CANCEL := false;
if CMDNEXT then
   if TOSTEP=1 then (*умова завершення стану*)  
   	CTRL.PAUSING_CMPLT := CTRL.STA_PAUSING;
   	CTRL.RUNING_CMPLT := CTRL.STA_RUNNING;
   	CTRL.STARTING_CMPLT := CTRL.STA_STARTING;
   	CTRL.COMPLETING_CMPLT := CTRL.STA_COMPLETING;
   	CTRL.RESTARTING_CMPLT := CTRL.STA_RESTARTING;
   	CTRL.HOLDING_CMPLT := CTRL.STA_HOLDING;
   	CTRL.STOPPING_CMPLT := CTRL.STA_STOPPING;
   	CTRL.ABORTING_CMPLT := CTRL.STA_ABORTING;
   else 
	CFG.STEP2 := TOSTEP;
   end_if;
   CFG.T_STEP2 := 0;
   CFG.ENCMD_NEXT := false;
end_if;
HMI.ENCMD_NEXT:=CFG.ENCMD_NEXT;(*дозвіл на CMD NEXT з HMI для наступного циклу обробки*)
HMI.ENCMD_OK := CFG.ENCMD_OK; 
HMI.ENCMD_CANCEL := CFG.ENCMD_CANCEL;

</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="PROC_TRANS_M" version="0.07" dateTime="dt#2022-09-12-00:11:05">
		<attribute name="TypeCodeCheckSumString" value="F365"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="896D"></attribute>
		<inputParameters>
			<variables name="TOSTEPOK" typeName="UINT">
				<comment>куди переходити при OK</comment>
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="TOSTEPCANCEL" typeName="UINT">
				<comment>куди переходити при CANCEL</comment>
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="CFG" typeName="PROC_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="HMI" typeName="PROC_HMI">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CTRL" typeName="PROC_CTRL">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="CMDNEXT" typeName="BOOL">
				<comment>умова спрацювала</comment>
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="TOSTEP" typeName="UINT"></variables>
		</privateLocalVariables>
		<FBProgram name="PROC_TRANS_M">
			<STSource>(*Функція реалізовує:
- включає видимість `CMD_OK`
- керує видимістю  `ENCMD_CANCEL` в залежності від `TOSTEPCANCEL` (`ENCMD_CANCEL = TOSTEPCANCEL&gt;0`)
- перехід на крок, вказаний в полі `TOSTEPOK`, якщо відправлена команда `CMD_OK`
- перехід на крок, вказаний в полі `TOSTEPCANCEL`, якщо відправлена команда `CMD_CANCEL`
- відмикає видимість біту `ENCMD_NEXT` *)

CFG.ENCMD_NEXT:=false;
CFG.ENCMD_OK := true; CFG.ENCMD_CANCEL := TOSTEPCANCEL&gt;0;
TOSTEP := 0;
CMDNEXT := false;
if CFG.ENCMD_OK and HMI.CMD = 16#0300  then
   CMDNEXT:=true;
   TOSTEP  := TOSTEPOK;
elsif CFG.ENCMD_CANCEL and HMI.CMD = 16#0301 then
   CMDNEXT:=true;
   TOSTEP := TOSTEPCANCEL;
end_if;

if CMDNEXT then   
   if TOSTEP=1 then (*умова завершення стану*)  
	CTRL.PAUSING_CMPLT := CTRL.STA_PAUSING;
	CTRL.RUNING_CMPLT := CTRL.STA_RUNNING;
	CTRL.STARTING_CMPLT := CTRL.STA_STARTING;
	CTRL.COMPLETING_CMPLT := CTRL.STA_COMPLETING;
	CTRL.RESTARTING_CMPLT := CTRL.STA_RESTARTING;
	CTRL.HOLDING_CMPLT := CTRL.STA_HOLDING;
	CTRL.STOPPING_CMPLT := CTRL.STA_STOPPING;
	CTRL.ABORTING_CMPLT := CTRL.STA_ABORTING;
   else 
	CFG.STEP2 := TOSTEP;
   end_if;
   CFG.T_STEP2 := 0;
   CFG.ENCMD_OK := false;CFG.ENCMD_CANCEL:=false;
end_if;
(*16#0300 – команда підтвердження дій CMD_OK
16#0301 - CANCEL (HMI - негативне пітвердження (відміна) ручної операції)*)

HMI.ENCMD_NEXT:=CFG.ENCMD_NEXT;(*дозвіл на CMD NEXT з HMI для наступного циклу обробки*)
HMI.ENCMD_OK := CFG.ENCMD_OK; 
HMI.ENCMD_CANCEL := CFG.ENCMD_CANCEL;
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_actrs" type="SR" task="MAST"></identProgram>
		<STSource>PFWV.DIVAR_TMP.ID:=0; PFWV.DIVAR_TMP.CLSID:=0;
PFWV.DOVAR_TMP.ID:=0; PFWV.DOVAR_TMP.CLSID:=0;
PFWV.AIVAR_TMP.ID:=0; PFWV.AIVAR_TMP.CLSID:=0;
PFWV.AOVAR_TMP.ID:=0; PFWV.AOVAR_TMP.CLSID:=0;
VLVDFN(ACTCFG:=ACT.VLVD1, ACTHMI:=ACTH.VLVD1, SCLS:=PFWV.DIVAR_TMP, SOPN:=PFWV.DIVAR_TMP, COPN:=PFWV.DOVAR_TMP, PLCCFG := PLC, ACTBUF := ACTBUF ); 
VLVAFN(ACTCFG:=ACT.VLVA1, ACTHMI:=ACTH.VLVA1, CPOS:=PFWV.AOVAR_TMP, PLCCFG := PLC, ACTBUF := ACTBUF ); 
DRVFN(ACTCFG:=ACT.DRV1, ACTHMI:=ACTH.DRV1, RUN:=PFWV.DIVAR_TMP, CSTRT:=PFWV.DOVAR_TMP, CSPD:=PFWV.AOVAR_TMP, PLCCFG := PLC, ACTBUF := ACTBUF );  
</STSource>
	</program>
	<DDTSource DDTName="ACTH" version="0.02" dateTime="dt#2022-05-28-11:05:31">
		<comment>PFW екземпляри ACT_HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="3E5E"></attribute>
		<structure>
			<variables name="VLVD1" typeName="VLVD_HMI"></variables>
			<variables name="VLVA1" typeName="VLVA_HMI"></variables>
			<variables name="DRV1" typeName="DRV_HMI"></variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="VLVD_HMI" version="0.02" dateTime="dt#2022-01-17-17:09:55">
		<comment>PFW структура VLVD для HMI </comment>
		<attribute name="TypeSignatureCheckSumString" value="6639"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда керування</comment>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти тривог</comment>
			</variables>
			<variables name="POS" typeName="INT">
				<comment>позиція ВМ (0-10000)</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="VLVA_HMI" version="0.03" dateTime="dt#2022-03-22-15:06:22">
		<comment>PFW структура VLVA для HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="C8E4"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда керування</comment>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти тривог</comment>
			</variables>
			<variables name="POS" typeName="INT">
				<comment>позиція ВМ (0-10000) - ЗВОРОТНІЙ ЗВЯЗОК</comment>
			</variables>
			<variables name="CPOS" typeName="REAL">
				<comment>позиція ВМ (0-100%) - ЗАДАНЕ ЗНАЧЕННЯ</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DRV_HMI" version="0.02" dateTime="dt#2022-03-18-16:34:43">
		<comment>PFW структура DRV для HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="BDF4"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>команда керування</comment>
			</variables>
			<variables name="ALM" typeName="INT">
				<comment>біти тривог</comment>
			</variables>
			<variables name="SPD" typeName="INT">
				<comment>позиція ВМ (0-10000) - ЗВОРОТНІЙ ЗВЯЗОК</comment>
			</variables>
			<variables name="CSPD" typeName="REAL">
				<comment>позиція ВМ (0-100%) - ЗАДАНЕ ЗНАЧЕННЯ</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="VLVDFN" version="0.62" dateTime="dt#2022-08-29-11:56:40">
		<comment>PFW обробка VLVD</comment>
		<attribute name="TypeCodeCheckSumString" value="E713"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="C6A9"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="VLVD_CFG">
				<comment>CFG ВМ</comment>
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="ACTHMI" typeName="VLVD_HMI">
				<comment>HMI ВМ</comment>
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="SOPN" typeName="DIVAR_CFG">
				<comment>Датчик Відкрито</comment>
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="SCLS" typeName="DIVAR_CFG">
				<comment>Датчик Закрито</comment>
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
			<variables name="COPN" typeName="DOVAR_CFG">
				<comment>керування відкрити</comment>
				<attribute name="PositionPin" value="12"></attribute>
			</variables>
			<variables name="CCLS" typeName="DOVAR_CFG">
				<comment>керування закрити</comment>
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="14"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="15"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="ACTBUFIN" typeName="ACTTR_CFG"></variables>
			<variables name="ACTBUFOUT" typeName="ACTTR_CFG"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="ACTCFGu" typeName="ACTTR_CFG">
				<comment>універсальна структура CFG</comment>
			</variables>
			<variables name="STA" typeName="ACTTR_STA">
				<comment>структура STA</comment>
			</variables>
			<variables name="ALMS" typeName="ACTTR_ALM">
				<comment>структура ALM</comment>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<comment>структура CMD</comment>
			</variables>
			<variables name="SOPN1" typeName="BOOL">
				<comment>значення датчика SOPN</comment>
			</variables>
			<variables name="SCLS1" typeName="BOOL">
				<comment>значення датчика SCLS</comment>
			</variables>
			<variables name="SRUN1" typeName="BOOL">
				<comment>значення датчика RUN</comment>
			</variables>
			<variables name="SPWR1" typeName="BOOL">
				<comment>значення датчика PWR</comment>
			</variables>
			<variables name="SALM1" typeName="BOOL">
				<comment>значення датчика ALM</comment>
			</variables>
			<variables name="SPOS1" typeName="INT">
				<comment>значення віртуального датчика позиції</comment>
			</variables>
			<variables name="dT1" typeName="UDINT">
				<comment>різниця часу між викликами блоку в мс</comment>
			</variables>
			<variables name="dpos" typeName="REAL">
				<comment>приріст відкриття/закриття у 0.01% для імітації</comment>
			</variables>
			<variables name="VLVD_to_ACT" typeName="VLVD_to_ACT"></variables>
			<variables name="ACT_PRE" typeName="ACT_PRE"></variables>
			<variables name="ACT_CMDCTRL" typeName="ACT_CMDCTRL"></variables>
			<variables name="ACT_POST" typeName="ACT_POST"></variables>
			<variables name="ACT_to_VLVD" typeName="ACT_to_VLVD"></variables>
		</privateLocalVariables>
		<FBProgram name="VLVD">
			<STSource>(*передача змінних з конкретного типу ВМ в універсальний тип ВМ *)
VLVD_to_ACT (VLVDCFG := ACTCFG, VLVDHMI := ACTHMI, ACTCFG := ACTCFGu);

(*попередня обробка: ініт STA, ALM, CMD, INBUF, SML, dt *)
ACT_PRE (ACTCFG := ACTCFGu, STA := STA, ALMs := ALMS, CMD := CMD, dt1 := dT1, PLCCFG := PLCCFG, ACTBUF := ACTBUF);

(*ініціалізація змінної на першому циклі обробки*)
IF PLCCFG.STA_SCN1 THEN (*first scan*)
    IF ACTCFGu.T_OPNSP &lt;= 0 THEN (*якщо уставка часу выдкриття не виставлена*)
        ACTCFGu.T_OPNSP := 500; (*5 секунд*)
    END_IF;
    IF ACTCFGu.T_DEASP &lt;= 0 THEN (*якщо уставка затримки часу тривоги не виставлена*)
        ACTCFGu.T_DEASP := 200; (*2 секунди*)
    END_IF;
    (*технологічні тривоги для датчиків не використовуються*)
    IF SOPN.ID &lt;&gt; 0 THEN
        SOPN.PRM_ISALM := false; (*ISALM*)
        SOPN.PRM_ISWRN := false; (*ISWRN*)
    END_IF;
    IF SCLS.ID &lt;&gt; 0 THEN
        SCLS.PRM_ISALM := false; (*ISALM*)
        SCLS.PRM_ISWRN := false; (*ISWRN*)
    END_IF;
END_IF;

(* --------------------- блок параметрів*)
(*параметри перевірка наявності/використання датчиків на вході*)
ACTCFGu.PRM.PRM_MANCFG:=false;(*відключення ручного конфігурування параметрів IO*)
ACTCFGu.PRM.PRM_ZCLSENBL := NOT SCLS.PRM_DSBL AND SCLS.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ZOPNENBL := NOT SOPN.PRM_DSBL AND SOPN.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ZPOSENBL := FALSE; (*відключення позиціонера*)
ACTCFGu.PRM.PRM_PULSCTRLENBL := ACTCFGu.CLSID=16#2014; (*параметри імпульсного керування*)

(*------------------- блок для режиму імітації*)
(*режим імітації підлеглих від хозяїна*)
SOPN.STA_SML := STA.STA_SML;        
SCLS.STA_SML := STA.STA_SML;        
COPN.STA_SML := STA.STA_SML; 
CCLS.STA_SML := STA.STA_SML;       

(*логіка для режиму імітації *) 
IF STA.STA_SML THEN
    dpos:= UDINT_TO_REAL(dT1*100)/UDINT_TO_REAL((UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100));(*%*)
    IF ACTCFGu.STEP1=2  THEN
        ACTCFGu.POS := ACTCFGu.POS + dpos; (*0-10000*)
    END_IF;
    IF ACTCFGu.STEP1=3 THEN
        ACTCFGu.POS := ACTCFGu.POS - dpos; (*0-10000*)
    END_IF;
    IF ACTCFGu.POS&lt;0.0 THEN ACTCFGu.POS:=0.0; END_IF;
    IF ACTCFGu.POS&gt;100.0 THEN ACTCFGu.POS:=100.0; END_IF;  
    
    (*імітація датчиків *)
    IF NOT SOPN.STA_FRC THEN
       SOPN.STA_VALB:= STA.STA_OPNING AND ACTCFGu.T_STEP1 &gt;= UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100 OR STA.STA_OPND; 
    END_IF;
    IF NOT SCLS.STA_FRC THEN
       SCLS.STA_VALB:= STA.STA_CLSING AND ACTCFGu.T_STEP1 &gt;= UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100 OR STA.STA_CLSD; 
    END_IF;          
END_IF;

(*-------------------- блок обробки команд *)
(*стандартний обробник команд*)
ACT_CMDCTRL (ACTCFG := ACTCFGu, STA := STA, CMD := CMD, ACTBUF := ACTBUF);

(* -------------------  блок обробки станів датчиків відкриття/закриття, або їх заміна на логіку*)
IF NOT ACTCFGu.PRM.PRM_ZOPNENBL THEN
    SOPN1:= STA.STA_OPNING AND ACTCFGu.T_STEP1 &gt;= UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100
    OR STA.STA_OPND;
    IF PLCCFG.STA_SCN1 THEN SOPN1:=false; END_IF;
ELSE
    SOPN1:=SOPN.STA_VALB;
END_IF;
IF NOT ACTCFGu.PRM.PRM_ZCLSENBL THEN
    SCLS1:=STA.STA_CLSING AND ACTCFGu.T_STEP1 &gt;= UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100
    OR STA.STA_CLSD;
    IF PLCCFG.STA_SCN1 THEN SCLS1:=TRUE; END_IF;
ELSE
    SCLS1:=SCLS.STA_VALB;
END_IF;

IF NOT ACTCFGu.PRM.PRM_ZPOSENBL THEN
    SPOS1:=-10000;
END_IF;

(*//----------------- автомат станів позиції та тривог позиції та основне керування
//0 -  ініціалізація, 1- зупинено в проміжному стані, 4 - зупинений у відкритому стані, 5 - зупинений в закритому стані  
//7 - рухається в довільному напрямку (ручний зі щита),  2 - відкривається , 3 - закривається  
//керування автоматом станів див в наступному блоці
//керування виходами COPN, CCLS згідно логіки*)
CASE ACTCFGu.STEP1 OF
    0:(*ініціалізація*)
        ACTCFGu.STEP1 := 1;
        ACTCFGu.T_STEP1 := 0;
    1, 4, 5: (*зупинений, 1 - зупинено в проміжному стані 4 - зупинений у відкритому стані, 5 - зупинений в закритому стані*)
        IF SOPN1 AND NOT SCLS1 and not ALMS.ALM_ALMSHFT THEN
            IF ACTCFGu.STEP1&lt;&gt;4 THEN ACTCFGu.T_STEP1 := 0;END_IF;
            ACTCFGu.STEP1 := 4;
	    ALMS.ALM_ALMSHFT:=FALSE; 
            ALMS.ALM_ALMCLS := FALSE;
            ALMS.ALM_ALMOPN := FALSE;
        END_IF;

        IF SCLS1 AND NOT SOPN1 and not ALMS.ALM_ALMSHFT THEN
            IF ACTCFGu.STEP1&lt;&gt;5 THEN ACTCFGu.T_STEP1 := 0;END_IF;
            ACTCFGu.STEP1 := 5;
	    ALMS.ALM_ALMSHFT:=FALSE;
            ALMS.ALM_ALMCLS := FALSE;
            ALMS.ALM_ALMOPN := FALSE;
        END_IF;

        IF ((ACTCFGu.STEP1 = 4 AND NOT SOPN1) OR (ACTCFGu.STEP1 = 5 AND SOPN1)) OR (SOPN1 AND SCLS1) THEN
            ALMS.ALM_ALMSHFT:=true;
                ELSE
            ALMS.ALM_ALMSHFT:=false;
        END_IF;

    2:  (*відкривається*)
        IF SOPN1 AND NOT SCLS1 THEN
            ACTCFGu.STEP1 := 4; (*у стан відкрито*)
            ACTCFGu.T_STEP1 := 0;
        END_IF; 
	       
        ALMS.ALM_ALMOPN := FALSE; 
	ALMS.ALM_ALMCLS := FALSE;
	ALMS.ALM_ALMSHFT:= FALSE;

        IF ACTCFGu.T_STEP1 &gt;= (UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100 + UINT_TO_UDINT(ACTCFGu.T_DEASP)*100) THEN
            ALMS.ALM_ALMOPN := TRUE;
            ALMS.ALM_ALMCLS := FALSE;
            IF SCLS1 AND NOT SOPN1 THEN
                ACTCFGu.STEP1 := 5; (*у стан закрито*)
                ACTCFGu.T_STEP1 := 0;
            END_IF;
        END_IF;

    3:(*закривається*)
        IF SCLS1 AND NOT SOPN1 THEN
            ACTCFGu.STEP1 := 5;
            ACTCFGu.T_STEP1 := 0;
        END_IF;

        ALMS.ALM_ALMOPN := FALSE; 
	ALMS.ALM_ALMCLS := FALSE;
	ALMS.ALM_ALMSHFT:= FALSE;

        IF ACTCFGu.T_STEP1 &gt;= UINT_TO_UDINT(ACTCFGu.T_OPNSP)*100 +  UINT_TO_UDINT(ACTCFGu.T_DEASP)*100 THEN
            ALMS.ALM_ALMCLS := TRUE;
            ALMS.ALM_ALMOPN := FALSE;
            IF SOPN1 AND NOT SCLS1 THEN (*у стан відкрито*) 
                ACTCFGu.STEP1 := 4;
                ACTCFGu.T_STEP1 := 0;
            END_IF;
        END_IF;

    7: (*рухається в довільному напрямку (ручний зі щита) чи помилка довільного зсуву*)
        ALMS.ALM_ALMSHFT:=true;
        ACTCFGu.STEP1 := 1;
        ACTCFGu.T_STEP1 := 0;
        
    ELSE  (*невизначеність*)
        ACTCFGu.STEP1 := 0;
END_CASE;

(*автомат станів побітово*)
STA.STA_IMSTPD:= ACTCFGu.STEP1 = 1;
STA.STA_MANRUNING:= ACTCFGu.STEP1 = 7;
STA.STA_OPNING:= ACTCFGu.STEP1 = 2;
STA.STA_CLSING := ACTCFGu.STEP1 = 3;
STA.STA_OPND:= ACTCFGu.STEP1 = 4;
STA.STA_CLSD:= ACTCFGu.STEP1 = 5;

(*-------- блокуання приводу*)
(*умова блокуання *)
IF CMD.CMD_BLCK THEN
    STA.STA_BLCK:=TRUE;
    ALMS.ALM_ALMSTP:=false;
END_IF; 

(*умова розблокуання *)
IF CMD.CMD_DBLCK THEN
    STA.STA_BLCK:=FALSE;
    ALMS.ALM_ALMSTP:=false;
END_IF; 

(*умова блокуання , умова спрацьовує тільки при початку блокування *)
IF (ALMS.ALM_ALMPWR OR CMD.CMD_PROTECT) AND NOT STA.STA_BLCK THEN 
   STA.STA_BLCK:=true;
END_IF;

(*стан блокування*)
IF STA.STA_BLCK THEN
    COPN.STA_VALB:= FALSE;
    CCLS.STA_VALB:= FALSE;
END_IF;

(*-----------------------------*)

(*------------------------виходи керування *)
(*керування OPN/CLS тільки при дозволі керування або тимчасовому розблокуванні та при відсутності блокування*)
IF (CMD.CMD_RESOLUTION OR PLCCFG.STA_PERM.6) AND NOT STA.STA_BLCK THEN
    IF CMD.CMD_CLS THEN CMD.CMD_OPN:=FALSE; END_IF;(*CLS має пріоритет над OPN*)
    IF CMD.CMD_CLS AND ACTCFGu.STEP1 &lt;&gt; 5 AND ACTCFGu.STEP1 &lt;&gt; 3 THEN
        ACTCFGu.STEP1 := 3;
        ACTCFGu.T_STEP1 := 0;
        ACTCFGu.CNTPER := ACTCFGu.CNTPER + 1;
	COPN.STA_VALB:= FALSE;
	CCLS.STA_VALB:= TRUE;
    END_IF;
    IF CMD.CMD_OPN AND ACTCFGu.STEP1 &lt;&gt; 4 AND ACTCFGu.STEP1 &lt;&gt; 2 THEN
        ACTCFGu.STEP1 := 2;
        ACTCFGu.T_STEP1 := 0;
        ACTCFGu.CNTPER := ACTCFGu.CNTPER + 1;
	COPN.STA_VALB:= TRUE;
	CCLS.STA_VALB:= FALSE;
    END_IF;
END_IF;


(*-------------------- режими*)

(*місцевий режим керування*)
STA.STA_MANBX := CMD.CMD_CLCL; 
(*у місцевому режимі керування відключати усі виходи і перевести в ручний режим*)
IF STA.STA_MANBX THEN
    COPN.STA_VALB:=FALSE;
    CCLS.STA_VALB:= FALSE;
    STA.STA_DISP:=true;
END_IF;

STA.STA_FRC := COPN.STA_FRC AND COPN.ID&lt;&gt;0
    OR CCLS.STA_FRC AND CCLS.ID&lt;&gt;0 
    OR SOPN.STA_FRC AND SOPN.ID&lt;&gt;0  
    OR SCLS.STA_FRC AND SCLS.ID&lt;&gt;0;

(*------------------- зведення кастомних тривог, режимів, бітів*)
IF ALMS.ALM_ALMOPN THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1; 
    IF NOT ACTCFGu.ALM.ALM_ALMOPN THEN
        PLCCFG.ALM_NWALM := TRUE; 
    END_IF;
END_IF;
IF ALMS.ALM_ALMCLS THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1; 
    IF NOT ACTCFGu.ALM.ALM_ALMCLS THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMOPN2 THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1; 
    IF NOT ACTCFGu.ALM.ALM_ALMOPN2 THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMCLS2 THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1; 
    IF NOT ACTCFGu.ALM.ALM_ALMCLS2 THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMSHFT THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1; 
    IF NOT ACTCFGu.ALM.ALM_ALMSHFT THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;


ALMS.ALM_ALM := ALMS.ALM_ALMOPN OR ALMS.ALM_ALMCLS OR ALMS.ALM_ALMOPN2 OR ALMS.ALM_ALMCLS2 OR ALMS.ALM_ALMSHFT OR ALMS.ALM_ALMSTPBTN OR ALMS.ALM_ALMPWR OR STA.STA_BLCK;

(*заключна обробка: зведення в PLC.CFG, STA, ALM, CMD, INBUF, SML, dt *)
ACT_POST (ACTCFG := ACTCFGu, STA := STA, ALMs := ALMS, CMD := CMD, dt1 := dt1, ACTBUF := ACTBUF, PLCCFG := PLCCFG);

ACT_to_VLVD (VLVDCFG := ACTCFG, VLVDHMI := ACTHMI, ACTCFG := ACTCFGu);

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані   *)
   ACTBUFOUT.MSG := 201;

   ACTBUFOUT.T_DEASP := ACTCFG.T_DEASP;
   ACTBUFOUT.T_OPNSP := ACTCFG.T_OPNSP;

   ACTBUFIN.CMDHMI :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані *)
   
   ACTBUFOUT:=ACTBUFIN;

   ACTCFG.T_DEASP := ACTBUFIN.T_DEASP;
   ACTCFG.T_OPNSP := ACTBUFIN.T_OPNSP;

   ACTBUFOUT.MSG := 201;

   ACTBUFIN.CMDHMI :=0; 
end_if;  
</STSource>
		</FBProgram>
	</FBSource>
	<DDTSource DDTName="ACTTR_CFG" version="0.09" dateTime="dt#2022-06-25-18:40:57">
		<comment>PFW структура для універсального ВМ</comment>
		<attribute name="TypeSignatureCheckSumString" value="BA86"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="ACTTR_STA">
				<comment>біти стану</comment>
			</variables>
			<variables name="ALM" typeName="ACTTR_ALM">
				<comment>біти тривог</comment>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<comment>біти команд</comment>
			</variables>
			<variables name="PRM" typeName="ACTTR_PRM">
				<comment>біти параметрыв</comment>
			</variables>
			<variables name="STAHMI1" typeName="INT">
				<comment>біти стану для НМІ</comment>
			</variables>
			<variables name="STAHMI2" typeName="INT">
				<comment>біти стану для НМІ</comment>
			</variables>
			<variables name="ALMHMI1" typeName="INT">
				<comment>біти тривог для НМІ</comment>
			</variables>
			<variables name="ALMHMI2" typeName="INT">
				<comment>біти тривог для НМІ</comment>
			</variables>
			<variables name="CMDHMI" typeName="INT">
				<comment>команди НМІ</comment>
			</variables>
			<variables name="PRMHMI" typeName="INT">
				<comment>параметри НМІ</comment>
			</variables>
			<variables name="T_DEASP" typeName="UINT">
				<comment>час затримки тривоги 0.1 с</comment>
			</variables>
			<variables name="T_OPNSP" typeName="UINT">
				<comment>Максимальний час відкриття в 0.1 секундах</comment>
			</variables>
			<variables name="POS" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗВОРОТНІЙ ЗВЯЗОК</comment>
			</variables>
			<variables name="rez" typeName="INT"></variables>
			<variables name="STEP1" typeName="UINT">
				<comment>крок</comment>
			</variables>
			<variables name="CNTPER" typeName="UINT">
				<comment>кількість перестановок</comment>
			</variables>
			<variables name="CNTALM" typeName="UINT">
				<comment>кількість тривог</comment>
			</variables>
			<variables name="T_STEP1" typeName="UDINT">
				<comment>Плинний час кроку в мс</comment>
			</variables>
			<variables name="T_PREV" typeName="UDINT">
				<comment>час в мс з попереднього виклику, береться зі структури PLC_CFG.TQMS</comment>
			</variables>
			<variables name="VALPREV" typeName="REAL">
				<comment>значення на попередньому циклі</comment>
			</variables>
			<variables name="MVAL" typeName="REAL">
				<comment>значення в ручному режимі</comment>
			</variables>
			<variables name="POWER_IN" typeName="REAL">
				<comment>потужність, кВт</comment>
			</variables>
			<variables name="CPOS" typeName="REAL">
				<comment>позиціяВМ (0-100%) - ЗАДАНЕ ЗНАЧЕННЯ</comment>
			</variables>
			<variables name="SPD" typeName="INT">
				<comment>Обрахунок швидкості обертання ДАТЧЧИК 1, %</comment>
			</variables>
			<variables name="SPD2" typeName="INT">
				<comment>Обрахунок швидкості обертання ДАТЧЧИК 2, %</comment>
			</variables>
			<variables name="SPDWRNSP" typeName="UINT">
				<comment>вставка попередження на пробуксовку привода, %</comment>
			</variables>
			<variables name="SPDALMSP" typeName="UINT">
				<comment>вставка тривоги на пробуксовку привода, %</comment>
			</variables>
			<variables name="STRT_DELAY" typeName="UINT">
				<comment>ЗАТРИМКА НА ВКЛЮЧЕННЯ 0.1 С</comment>
			</variables>
			<variables name="STOP_DELAY" typeName="UINT">
				<comment>ЗАТРИМКА НА ВИКЛЮЧЕННЯ 0.1 С</comment>
			</variables>
			<variables name="TQ_TOTAL" typeName="UDINT">
				<comment>Загальний час напрацювання в хв</comment>
			</variables>
			<variables name="TQ_LAST" typeName="UDINT">
				<comment>Час роботи з останнього пуску в с</comment>
			</variables>
			<variables name="FRQ_IN" typeName="REAL">
				<comment>поточна частота</comment>
			</variables>
			<variables name="FRQ_OUT" typeName="REAL">
				<comment>задана частота</comment>
			</variables>
			<variables name="CURR_IN" typeName="REAL">
				<comment>струм зворотній звязок</comment>
			</variables>
			<variables name="SPDMON_DELAY" typeName="UINT">
				<comment>затримка на початок обрахунку швидкості 0.1 с</comment>
			</variables>
			<variables name="MSG" typeName="UINT">
				<comment>повідомлення</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="ACTTR_STA" version="0.03" dateTime="dt#2022-06-23-18:57:05">
		<comment>PFW біти станів для універсального ВМ </comment>
		<attribute name="TypeSignatureCheckSumString" value="B220"></attribute>
		<structure>
			<variables name="STA1" typeName="INT"></variables>
			<variables name="STA_IMSTPD" typeName="BOOL">
				<comment>=1 зупинився в проміжному стані</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_MANRUNING" typeName="BOOL">
				<comment>=1 рухається в невизначеному напрямку (ручний зі щита)</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_STOPING" typeName="BOOL">
				<comment>=1 Зупиняється</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_OPNING" typeName="BOOL">
				<comment>=1 Відкривається</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_CLSING" typeName="BOOL">
				<comment>=1 Закривається</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_OPND" typeName="BOOL">
				<comment>=1 Відкритий (16#0080)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_CLSD" typeName="BOOL">
				<comment>=1 Закритий (16#0100)</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_MANBXOUT" typeName="BOOL">
				<comment>=1 Включення ручного зі щита</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_WRKED" typeName="BOOL">
				<comment>=1 В роботі</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_DISP" typeName="BOOL">
				<comment>=1 дистанційний режим (з ПК/ОП) (16#0200)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_MANBX" typeName="BOOL">
				<comment>=1 Ручний зі щита (за зворотнім зв'язком)</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INBUF" typeName="BOOL">
				<comment>=1 - змінна в буфері</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_FRC" typeName="BOOL">
				<comment>=1 хоча би одна зі змінних в об’єкті форсована (для зручності відображення при наладці)</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_SML" typeName="BOOL">
				<comment>=1 режим симуляції</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_BLCK" typeName="BOOL">
				<comment>=1 Заблокований</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_STRTING" typeName="BOOL">
				<comment>=1 Запускається</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="STA2" typeName="INT"></variables>
			<variables name="STA_STOPED" typeName="BOOL">
				<comment>=1 Зупинений(16#0100)</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="STA_SLNDBRK" typeName="BOOL">
				<comment>=1 Помилка датчику</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="STA_CMDACK" typeName="BOOL">
				<comment>=1 підтвердження команди</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="STA_SPD1" typeName="BOOL">
				<comment>= 1 Робота, 1-ша швидкість</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="STA_SPD2" typeName="BOOL">
				<comment>= 1 Робота, 2-га швидкість</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="STA_WRNSPD2" typeName="BOOL">
				<comment>= 1 попередження на пробуксовку привода 2, %</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="STA_STRT_DELAY" typeName="BOOL">
				<comment>=1 - йде затримка перед запуском</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="STA_STOP_DELAY" typeName="BOOL">
				<comment>=1 - йде затримка перед зупинкою</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="STA_DBLCKACT" typeName="BOOL">
				<comment>=1 - режим ігнорування CMDRESOLUTION</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="STA_ISREVERS" typeName="BOOL">
				<comment>=1 - пуск з реверсом</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="STA_ISANALOG" typeName="BOOL">
				<comment>=1 з аналоговим керуванням (для зрeчності відображення)</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="STA_INIOTBUF" typeName="BOOL">
				<comment>=1 змінна в буфері IoT</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="STA_SPDMONON" typeName="BOOL">
				<comment>=1 включений контроль швидкості (SPDMON) </comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="STA_SPDCALIBRON" typeName="BOOL">
				<comment>=1 включене калібрування по швидкості</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="STA_MAINT" typeName="BOOL">
				<comment>=1 виведений з обслуговування</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="STA_b31" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="ACTTR_ALM" version="0.04" dateTime="dt#2022-03-18-16:03:11">
		<comment>PFW біти тривог для універсального ВМ</comment>
		<attribute name="TypeSignatureCheckSumString" value="0D1F"></attribute>
		<structure>
			<variables name="ALM1" typeName="INT"></variables>
			<variables name="ALM_ALMSTRT" typeName="BOOL">
				<comment>=1 Не включився (скидається при зміні команди або стану) датчика)</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_ALMSTP" typeName="BOOL">
				<comment>=1 Не відключився (скидається при зміні команди або стану) датчика)</comment>
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_ALMOPN" typeName="BOOL">
				<comment>=1 Не відкрився (Несправність схеми управління)</comment>
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_ALMCLS" typeName="BOOL">
				<comment>=1 Не закрився (Несправність схеми управління)</comment>
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_ALMOPN2" typeName="BOOL">
				<comment>=1 Не відкрився</comment>
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_ALMCLS2" typeName="BOOL">
				<comment>=1 Не закрився (Несправність обладнання по місцю)</comment>
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_ALMSHFT" typeName="BOOL">
				<comment>=1 Порушення стану</comment>
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_ALM" typeName="BOOL">
				<comment>=1 Помилка приводу (по OR)</comment>
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_ALMBELL" typeName="BOOL">
				<comment>=1 Команда включення дзвоника (на один цикл ПЛК)</comment>
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_WRN" typeName="BOOL">
				<comment>=1 Попередження приводу (по OR)</comment>
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_WRNSPD" typeName="BOOL">
				<comment>= 1 попередження на пробуксовку привода, %</comment>
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_ALMSPD" typeName="BOOL">
				<comment>= 1 аварія на пробуксовку привода, %</comment>
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_WRNSPD2" typeName="BOOL">
				<comment>= 1 попередження на пробуксовку привода 2, %</comment>
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_ALMSPD2" typeName="BOOL">
				<comment>= 1 тривога на пробуксовку привода 2, %</comment>
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_ALMPWR" typeName="BOOL">
				<comment>= 1 - немає живлення</comment>
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_ALMSTPBTN" typeName="BOOL">
				<comment>= 1 - натиснута кнопка стоп</comment>
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
			<variables name="ALM2" typeName="INT"></variables>
			<variables name="ALM_ALMINVRTR" typeName="BOOL">
				<comment>= 1 - помилка частотного перетворювача</comment>
				<attribute name="ExtractBit" value="0"></attribute>
			</variables>
			<variables name="ALM_b17" typeName="BOOL">
				<attribute name="ExtractBit" value="1"></attribute>
			</variables>
			<variables name="ALM_b18" typeName="BOOL">
				<attribute name="ExtractBit" value="2"></attribute>
			</variables>
			<variables name="ALM_b19" typeName="BOOL">
				<attribute name="ExtractBit" value="3"></attribute>
			</variables>
			<variables name="ALM_b20" typeName="BOOL">
				<attribute name="ExtractBit" value="4"></attribute>
			</variables>
			<variables name="ALM_b21" typeName="BOOL">
				<attribute name="ExtractBit" value="5"></attribute>
			</variables>
			<variables name="ALM_b22" typeName="BOOL">
				<attribute name="ExtractBit" value="6"></attribute>
			</variables>
			<variables name="ALM_b23" typeName="BOOL">
				<attribute name="ExtractBit" value="7"></attribute>
			</variables>
			<variables name="ALM_b24" typeName="BOOL">
				<attribute name="ExtractBit" value="8"></attribute>
			</variables>
			<variables name="ALM_b25" typeName="BOOL">
				<attribute name="ExtractBit" value="9"></attribute>
			</variables>
			<variables name="ALM_b26" typeName="BOOL">
				<attribute name="ExtractBit" value="10"></attribute>
			</variables>
			<variables name="ALM_b27" typeName="BOOL">
				<attribute name="ExtractBit" value="11"></attribute>
			</variables>
			<variables name="ALM_b28" typeName="BOOL">
				<attribute name="ExtractBit" value="12"></attribute>
			</variables>
			<variables name="ALM_b29" typeName="BOOL">
				<attribute name="ExtractBit" value="13"></attribute>
			</variables>
			<variables name="ALM_b30" typeName="BOOL">
				<attribute name="ExtractBit" value="14"></attribute>
			</variables>
			<variables name="ALM_b31" typeName="BOOL">
				<attribute name="ExtractBit" value="15"></attribute>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="VLVD_to_ACT" version="0.07" dateTime="dt#2022-07-16-10:19:12">
		<comment>PFW приведення VLVD до ACT</comment>
		<attribute name="TypeCodeCheckSumString" value="410A"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="6000"></attribute>
		<inOutParameters>
			<variables name="VLVDCFG" typeName="VLVD_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="VLVDHMI" typeName="VLVD_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="VLVD_to_ACT">
			<STSource>ACTCFG.ID:= VLVDCFG.ID;
ACTCFG.CLSID:= VLVDCFG.CLSID;
ACTCFG.CMD:= VLVDCFG.CMD;
ACTCFG.PRM:= VLVDCFG.PRM;
ACTCFG.T_DEASP:= VLVDCFG.T_DEASP;
ACTCFG.T_OPNSP:= VLVDCFG.T_OPNSP;
ACTCFG.POS:= VLVDCFG.POS;
ACTCFG.STEP1:= VLVDCFG.STEP1;
ACTCFG.CNTPER:= VLVDCFG.CNTPER;
ACTCFG.CNTALM:= VLVDCFG.CNTALM;
ACTCFG.T_STEP1:= VLVDCFG.T_STEP1;
ACTCFG.T_PREV:= VLVDCFG.T_PREV;

ACTCFG.STA.STA_IMSTPD:= VLVDCFG.STA_IMSTPD;
ACTCFG.STA.STA_MANRUNING:= VLVDCFG.STA_MANRUNING;
ACTCFG.STA.STA_DBLCKACT:= VLVDCFG.STA_DBLCKACT;
ACTCFG.STA.STA_OPNING:= VLVDCFG.STA_OPNING;
ACTCFG.STA.STA_CLSING:= VLVDCFG.STA_CLSING;
ACTCFG.STA.STA_OPND:= VLVDCFG.STA_OPND;
ACTCFG.STA.STA_CLSD:= VLVDCFG.STA_CLSD;
ACTCFG.STA.STA_MANBXOUT:= VLVDCFG.STA_MANBXOUT;
ACTCFG.STA.STA_WRKED:= VLVDCFG.STA_WRKED;
ACTCFG.STA.STA_DISP:= VLVDCFG.STA_DISP;
ACTCFG.STA.STA_MANBX:= VLVDCFG.STA_MANBX;
ACTCFG.STA.STA_INBUF:= VLVDCFG.STA_INBUF;
ACTCFG.STA.STA_INIOTBUF:= VLVDCFG.STA_INIOTBUF;
ACTCFG.STA.STA_FRC:= VLVDCFG.STA_FRC;
ACTCFG.STA.STA_SML:= VLVDCFG.STA_SML;
ACTCFG.STA.STA_BLCK:= VLVDCFG.STA_BLCK;
ACTCFG.STA.STA_STOPING:=VLVDCFG.ALM_STOPING;

ACTCFG.ALM.ALM_ALMOPN:= VLVDCFG.ALM_ALMOPN;
ACTCFG.ALM.ALM_ALMCLS:= VLVDCFG.ALM_ALMCLS;
ACTCFG.ALM.ALM_ALMSHFT:= VLVDCFG.ALM_ALMSHFT;
ACTCFG.ALM.ALM_ALMOPN2:= VLVDCFG.ALM_ALMOPN2;
ACTCFG.ALM.ALM_ALMCLS2:= VLVDCFG.ALM_ALMCLS2;
ACTCFG.ALM.ALM_ALM:= VLVDCFG.ALM_ALM;
ACTCFG.ALM.ALM_WRN:= VLVDCFG.ALM_WRN;
ACTCFG.ALM.ALM_ALMSTP:= VLVDCFG.ALM_ALMSTP;
ACTCFG.ALM.ALM_ALMBELL:= VLVDCFG.ALM_ALMBELL;
ACTCFG.ALM.ALM_ALMPWR:= VLVDCFG.ALM_ALMPWR1;
ACTCFG.ALM.ALM_ALMSTPBTN := VLVDCFG.ALM_ALMSTPBTN;
ACTCFG.ALM.ALM_b27 := false;
ACTCFG.ALM.ALM_b28 := VLVDCFG.ALM_SEN;
ACTCFG.ALM.ALM_b29 := VLVDCFG.ALM_b13;
ACTCFG.ALM.ALM_b30 := VLVDCFG.ALM_b14;
ACTCFG.ALM.ALM_b31 := VLVDCFG.ALM_b15;

ACTCFG.CMDHMI:=VLVDHMI.CMD;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_PRE" version="0.12" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка ACT напочатку</comment>
		<attribute name="TypeCodeCheckSumString" value="5DAC"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="58F3"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="STA" typeName="ACTTR_STA">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ALMs" typeName="ACTTR_ALM">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="dt1" typeName="UDINT">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="ACT_PRE">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)
(*початкова обробка для усіх ВМ: інціалізація, присвоєння у внутрішні STA, ALM; визначення INBUF, SML, #dt *)
(*first scan*)
IF PLCCFG.STA_SCN1 THEN 
    (*обнулення бітів структури STA*)
    ACTCFG.STA.STA_IMSTPD:=FALSE;
    ACTCFG.STA.STA_MANRUNING:=FALSE;
    ACTCFG.STA.STA_STOPING:=FALSE;
    ACTCFG.STA.STA_OPNING:=FALSE;
    ACTCFG.STA.STA_CLSING:=FALSE;
    ACTCFG.STA.STA_OPND:=FALSE;
    ACTCFG.STA.STA_CLSD:=FALSE;
    ACTCFG.STA.STA_MANBXOUT:=FALSE;
    ACTCFG.STA.STA_WRKED:=FALSE;
    ACTCFG.STA.STA_DISP:=FALSE;
    ACTCFG.STA.STA_MANBX:=FALSE;
    ACTCFG.STA.STA_INBUF:=FALSE;
    ACTCFG.STA.STA_FRC:=FALSE;
    ACTCFG.STA.STA_SML:=FALSE;
    ACTCFG.STA.STA_BLCK:=FALSE;
    ACTCFG.STA.STA_STRTING:=FALSE;
    ACTCFG.STA.STA_STOPED:=FALSE;
    ACTCFG.STA.STA_SLNDBRK:=FALSE;
    ACTCFG.STA.STA_CMDACK:=FALSE;
    ACTCFG.STA.STA_SPD1:=FALSE;
    ACTCFG.STA.STA_SPD2:=FALSE;
    ACTCFG.STA.STA_WRNSPD2:=FALSE;
    ACTCFG.STA.STA_STRT_DELAY:=FALSE;
    ACTCFG.STA.STA_STOP_DELAY:=FALSE;
    ACTCFG.STA.STA_DBLCKACT:=FALSE;
    ACTCFG.STA.STA_ISREVERS:=FALSE;
    ACTCFG.STA.STA_ISANALOG:=FALSE;
    ACTCFG.STA.STA_INIOTBUF:=FALSE;
    ACTCFG.STA.STA_SPDMONON:=FALSE;
    ACTCFG.STA.STA_SPDCALIBRON:=FALSE;
    ACTCFG.STA.STA_MAINT:=FALSE;
    ACTCFG.STA.STA_b31:=FALSE;
    (*обнулення бітів структури ALM*)
    ACTCFG.ALM.ALM_ALMSTRT:=FALSE;
    ACTCFG.ALM.ALM_ALMSTP:=FALSE;
    ACTCFG.ALM.ALM_ALMOPN:=FALSE;
    ACTCFG.ALM.ALM_ALMCLS:=FALSE;
    ACTCFG.ALM.ALM_ALMOPN2:=FALSE;
    ACTCFG.ALM.ALM_ALMCLS2:=FALSE;
    ACTCFG.ALM.ALM_ALMSHFT:=FALSE;
    ACTCFG.ALM.ALM_ALM:=FALSE;
    ACTCFG.ALM.ALM_ALMBELL:=FALSE;
    ACTCFG.ALM.ALM_WRN:=FALSE;
    ACTCFG.ALM.ALM_WRNSPD:=FALSE;
    ACTCFG.ALM.ALM_ALMSPD:=FALSE;
    ACTCFG.ALM.ALM_WRNSPD2:=FALSE;
    ACTCFG.ALM.ALM_ALMSPD2:=FALSE;
    ACTCFG.ALM.ALM_ALMPWR:=FALSE;
    ACTCFG.ALM.ALM_ALMSTPBTN:=FALSE;
    ACTCFG.ALM.ALM_ALMINVRTR:=FALSE;
    ACTCFG.ALM.ALM_b17:=FALSE;
    ACTCFG.ALM.ALM_b18:=FALSE;
    ACTCFG.ALM.ALM_b19:=FALSE;
    ACTCFG.ALM.ALM_b20:=FALSE;
    ACTCFG.ALM.ALM_b21:=FALSE;
    ACTCFG.ALM.ALM_b22:=FALSE;
    ACTCFG.ALM.ALM_b23:=FALSE;
    ACTCFG.ALM.ALM_b24:=FALSE;
    ACTCFG.ALM.ALM_b25:=FALSE;
    ACTCFG.ALM.ALM_b26:=FALSE;
    ACTCFG.ALM.ALM_b27:=FALSE;
    ACTCFG.ALM.ALM_b28:=FALSE;
    ACTCFG.ALM.ALM_b29:=FALSE;
    ACTCFG.ALM.ALM_b30:=FALSE;
    ACTCFG.ALM.ALM_b31:=FALSE;
    IF ACTCFG.T_OPNSP = 0 THEN ACTCFG.T_OPNSP:=50; END_IF;  
END_IF;
(*//читання інформації з контурів, якщо вони привязані
"RW_LOOP_SEL"(direct:='r', ACT:=#ACTCFG);*)

STA:=ACTCFG.STA;
ALMs := ACTCFG.ALM;
CMD := ACTCFG.CMD;
ALMs.ALM_ALMBELL:= false; (*дзвінок знімається через один цикл*)
STA.STA_INBUF := (ACTCFG.ID = ACTBUF.ID AND ACTBUF.ID &lt;&gt; 0 AND ACTCFG.CLSID = ACTBUF.CLSID);(*знаходиться в буфері конфігурування*)
STA.STA_SML := PLCCFG.STA_SMLALL;(*режим імітації*)
dt1 := PLCCFG.TQMS - ACTCFG.T_PREV; (*різниця між викликами в мс*)
IF dt1&lt;1 THEN dt1:=1; END_IF;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_CMDCTRL" version="0.16" dateTime="dt#2022-07-16-19:36:14">
		<comment>PFW обробник команд ACT</comment>
		<attribute name="TypeCodeCheckSumString" value="F1C4"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="B4F1"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="STA" typeName="ACTTR_STA">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
		</inOutParameters>
		<privateLocalVariables>
			<variables name="CMDINT" typeName="INT"></variables>
		</privateLocalVariables>
		<FBProgram name="ACT_CMDCTRL">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0*)
(*блок обробляє команди з HMI та IOT, формує на основі них CMD, змінює статусні біти стану, обнуляє автоматичні команди в ручному режимі *)
(*вибір джерела конфігураційної/керівної команди HMI згідно пріоритету якщо команди надійшли одночасно*)
IF ACTCFG.CMDHMI &gt; 16#80 THEN (*конфіг кмд з HMI*)
    CMDINT := ACTCFG.CMDHMI;
ELSIF STA.STA_INBUF AND ACTBUF.CMDHMI &gt; 16#80 THEN (*конфіг кмд з буферу*)
    CMDINT := ACTBUF.CMDHMI;
ELSIF ACTCFG.CMDHMI &lt; 16#80 AND ACTCFG.CMDHMI &gt; 0 AND STA.STA_DISP THEN(*керування клапаном з елементу в ручному режимі*)
    CMDINT := ACTCFG.CMDHMI;
ELSIF STA.STA_INBUF AND ACTBUF.CMDHMI &lt; 16#80 AND ACTBUF.CMDHMI &gt; 0 AND STA.STA_DISP THEN (* керування клапаном з буферу в ручному режимі*)
    CMDINT := ACTBUF.CMDHMI; (* команда звідти інакше ігнорити*)
ELSE
    CMDINT := 0;
END_IF;
(*
(*---------------------- команди з IoT буферу, для керування тільки в ручному режимі  
//16#2xxx - команди для ВМ
#INIoTBUF:= ("IOTDB".IOTBUF.ACT.ID = #ACTCFG.ID);
#STA.INIOTBUF := #INIoTBUF;
IF ("IOTDB".IOTBUF.CMD AND 16#F000) = 16#2000 AND ("IOTDB".IOTBUF.ID = #ACTCFG.ID) THEN
    "IOTDB".IOTBUF.ACTH_ID := #ACTCFG.ID; //для запису в BUF
    IF #STA.DISP THEN 
        CASE "IOTDB".IOTBUF.CMD OF
            16#2001: //відкрити
                #CMDINT:=16#1;
            16#2002: //закрити
                #CMDINT:=16#2;
            16#2003: //перемкнути
                #CMDINT:=16#3;
        END_CASE;
    END_IF;
    CASE "IOTDB".IOTBUF.CMD OF
        16#2011: //завантажити буфер
            "IOTDB".IOTBUF.ACT := #ACTCFG;
        16#2012: //запис з буферу в змінну
            ;//
        16#2031: //переведення в ручний
            #CMDINT:=16#0301;
        16#2032: //переведення в автомат
            #CMDINT:=16#0302;
        16#2033: //тогл режиму
            #CMDINT:=16#0303;
    END_CASE;

    "IOTDB".IOTBUF.CMD:=0; "IOTDB".IOTBUF.ID:=0;
END_IF;
// #INIoTBUF Тепер в "ACT" POST 
//------------
*)

(*у рчуному режимі усі автоматичні команди керування обнуляються*)
IF STA.STA_DISP THEN
    CMD.CMD_OPN:=FALSE;
    CMD.CMD_CLS:=FALSE;
    CMD.CMD_TOGGLE:=false;
    CMD.CMD_START:=false;
    CMD.CMD_STOP:=false;
    CMD.CMD_REVERS:=false;
    CMD.CMD_TOGGLE:=FALSE;
END_IF;

(*команди операторського керування
16#0001 - CMD_OPN
16#0002 - CMD_CLS
16#0004 - CMD_ALMRST
16#0008 - CMD_DBLK
16#0010 - CMD_STOP
*)

(* команди HMI*)
CASE CMDINT OF
    16#0001:(*відкрити *)
        CMD.CMD_OPN := TRUE;
        CMD.CMD_CLS := FALSE;
    16#0002:(*закрити *)
        CMD.CMD_CLS := TRUE;
        CMD.CMD_OPN := FALSE;
    16#0003:(*перемкнути*)
        CMD.CMD_TOGGLE := TRUE;
    16#0004:(* Підтвердити тривогу*)
        CMD.CMD_ALMACK:= TRUE; 
    16#0005:(*Скинути тривоги *)
        CMD.CMD_ALMRESET:= TRUE; 
    16#0006:
        CMD.CMD_BLCK:= TRUE; (*Заблокувати*)
    16#0007:
        CMD.CMD_DBLCK:= TRUE; (*Розблокувати*)
    16#0008:
        CMD.CMD_STOPTUN:= TRUE;(*Зупинити автоналаштування*)
    16#0009:
        CMD.CMD_TUNING:= TRUE;(*Запустити автоналаштування *)
    16#000A:
        CMD.CMD_PROTECT:= TRUE;(*Включити алгоритм захисту *)
    16#000B: (*=1 дозвіл на керування*)
        CMD.CMD_RESOLUTION:= TRUE; (*//на один цикл*)
    16#000C: (*=1 запуск калібрування датчика шивдкості*)
        CMD.CMD_P_RESOLUTION := TRUE; (*//на один цикл*)  
    16#000D: (*=1 запуск калібрування датчика шивдкості*)
        CMD.CMD_DBLCKACTTOGGLE := true;
        STA.STA_DBLCKACT := NOT STA.STA_DBLCKACT;
     
    (*E..10 - вільні*)

    16#0011:(*Запустити*)
        CMD.CMD_START:= TRUE; 
        CMD.CMD_STOP:= false;
    16#0012: (*Зупинити*)
        CMD.CMD_STOP:= TRUE;
        CMD.CMD_START:= false;
    16#0013:(*19*)
        CMD.CMD_REVERS:= TRUE;(*Включити реверс *)
    (*14-20 - вільні*)
    16#0021:
        CMD.CMD_UP:= TRUE; (*Більше*)
    16#0022: 
        CMD.CMD_DWN:= TRUE; (*Менше*)
    (*23-9F - вільні*)
    (*починаючи з 16#0080 тільки для роботи з буфера і керування режимом*)
    16#0100: (*прочитати конфігурацію*)
        CMD.CMD_BUFLOAD:=true;
        ACTBUF := ACTCFG;
    16#0101: (*записати конфігурацію*)
        ACTCFG.PRM := ACTBUF.PRM;
	ACTCFG.T_DEASP := ACTBUF.T_DEASP;
        ACTCFG.T_OPNSP := ACTBUF.T_OPNSP;
        ACTCFG.STOP_DELAY := ACTBUF.STOP_DELAY;
        (*запис конфігураційних параметрів в контур, якщо він є*)
        (*"RW_LOOP_SEL"(direct:='c', ACT:=#ACTCFG);*)
    (*102-2FF вільні*)
    16#0300: (*перемкнути ручний/автомат*)
        STA.STA_DISP := NOT STA.STA_DISP;
    16#0301: (*РУЧНИЙ РЕЖИМ*)
        STA.STA_DISP := TRUE;
    16#0302: (*АВТО РЕЖИМ*)
        STA.STA_DISP := FALSE;
    16#0313:(* включити місцевий режим*)
        STA.STA_MANBXOUT := true;
	STA.STA_MANBX := true;
	STA.STA_DISP := TRUE;
        (*#CMD.CRMT:= TRUE; //чи потрібен з програми?*)
    16#0314:(* відключити місцевий режим*)
        STA.STA_MANBXOUT := false;
        STA.STA_MANBX := false;
        (*#CMD.CLCL:= TRUE; //чи потрібен з програми?*)
    16#0315: (*=1 вивести з експлуатації*)
        CMD.CMD_OUTSRVC := true;
    16#0316: (*=1 ввести в експлуатацію*)
        CMD.CMD_INSRVC := true;
    (*керування статистикою*)
    16#0401:(* скинути лічильник тривог 1025*)
        ACTCFG.CNTALM:=0;
    16#0402:(* скинути лічильник спрацювань/переміщень 1026*)
        ACTCFG.CNTPER:=0;
    16#0403:(* скинути лічильник спрацювань/переміщень 1027*)
        ACTCFG.TQ_TOTAL:=0;
    16#0404:(* скинути лічильник спрацювань/переміщень 1028*)
        ACTCFG.TQ_LAST :=0;
END_CASE;

(*проходження команд розблокувати-заблокувати з буфера та НМІ*)
IF ACTCFG.CMDHMI = 16#0006 OR (ACTBUF.CMDHMI = 16#0006 AND STA.STA_INBUF) THEN CMD.CMD_BLCK:= TRUE; END_IF;
IF ACTCFG.CMDHMI = 16#0007 OR (ACTBUF.CMDHMI = 16#0007 AND STA.STA_INBUF) THEN CMD.CMD_DBLCK:= TRUE; END_IF;

CMDINT:=0;
ACTCFG.CMDHMI:=0;
if STA.STA_INBUF then
  ACTBUF.CMDHMI:=0;
end_if;
</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_POST" version="0.19" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка ACT в кінці</comment>
		<attribute name="TypeCodeCheckSumString" value="746B"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="7336"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="STA" typeName="ACTTR_STA">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ALMs" typeName="ACTTR_ALM">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="CMD" typeName="ACTTR_CMD">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="dt1" typeName="UDINT">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="ACT_POST">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)
(*кінцева обробка ВМ перед фцією act_to_XXX: оновлення загальних статусних бітів PLC, 
обмеження лічильників тривог, запис в STA, ALM, оновлення буферу*)
(*режими - в PLC*)
(*загальний біт хоча б одного ручного*)
IF STA.STA_DISP THEN
    PLCCFG.STA_DISP := true;
END_IF; 
IF STA.STA_SML THEN
    PLCCFG.STA_SML := true;
END_IF;
IF ACTCFG.CNTALM &gt; 30000 THEN
    ACTCFG.CNTALM := 30000;
END_IF;
IF ACTCFG.CNTPER &gt; 30000 THEN
    ACTCFG.CNTPER := 30000;
END_IF;
ACTCFG.STA := STA;
ACTCFG.ALM := ALMs;
(*обнулення усіх команд з HMI*)
ACTCFG.CMDHMI := 0;
(*обнулення усіх команд з програми*)

ACTCFG.CMD.CMD_OPN:=FALSE;
ACTCFG.CMD.CMD_CLS:=FALSE;
ACTCFG.CMD.CMD_TOGGLE:=FALSE;
ACTCFG.CMD.CMD_ALMACK:=FALSE;
ACTCFG.CMD.CMD_ALMRESET:=FALSE;
ACTCFG.CMD.CMD_BLCK:=FALSE;
ACTCFG.CMD.CMD_DBLCK:=FALSE;
ACTCFG.CMD.CMD_STOPTUN:=FALSE;
ACTCFG.CMD.CMD_TUNING:=FALSE;
ACTCFG.CMD.CMD_MAN:=FALSE;
ACTCFG.CMD.CMD_AUTO:=FALSE;
ACTCFG.CMD.CMD_PROTECT:=FALSE;
ACTCFG.CMD.CMD_START:=FALSE;
ACTCFG.CMD.CMD_STOP:=FALSE;
ACTCFG.CMD.CMD_UP:=FALSE;
ACTCFG.CMD.CMD_DWN:=FALSE;
ACTCFG.CMD.CMD_CRMT:=FALSE;
ACTCFG.CMD.CMD_RESOLUTION:=FALSE;
ACTCFG.CMD.CMD_REVERS:=FALSE;
ACTCFG.CMD.CMD_CLCL:=FALSE;
ACTCFG.CMD.CMD_DBLCKACTTOGGLE:=FALSE;
ACTCFG.CMD.CMD_STARTDELAY:=FALSE;
ACTCFG.CMD.CMD_STOPDELAY:=FALSE;
ACTCFG.CMD.CMD_P_RESOLUTION:=FALSE;
ACTCFG.CMD.CMD_BUFLOAD:=FALSE;
ACTCFG.CMD.CMD_OUTSRVC:=FALSE;
ACTCFG.CMD.CMD_INSRVC:=FALSE;
ACTCFG.CMD.CMD_b27:=FALSE;
ACTCFG.CMD.CMD_b28:=FALSE;
ACTCFG.CMD.CMD_b29:=FALSE;
ACTCFG.CMD.CMD_b30:=FALSE;
ACTCFG.CMD.CMD_b31:=FALSE;

CMD.CMD_OPN:=FALSE;
CMD.CMD_CLS:=FALSE;
CMD.CMD_TOGGLE:=FALSE;
CMD.CMD_ALMACK:=FALSE;
CMD.CMD_ALMRESET:=FALSE;
CMD.CMD_BLCK:=FALSE;
CMD.CMD_DBLCK:=FALSE;
CMD.CMD_STOPTUN:=FALSE;
CMD.CMD_TUNING:=FALSE;
CMD.CMD_MAN:=FALSE;
CMD.CMD_AUTO:=FALSE;
CMD.CMD_PROTECT:=FALSE;
CMD.CMD_START:=FALSE;
CMD.CMD_STOP:=FALSE;
CMD.CMD_UP:=FALSE;
CMD.CMD_DWN:=FALSE;
CMD.CMD_CRMT:=FALSE;
CMD.CMD_RESOLUTION:=FALSE;
CMD.CMD_REVERS:=FALSE;
CMD.CMD_CLCL:=FALSE;
CMD.CMD_DBLCKACTTOGGLE:=FALSE;
CMD.CMD_STARTDELAY:=FALSE;
CMD.CMD_STOPDELAY:=FALSE;
CMD.CMD_P_RESOLUTION:=FALSE;
CMD.CMD_BUFLOAD:=FALSE;
CMD.CMD_OUTSRVC:=FALSE;
CMD.CMD_INSRVC:=FALSE;
CMD.CMD_b27:=FALSE;
CMD.CMD_b28:=FALSE;
CMD.CMD_b29:=FALSE;
CMD.CMD_b30:=FALSE;
CMD.CMD_b31:=FALSE;

(*sta bits pack*)
ACTCFG.STAHMI1.0:= ACTCFG.STA.STA_IMSTPD;
ACTCFG.STAHMI1.1:= ACTCFG.STA.STA_MANRUNING;
ACTCFG.STAHMI1.2:= ACTCFG.STA.STA_STOPING;
ACTCFG.STAHMI1.3:= ACTCFG.STA.STA_OPNING;
ACTCFG.STAHMI1.4:= ACTCFG.STA.STA_CLSING;
ACTCFG.STAHMI1.5:= ACTCFG.STA.STA_OPND;
ACTCFG.STAHMI1.6:= ACTCFG.STA.STA_CLSD;
ACTCFG.STAHMI1.7:= ACTCFG.STA.STA_MANBXOUT;
ACTCFG.STAHMI1.8:= ACTCFG.STA.STA_WRKED;
ACTCFG.STAHMI1.9:= ACTCFG.STA.STA_DISP;
ACTCFG.STAHMI1.10:= ACTCFG.STA.STA_MANBX;
ACTCFG.STAHMI1.11:= ACTCFG.STA.STA_INBUF;
ACTCFG.STAHMI1.12:= ACTCFG.STA.STA_FRC;
ACTCFG.STAHMI1.13:= ACTCFG.STA.STA_SML;
ACTCFG.STAHMI1.14:= ACTCFG.STA.STA_BLCK;
ACTCFG.STAHMI1.15:= ACTCFG.STA.STA_STRTING;
ACTCFG.STAHMI2.0:= ACTCFG.STA.STA_STOPED;
ACTCFG.STAHMI2.1:= ACTCFG.STA.STA_SLNDBRK;
ACTCFG.STAHMI2.2:= ACTCFG.STA.STA_CMDACK;
ACTCFG.STAHMI2.3:= ACTCFG.STA.STA_SPD1;
ACTCFG.STAHMI2.4:= ACTCFG.STA.STA_SPD2;
ACTCFG.STAHMI2.5:= ACTCFG.STA.STA_WRNSPD2;
ACTCFG.STAHMI2.6:= ACTCFG.STA.STA_STRT_DELAY;
ACTCFG.STAHMI2.7:= ACTCFG.STA.STA_STOP_DELAY;
ACTCFG.STAHMI2.8:= ACTCFG.STA.STA_DBLCKACT;
ACTCFG.STAHMI2.9:= ACTCFG.STA.STA_ISREVERS;
ACTCFG.STAHMI2.10:= ACTCFG.STA.STA_ISANALOG;
ACTCFG.STAHMI2.11:= ACTCFG.STA.STA_INIOTBUF;
ACTCFG.STAHMI2.12:= ACTCFG.STA.STA_SPDMONON;
ACTCFG.STAHMI2.13:= ACTCFG.STA.STA_SPDCALIBRON;
ACTCFG.STAHMI2.14:= ACTCFG.STA.STA_MAINT;
ACTCFG.STAHMI2.15:= ACTCFG.STA.STA_b31;

(*alm bits pack*)
ACTCFG.ALMHMI1.0:= ACTCFG.ALM.ALM_ALMSTRT;
ACTCFG.ALMHMI1.1:= ACTCFG.ALM.ALM_ALMSTP;
ACTCFG.ALMHMI1.2:= ACTCFG.ALM.ALM_ALMOPN;
ACTCFG.ALMHMI1.3:= ACTCFG.ALM.ALM_ALMCLS;
ACTCFG.ALMHMI1.4:= ACTCFG.ALM.ALM_ALMOPN2;
ACTCFG.ALMHMI1.5:= ACTCFG.ALM.ALM_ALMCLS2;
ACTCFG.ALMHMI1.6:= ACTCFG.ALM.ALM_ALMSHFT;
ACTCFG.ALMHMI1.7:= ACTCFG.ALM.ALM_ALM;
ACTCFG.ALMHMI1.8:= ACTCFG.ALM.ALM_ALMBELL;
ACTCFG.ALMHMI1.9:= ACTCFG.ALM.ALM_WRN;
ACTCFG.ALMHMI1.10:= ACTCFG.ALM.ALM_WRNSPD;
ACTCFG.ALMHMI1.11:= ACTCFG.ALM.ALM_ALMSPD;
ACTCFG.ALMHMI1.12:= ACTCFG.ALM.ALM_WRNSPD2;
ACTCFG.ALMHMI1.13:= ACTCFG.ALM.ALM_ALMSPD2;
ACTCFG.ALMHMI1.14:= ACTCFG.ALM.ALM_ALMPWR;
ACTCFG.ALMHMI1.15:= ACTCFG.ALM.ALM_ALMSTPBTN;
ACTCFG.ALMHMI2.0:=ACTCFG.ALM.ALM_ALMINVRTR;
ACTCFG.ALMHMI2.1:=ACTCFG.ALM.ALM_b17;
ACTCFG.ALMHMI2.2:=ACTCFG.ALM.ALM_b18;
ACTCFG.ALMHMI2.3:=ACTCFG.ALM.ALM_b19;
ACTCFG.ALMHMI2.4:=ACTCFG.ALM.ALM_b20;
ACTCFG.ALMHMI2.5:=ACTCFG.ALM.ALM_b21;
ACTCFG.ALMHMI2.6:=ACTCFG.ALM.ALM_b22;
ACTCFG.ALMHMI2.7:=ACTCFG.ALM.ALM_b23;
ACTCFG.ALMHMI2.8:=ACTCFG.ALM.ALM_b24;
ACTCFG.ALMHMI2.9:=ACTCFG.ALM.ALM_b25;
ACTCFG.ALMHMI2.10:=ACTCFG.ALM.ALM_b26;
ACTCFG.ALMHMI2.11:=ACTCFG.ALM.ALM_b27;
ACTCFG.ALMHMI2.12:=ACTCFG.ALM.ALM_b28;
ACTCFG.ALMHMI2.13:=ACTCFG.ALM.ALM_b29;
ACTCFG.ALMHMI2.14:=ACTCFG.ALM.ALM_b30;
ACTCFG.ALMHMI2.15:=ACTCFG.ALM.ALM_b31;


(*оновлення в буфері HMI
//передаємо постійно в буфер тільки ті значення які змінюються постійно*) 
IF STA.STA_INBUF THEN
    ACTBUF.ID := ACTCFG.ID ;
    ACTBUF.CLSID := ACTCFG.CLSID ;
    ACTBUF.CMDHMI := ACTCFG.CMDHMI ;
    ACTBUF.STAHMI1:= ACTCFG.STAHMI1;
    ACTBUF.ALMHMI1:= ACTCFG.ALMHMI1 ;
    ACTBUF.STAHMI2:= ACTCFG.STAHMI2;
    ACTBUF.ALMHMI2:= ACTCFG.ALMHMI2 ;
    ACTBUF.STEP1:= ACTCFG.STEP1 ;
    ACTBUF.T_STEP1:= ACTCFG.T_STEP1;
    ACTBUF.POS := ACTCFG.POS;
    IF NOT STA.STA_DISP THEN
      ACTBUF.CPOS := ACTCFG.CPOS;
    END_IF;
    (*"BUF".ACTBUF.POS_PV :=   #ACTCFG.POS_PV ;*)
    (*"BUF".ACTBUF.POS_SP :=   #ACTCFG.POS_SP ;*)
    ACTBUF.STA:=ACTCFG.STA;
    ACTBUF.ALM:=ACTCFG.ALM;
    ACTBUF.CNTPER:=ACTCFG.CNTPER;
    ACTBUF.CNTALM:=ACTCFG.CNTALM;
END_IF;

(*онвлення в буфері IoT CFG - пишемо весь конфіг
IF #ACTCFG.ID = "IOTDB".IOTBUF.ACT.ID THEN
    "IOTDB".IOTBUF.ACT := #ACTCFG;
END_IF; 
//онвлення в буфері IoT HMI з CFG - пишемо весь конфіг
IF #ACTCFG.ID = "IOTDB".IOTBUF.ACTH_ID THEN
    "IOTDB".IOTBUF.ACTH := #ACTCFG;
END_IF;  

//запис інформації в контурі, якщо він привязаний
"RW_LOOP_SEL"(direct:='w', ACT:=#ACTCFG);
*)

ACTCFG.T_PREV := PLCCFG.TQMS;
ACTCFG.T_STEP1 := ACTCFG.T_STEP1 + dt1;
IF ACTCFG.T_STEP1 &gt; 16#7FFF_FFFF THEN
    ACTCFG.T_STEP1 := 16#7FFF_FFFF;
END_IF;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_to_VLVD" version="0.11" dateTime="dt#2022-07-16-19:36:14">
		<comment>PFW приведення ACT до VLVD</comment>
		<attribute name="TypeCodeCheckSumString" value="5938"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="6000"></attribute>
		<inOutParameters>
			<variables name="VLVDCFG" typeName="VLVD_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="VLVDHMI" typeName="VLVD_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="ACT_to_VLVD">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)
VLVDCFG.ID:= ACTCFG.ID;
VLVDCFG.CLSID:= ACTCFG.CLSID;
VLVDCFG.CMD:= ACTCFG.CMD;
VLVDCFG.PRM:= ACTCFG.PRM;
VLVDCFG.T_DEASP:= ACTCFG.T_DEASP;
VLVDCFG.T_OPNSP:= ACTCFG.T_OPNSP;
VLVDCFG.POS:= ACTCFG.POS;
VLVDCFG.STEP1:= ACTCFG.STEP1;
VLVDCFG.CNTPER:= ACTCFG.CNTPER;
VLVDCFG.CNTALM:= ACTCFG.CNTALM;
VLVDCFG.T_STEP1:= ACTCFG.T_STEP1;
VLVDCFG.T_PREV:= ACTCFG.T_PREV;

VLVDCFG.STA_IMSTPD:= ACTCFG.STA.STA_IMSTPD;
VLVDCFG.STA_MANRUNING:= ACTCFG.STA.STA_MANRUNING;
VLVDCFG.STA_DBLCKACT:= ACTCFG.STA.STA_DBLCKACT;
VLVDCFG.STA_OPNING:= ACTCFG.STA.STA_OPNING;
VLVDCFG.STA_CLSING:= ACTCFG.STA.STA_CLSING;
VLVDCFG.STA_OPND:= ACTCFG.STA.STA_OPND;
VLVDCFG.STA_CLSD:= ACTCFG.STA.STA_CLSD;
VLVDCFG.STA_MANBXOUT:= ACTCFG.STA.STA_MANBXOUT;
VLVDCFG.STA_WRKED:= ACTCFG.STA.STA_WRKED;
VLVDCFG.STA_DISP:= ACTCFG.STA.STA_DISP;
VLVDCFG.STA_MANBX:= ACTCFG.STA.STA_MANBX;
VLVDCFG.STA_INBUF:= ACTCFG.STA.STA_INBUF;
VLVDCFG.STA_INIOTBUF :=ACTCFG.STA.STA_INIOTBUF;
VLVDCFG.STA_FRC:= ACTCFG.STA.STA_FRC;
VLVDCFG.STA_SML:= ACTCFG.STA.STA_SML;
VLVDCFG.STA_BLCK:= ACTCFG.STA.STA_BLCK;

VLVDCFG.ALM_ALMOPN:= ACTCFG.ALM.ALM_ALMOPN;
VLVDCFG.ALM_ALMCLS:= ACTCFG.ALM.ALM_ALMCLS;
VLVDCFG.ALM_ALMSHFT:= ACTCFG.ALM.ALM_ALMSHFT;
VLVDCFG.ALM_ALMOPN2:= ACTCFG.ALM.ALM_ALMOPN2;
VLVDCFG.ALM_ALMCLS2:= ACTCFG.ALM.ALM_ALMCLS2;
VLVDCFG.ALM_ALM:= ACTCFG.ALM.ALM_ALM;
VLVDCFG.ALM_WRN:= ACTCFG.ALM.ALM_WRN;
VLVDCFG.ALM_ALMSTP:= ACTCFG.ALM.ALM_ALMSTP;
VLVDCFG.ALM_ALMBELL:= ACTCFG.ALM.ALM_ALMBELL;
VLVDCFG.ALM_ALMPWR1:= ACTCFG.ALM.ALM_ALMPWR;
VLVDCFG.ALM_ALMSTPBTN:=ACTCFG.ALM.ALM_ALMSTPBTN;
VLVDCFG.ALM_STOPING:=ACTCFG.STA.STA_STOPING;(*бітів STA не вистачило*)
VLVDCFG.ALM_SEN:=false;
VLVDCFG.ALM_b13:=false;
VLVDCFG.ALM_b14:=false;
VLVDCFG.ALM_b15:=false;

VLVDHMI.CMD:=ACTCFG.CMDHMI;

VLVDHMI.STA := VLVDCFG.STA;

VLVDHMI.ALM :=VLVDCFG.ALM;


VLVDHMI.POS := REAL_TO_INT(VLVDCFG.POS);

</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="VLVAFN" version="0.30" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка VLVA</comment>
		<attribute name="TypeCodeCheckSumString" value="B26E"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="CFD4"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="VLVA_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="ACTHMI" typeName="VLVA_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="SOPN" typeName="DIVAR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="SCLS" typeName="DIVAR_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="POS" typeName="AIVAR_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="CPOS" typeName="AOVAR_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="8"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="ACTBUFIN" typeName="ACTTR_CFG"></variables>
			<variables name="ACTBUFOUT" typeName="ACTTR_CFG"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="ACTCFGu" typeName="ACTTR_CFG"></variables>
			<variables name="STA" typeName="ACTTR_STA"></variables>
			<variables name="ALMs" typeName="ACTTR_ALM"></variables>
			<variables name="CMD" typeName="ACTTR_CMD"></variables>
			<variables name="CMDINT" typeName="UINT"></variables>
			<variables name="SOPN1" typeName="BOOL"></variables>
			<variables name="SCLS1" typeName="BOOL"></variables>
			<variables name="SPOS1" typeName="REAL"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="dpos" typeName="REAL"></variables>
			<variables name="VLVA_to_ACT" typeName="VLVA_to_ACT"></variables>
			<variables name="ACT_PRE" typeName="ACT_PRE"></variables>
			<variables name="ACT_CMDCTRL" typeName="ACT_CMDCTRL"></variables>
			<variables name="ACT_POST" typeName="ACT_POST"></variables>
			<variables name="ACT_to_VLVA" typeName="ACT_to_VLVA"></variables>
		</privateLocalVariables>
		<FBProgram name="VLVAFN">
			<STSource>VLVA_to_ACT(VLVACFG:=ACTCFG, VLVAHMI:=ACTHMI, ACTCFG:=ACTCFGu);
(*попередня обробка: ініт STA, ALM, CMD, INBUF, SML, dt *)
ACT_PRE (ACTCFG := ACTCFGu, STA := STA, ALMs := ALMs, CMD := CMD, dt1 := dT1, PLCCFG := PLCCFG, ACTBUF := ACTBUF);
(*значення за замовченням*)
IF PLCCFG.STA_SCN1  THEN (*first scan*)
    IF ACTCFGu.T_OPNSP &lt;= 0 THEN (*якщо уставка часу выдкриття не виставлена*)
        ACTCFGu.T_OPNSP := 500; (*5 секунд*)
    END_IF;
    IF ACTCFGu.T_DEASP &lt;= 0 THEN (*якщо уставка затримки часу тривоги не виставлена*)
        ACTCFGu.T_DEASP := 200; (*2 секунди*)
    END_IF;
    (*технологічні тривоги для датчиків не використовуються*)
    IF SOPN.ID &lt;&gt; 0 THEN
        SOPN.PRM_ISALM := false; (*ISALM*)
        SOPN.PRM_ISWRN := false; (*ISWRN*)
    END_IF;
    IF SCLS.ID &lt;&gt; 0 THEN
        SCLS.PRM_ISALM := false; (*ISALM*)
        SCLS.PRM_ISWRN := false; (*ISWRN*)
    END_IF;
END_IF;

(* --------------------- блок параметрів
//параметри перевірка наявності/використання датчиків на вході*)
ACTCFGu.PRM.PRM_MANCFG:=false;(*у цьому проекті не буде ручного конфігурування параметрів IO*)
ACTCFGu.PRM.PRM_ZCLSENBL := NOT SCLS.PRM_DSBL AND SCLS.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ZOPNENBL := NOT SOPN.PRM_DSBL AND SOPN.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ALMENBL := false;
ACTCFGu.PRM.PRM_ZWRKENBL := false;
ACTCFGu.PRM.PRM_ZPOSENBL := NOT POS.PRM_DSBL AND POS.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_PWRENBL := false;
ACTCFGu.PRM.PRM_BTNSTPENBL := false;
ACTCFGu.PRM.PRM_ALMENBL := false;
ACTCFGu.PRM.PRM_SELLCLENBL := false;
(*параметри імпульсного керування*)
ACTCFGu.PRM.PRM_PULSCTRLENBL := FALSE;

(*------------------- блок для режиму імітації
//режим імітації підлеглих від хозяїна*)
SOPN.STA_SML := STA.STA_SML;
SCLS.STA_SML := STA.STA_SML;

(*логіка для режиму імітації  *)
IF STA.STA_SML THEN
    ACTCFGu.POS:=ACTCFG.CPOS;
    IF ACTCFGu.POS&lt;0.0 THEN ACTCFGu.POS:=0.0; END_IF;
    IF ACTCFGu.POS&gt;100.0 THEN ACTCFGu.POS:=100.0; END_IF;
    
    (*імітація датчиків *)
    IF NOT SOPN.STA_FRC THEN
            SOPN.STA_VALB:= ACTCFGu.POS&gt;99.0;
        END_IF;
    IF NOT SCLS.STA_FRC THEN
            SCLS.STA_VALB:= ACTCFGu.POS&lt;3.0;
    END_IF;
   
END_IF;

(*-------------------- блок обробки команд
//стандартний обробник команд*)
ACT_CMDCTRL(ACTCFG:=ACTCFGu, CMD:=CMD, STA:=STA, ACTBUF := ACTBUF);



(* -------------------  блок обробки станів датчиків відкриття/закриття, або їх заміна на логіку*)
IF NOT ACTCFGu.PRM.PRM_ZPOSENBL THEN       (*// ЯКЩО НЕМА СИГНАЛ ЗВОРОТНЬОГО ЗВЯЗКУ ПОЛОЖЕННЯ*)
    SPOS1:=CPOS.VAL;                   (* // ТО ПОЛОЖЕННЯ ПРИРІВНЮЄМО ЗАДАНОМУ ЗНАЧЕННЮ*)
ELSE
    SPOS1:=POS.VAL;                   (* // ІНАКШЕ БЕРЕЗ ЗНАЧЕННЯ З ДАТЧИКА*)
END_IF;
IF NOT ACTCFGu.PRM.PRM_ZOPNENBL THEN       (*// ЯКЩО НЕМА КІНЦЕВИКА ВІДКРИТО*)
    SOPN1:= SPOS1&gt;=3.0;                     (* // ТО ЗНАЧЕННЯ ВІДКРИТОСТІ БЕРЕМ ЯКЩО ПОЗИЦІЯ БІЛЬШЕ 3*)
ELSE
    SOPN1:=SOPN.STA_VALB;                 (* // ІНАКШЕ БЕРЕЗ ЗНАЧЕННЯ З ДАТЧИКА*)
END_IF;
IF NOT ACTCFGu.PRM.PRM_ZCLSENBL THEN     (*  // ЯКЩО НЕМА КІНЦЕВИКА ЗАКРИТО*)
    SCLS1:=SPOS1&lt;3.0;                      (* // ТО ЗНАЧЕННЯ ВІДКРИТОСТІ БЕРЕМ ЯКЩО ПОЗИЦІЯ МЕНШЕ 3*)
ELSE
    SCLS1:=SCLS.STA_VALB;                 (* // ІНАКШЕ БЕРЕЗ ЗНАЧЕННЯ З ДАТЧИКА*)
END_IF;


(*----------------- автомат станів позиції та тривог позиції  *)
CASE ACTCFGu.STEP1 OF
    0:(*ініціалізація*)
        ACTCFGu.STEP1 := 1;
        ACTCFGu.T_STEP1 := 0;
    1, 4, 5: (*зупинений, 1 - зупинено в проміжному стані 4 - зупинений у відкритому стані, 5 - зупинений в закритому стані*)
        IF ACTCFGu.POS&gt;3.0 AND ACTCFGu.STEP1 &lt;&gt; 4 THEN
            ACTCFGu.STEP1 := 4;
            ACTCFGu.T_STEP1 := 0;
        END_IF;
        IF ACTCFGu.POS&lt;3.0 AND ACTCFGu.STEP1 &lt;&gt; 5  THEN
            ACTCFGu.STEP1 := 5;
            ACTCFGu.T_STEP1 := 0;
        END_IF;
    ELSE  (*невизначеність*)
        ACTCFGu.STEP1 := 0;
END_CASE;
(*автомат станів побітово*)
STA.STA_IMSTPD:= ACTCFGu.STEP1 = 0 OR ACTCFGu.STEP1 = 1;
STA.STA_OPND:= ACTCFGu.STEP1 = 4;
STA.STA_CLSD:= ACTCFGu.STEP1 = 5;



(*----------------------------- керування ВМ*)

(*керування OPN/CLS тільки при дозволі керування або тимчасовому розблокуванні*)
IF (CMD.CMD_RESOLUTION OR PLCCFG.STA_PERM.6) AND NOT STA.STA_BLCK THEN
    ;
ELSE
    ACTCFG.CPOS:=0.0;
    ACTHMI.CPOS:=0.0;
END_IF;

(*-------------------- режими*)

STA.STA_FRC := CPOS.STA_FRC AND CPOS.ID&lt;&gt;0
OR POS.STA_FRC AND POS.ID&lt;&gt;0
OR SOPN.STA_FRC AND SOPN.ID&lt;&gt;0
OR SCLS.STA_FRC AND SCLS.ID&lt;&gt;0;

(*------------------- зведення ксатомних тривог, режимів, бітів*)

ALMs.ALM_ALM := false;

ACTCFG.POS := SPOS1;
 

(*заключна обробка: зведення в PLC.CFG, STA, ALM, CMD, INBUF, SML, dt *) 
ACT_POST(ACTCFG:=ACTCFGu, STA:=STA, ALMs:=ALMs, CMD:=CMD, dt1 := dT1, ACTBUF := ACTBUF, PLCCFG := PLCCFG);


ACT_to_VLVA(VLVACFG:=ACTCFG, VLVAHMI:=ACTHMI, ACTCFG:=ACTCFGu);


(*------------------- вибір джерела завдання*)
IF ACTCFGu.STA.STA_INBUF AND ACTCFGu.STA.STA_DISP THEN
    ACTCFGu.CPOS := ACTBUF.CPOS;
    ACTHMI.CPOS := ACTCFGu.CPOS;
    ACTCFG.CPOS := ACTCFGu.CPOS;
ELSIF NOT ACTCFGu.STA.STA_INBUF AND ACTCFGu.STA.STA_DISP THEN
    ACTCFGu.CPOS := ACTHMI.CPOS;
    ACTHMI.CPOS := ACTCFGu.CPOS;
    ACTCFG.CPOS := ACTCFGu.CPOS;
ELSE
    ACTCFGu.CPOS := ACTCFG.CPOS;
    ACTHMI.CPOS := ACTCFGu.CPOS;
    ACTCFG.CPOS := ACTCFGu.CPOS;
END_IF;
CPOS.VAL:=ACTCFGu.CPOS;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані   *)
   ACTBUFOUT.MSG := 201;

   ACTBUFOUT.T_DEASP := ACTCFG.T_DEASP;

   ACTBUFIN.CMDHMI :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані *)
   
   ACTBUFOUT:=ACTBUFIN;

   ACTCFG.T_DEASP := ACTBUFIN.T_DEASP;

   ACTBUFOUT.MSG := 201;

   ACTBUFIN.CMDHMI :=0; 
end_if;  

</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="VLVA_to_ACT" version="0.03" dateTime="dt#2022-07-16-10:19:11">
		<comment>PFW приведення VLVA до ACT</comment>
		<attribute name="TypeCodeCheckSumString" value="5B81"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="629E"></attribute>
		<inOutParameters>
			<variables name="VLVACFG" typeName="VLVA_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="VLVAHMI" typeName="VLVA_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="VLVA_to_ACT">
			<STSource>ACTCFG.ID:= VLVACFG.ID;
ACTCFG.CLSID:= VLVACFG.CLSID;
ACTCFG.CMD:= VLVACFG.CMD;
ACTCFG.PRM:= VLVACFG.PRM;
ACTCFG.T_DEASP:= VLVACFG.T_DEASP;
ACTCFG.POS:= VLVACFG.POS;
ACTCFG.CPOS:= VLVACFG.CPOS;
ACTCFG.STEP1:= VLVACFG.STEP1;
ACTCFG.CNTPER:= VLVACFG.CNTPER;
ACTCFG.CNTALM:= VLVACFG.CNTALM;
ACTCFG.T_STEP1:= VLVACFG.T_STEP1;
ACTCFG.T_PREV:= VLVACFG.T_PREV;

ACTCFG.STA.STA_OPND:= VLVACFG.STA_OPND;
ACTCFG.STA.STA_CLSD:= VLVACFG.STA_CLSD;
ACTCFG.STA.STA_DISP:= VLVACFG.STA_DISP;
ACTCFG.STA.STA_MANBX:= VLVACFG.STA_MANBX;
ACTCFG.STA.STA_INBUF:= VLVACFG.STA_INBUF;
ACTCFG.STA.STA_FRC:= VLVACFG.STA_FRC;
ACTCFG.STA.STA_SML:= VLVACFG.STA_SML;
ACTCFG.STA.STA_BLCK:= VLVACFG.STA_BLCK;

ACTCFG.CMDHMI:=VLVAHMI.CMD;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_to_VLVA" version="0.07" dateTime="dt#2022-07-16-19:36:14">
		<comment>PFW приведення ACT до VLVA</comment>
		<attribute name="TypeCodeCheckSumString" value="D56F"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="629E"></attribute>
		<inOutParameters>
			<variables name="VLVACFG" typeName="VLVA_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="VLVAHMI" typeName="VLVA_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="ACT_to_VLVA">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)
VLVACFG.ID:= ACTCFG.ID;
VLVACFG.CLSID:= ACTCFG.CLSID;
VLVACFG.CMD:= ACTCFG.CMD;
VLVACFG.PRM:= ACTCFG.PRM;
VLVACFG.T_DEASP:= ACTCFG.T_DEASP;

VLVACFG.POS:= ACTCFG.POS;
VLVACFG.CPOS:= ACTCFG.CPOS;
VLVACFG.STEP1:= ACTCFG.STEP1;
VLVACFG.CNTPER:= ACTCFG.CNTPER;
VLVACFG.CNTALM:= ACTCFG.CNTALM;
VLVACFG.T_STEP1:= ACTCFG.T_STEP1;
VLVACFG.T_PREV:= ACTCFG.T_PREV;

VLVACFG.STA_b0:= false;
VLVACFG.STA_b1:= false;
VLVACFG.STA_b2:= false;
VLVACFG.STA_b3:= false;
VLVACFG.STA_b4:= false;
VLVACFG.STA_OPND:= ACTCFG.STA.STA_OPND;
VLVACFG.STA_CLSD:= ACTCFG.STA.STA_CLSD;
VLVACFG.STA_b7:= false;
VLVACFG.STA_b8:= false;
VLVACFG.STA_DISP:= ACTCFG.STA.STA_DISP;
VLVACFG.STA_MANBX:= ACTCFG.STA.STA_MANBX;
VLVACFG.STA_INBUF:= ACTCFG.STA.STA_INBUF;
VLVACFG.STA_FRC:= ACTCFG.STA.STA_FRC;
VLVACFG.STA_SML:= ACTCFG.STA.STA_SML;
VLVACFG.STA_BLCK:= ACTCFG.STA.STA_BLCK;


VLVACFG.ALM_b0:= false;
VLVACFG.ALM_b1:= false;
VLVACFG.ALM_b2:= false;
VLVACFG.ALM_b3:= false;
VLVACFG.ALM_b4:= false;
VLVACFG.ALM_b5:= false;
VLVACFG.ALM_b6:= false;
VLVACFG.ALM_b7:= false;
VLVACFG.ALM_b8:= false;
VLVACFG.ALM_b9:= false;
VLVACFG.ALM_b10:= false;
VLVACFG.ALM_b11:= false;
VLVACFG.ALM_b12:= false;
VLVACFG.ALM_b13:= false;
VLVACFG.ALM_b14:= false;
VLVACFG.ALM_b15:= false;

VLVAHMI.CMD:=ACTCFG.CMDHMI;

VLVAHMI.STA.0 := VLVACFG.STA_b0;
VLVAHMI.STA.1 :=VLVACFG.STA_b1;
VLVAHMI.STA.2 :=VLVACFG.STA_b2;
VLVAHMI.STA.3 :=VLVACFG.STA_b3;
VLVAHMI.STA.4 :=VLVACFG.STA_b4;
VLVAHMI.STA.5 :=VLVACFG.STA_OPND;
VLVAHMI.STA.6 :=VLVACFG.STA_CLSD;
VLVAHMI.STA.7 := VLVACFG.STA_b7;
VLVAHMI.STA.8 := VLVACFG.STA_b8;
VLVAHMI.STA.9 :=VLVACFG.STA_DISP;
VLVAHMI.STA.10 :=VLVACFG.STA_MANBX;
VLVAHMI.STA.11 := VLVACFG.STA_INIOTBUF;
VLVAHMI.STA.12 :=VLVACFG.STA_INBUF;
VLVAHMI.STA.13 := VLVACFG.STA_FRC;
VLVAHMI.STA.14 :=VLVACFG.STA_SML;
VLVAHMI.STA.15 :=VLVACFG.STA_BLCK;

VLVAHMI.ALM.0 :=VLVACFG.ALM_b0;
VLVAHMI.ALM.1 :=VLVACFG.ALM_b1;
VLVAHMI.ALM.2 :=VLVACFG.ALM_b2;
VLVAHMI.ALM.3 :=VLVACFG.ALM_b3;
VLVAHMI.ALM.4 :=VLVACFG.ALM_b4;
VLVAHMI.ALM.5 :=VLVACFG.ALM_b5;
VLVAHMI.ALM.6 :=VLVACFG.ALM_b6;
VLVAHMI.ALM.7 :=VLVACFG.ALM_b7;
VLVAHMI.ALM.8 :=VLVACFG.ALM_b8;
VLVAHMI.ALM.9 :=VLVACFG.ALM_b9;
VLVAHMI.ALM.10 :=VLVACFG.ALM_b10;
VLVAHMI.ALM.11 :=VLVACFG.ALM_b11;
VLVAHMI.ALM.12 :=VLVACFG.ALM_b12;
VLVAHMI.ALM.13 :=VLVACFG.ALM_b13;
VLVAHMI.ALM.14 :=VLVACFG.ALM_b14;
VLVAHMI.ALM.15 :=VLVACFG.ALM_b15;


VLVAHMI.POS := REAL_TO_INT(VLVACFG.POS)*100;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="DRVFN" version="0.52" dateTime="dt#2022-08-29-11:56:40">
		<comment>PFW обробка DRV</comment>
		<attribute name="TypeCodeCheckSumString" value="DFB3"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="D19E"></attribute>
		<inOutParameters>
			<variables name="ACTCFG" typeName="DRV_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="ACTHMI" typeName="DRV_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="LSTP" typeName="DIVAR_CFG">
				<comment>кнопка стоп по місцю</comment>
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="RUN" typeName="DIVAR_CFG">
				<comment>сигнал робота</comment>
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="RDY" typeName="DIVAR_CFG">
				<comment>готовність пристрою до роботи</comment>
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="ALM" typeName="DIVAR_CFG">
				<comment>помилка ПЧ</comment>
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
			<variables name="RMT" typeName="DIVAR_CFG">
				<comment>перемикач в місцевий по місцю</comment>
				<attribute name="PositionPin" value="7"></attribute>
			</variables>
			<variables name="SPDC" typeName="DIVAR_CFG">
				<comment>контакт дискретного датчику контролю обертів</comment>
				<attribute name="PositionPin" value="13"></attribute>
			</variables>
			<variables name="CSTRT" typeName="DOVAR_CFG">
				<comment>команда запуску</comment>
				<attribute name="PositionPin" value="8"></attribute>
			</variables>
			<variables name="SPD" typeName="AIVAR_CFG">
				<comment>плинне значення швидкості</comment>
				<attribute name="PositionPin" value="9"></attribute>
			</variables>
			<variables name="CSPD" typeName="AOVAR_CFG">
				<comment>задане значення швидкості</comment>
				<attribute name="PositionPin" value="10"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="11"></attribute>
			</variables>
			<variables name="ACTBUF" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="12"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="ACTBUFIN" typeName="ACTTR_CFG"></variables>
			<variables name="ACTBUFOUT" typeName="ACTTR_CFG"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="ACTCFGu" typeName="ACTTR_CFG"></variables>
			<variables name="STA" typeName="ACTTR_STA"></variables>
			<variables name="ALMS" typeName="ACTTR_ALM"></variables>
			<variables name="CMD" typeName="ACTTR_CMD"></variables>
			<variables name="CMDINT" typeName="UINT"></variables>
			<variables name="SOPN1" typeName="BOOL"></variables>
			<variables name="SCLS1" typeName="BOOL"></variables>
			<variables name="SRUN1" typeName="BOOL"></variables>
			<variables name="SPWR1" typeName="BOOL"></variables>
			<variables name="SALM1" typeName="BOOL"></variables>
			<variables name="SPOS1" typeName="REAL"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="dpos" typeName="REAL"></variables>
			<variables name="DRV_to_ACT" typeName="DRV_to_ACT"></variables>
			<variables name="ACT_PRE" typeName="ACT_PRE"></variables>
			<variables name="ACT_CMDCTRL" typeName="ACT_CMDCTRL"></variables>
			<variables name="ACT_POST" typeName="ACT_POST"></variables>
			<variables name="ACT_to_DRV" typeName="ACT_to_DRV"></variables>
		</privateLocalVariables>
		<FBProgram name="DRV">
			<STSource>DRV_to_ACT(DRVCFG:=ACTCFG,  DRVHMI:=ACTHMI, ACTCFG:=ACTCFGu);
(*попередня обробка: ініт STA, ALM, CMD, INBUF, SML, dt *)
ACT_PRE (ACTCFG := ACTCFGu, STA := STA, ALMs := ALMS, CMD := CMD, dt1 := dT1, PLCCFG := PLCCFG, ACTBUF := ACTBUF);
(*значення за замовченням*)
IF PLCCFG.STA_SCN1 THEN (*first scan*)
    IF ACTCFGu.T_OPNSP &lt;= 0 THEN (*якщо уставка часу выдкриття не виставлена*)
        ACTCFGu.T_OPNSP := 500; (*5 секунд*)
    END_IF;
    IF ACTCFGu.T_DEASP &lt;= 0 THEN (*якщо уставка затримки часу тривоги не виставлена*)
        ACTCFGu.T_DEASP := 200; (*2 секунди*)
    END_IF;
    (*технологічні тривоги для датчиків не використовуються*)
    IF RUN.ID &lt;&gt; 0 THEN
        RUN.PRM_ISALM := false; (*ISALM*)
        RUN.PRM_ISWRN := false; (*ISWRN*)
    END_IF;

END_IF;

(* --------------------- блок параметрів*)
(*параметри перевірка наявності/використання датчиків на вході*)
ACTCFGu.PRM.PRM_MANCFG     := false;(*у цьому проекті не буде ручного конфігурування параметрів IO*)
ACTCFGu.PRM.PRM_ALMENBL    := NOT ALM.PRM_DSBL AND ALM.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ZWRKENBL   := NOT RUN.PRM_DSBL AND RUN.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ZPOSENBL   := NOT SPD.PRM_DSBL AND SPD.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_PWRENBL    := NOT RDY.PRM_DSBL AND RDY.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_BTNSTPENBL := NOT LSTP.PRM_DSBL AND LSTP.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_ALMENBL    := NOT ALM.PRM_DSBL AND ALM.ID &lt;&gt; 0;
ACTCFGu.PRM.PRM_SELLCLENBL := NOT RMT.PRM_DSBL AND RMT.ID &lt;&gt; 0;

(*------------------- блок для режиму імітації*)
(*режим імітації підлеглих від хозяїна*)
LSTP.STA_SML := STA.STA_SML;
RUN.STA_SML := STA.STA_SML;
RDY.STA_SML := STA.STA_SML;
ALM.STA_SML := STA.STA_SML;
RMT.STA_SML := STA.STA_SML;
CSTRT.STA_SML := STA.STA_SML;
SPD.STA_SML := STA.STA_SML;
CSPD.STA_SML := STA.STA_SML;

(*логіка для режиму імітації  *)
IF STA.STA_SML THEN
    (*імітація датчиків *)
    IF NOT SPD.STA_FRC THEN SPD.VAL := CSPD.VAL; END_IF;
    IF NOT RUN.STA_FRC THEN RUN.STA_VALB:=ACTCFGu.STEP1=2 OR ACTCFGu.STEP1=4; END_IF;
    IF NOT RDY.STA_FRC THEN RDY.STA_VALB:=true; END_IF; (*живлення є*)
    IF NOT ALM.STA_FRC THEN ALM.STA_VALB := false; END_IF;(*тривоги немає*)
END_IF;

(*-------------------- блок обробки команд
//стандартний обробник команд*)
ACT_CMDCTRL (ACTCFG := ACTCFGu, STA := STA, CMD := CMD, ACTBUF := ACTBUF);

(*переключення в ручний режим при включенні локального ручного і блокування усіх команд*)
IF (RMT.STA_VALB AND NOT RMT.PRM_DSBL AND ACTCFGu.PRM.PRM_SELLCLENBL) OR STA.STA_MANBXOUT OR STA.STA_MANBX THEN
    (*CMD_RESET*)
    CMD.CMD_OPN:=FALSE;
    CMD.CMD_CLS:=FALSE;
    CMD.CMD_TOGGLE:=FALSE;
    CMD.CMD_ALMACK:=FALSE;
    CMD.CMD_ALMRESET:=FALSE;
    CMD.CMD_BLCK:=FALSE;
    CMD.CMD_DBLCK:=FALSE;
    CMD.CMD_STOPTUN:=FALSE;
    CMD.CMD_TUNING:=FALSE;
    CMD.CMD_MAN:=FALSE;
    CMD.CMD_AUTO:=FALSE;
    CMD.CMD_PROTECT:=FALSE;
    CMD.CMD_START:=FALSE;
    CMD.CMD_STOP:=FALSE;
    CMD.CMD_UP:=FALSE;
    CMD.CMD_DWN:=FALSE;
    CMD.CMD_CRMT:=FALSE;
   (* CMD.CMD_RESOLUTION:=FALSE;*)
    CMD.CMD_REVERS:=FALSE;
    CMD.CMD_CLCL:=FALSE;
    CMD.CMD_DBLCKACTTOGGLE:=FALSE;
    CMD.CMD_STARTDELAY:=FALSE;
    CMD.CMD_STOPDELAY:=FALSE;
    CMD.CMD_P_RESOLUTION:=FALSE;
    CMD.CMD_BUFLOAD:=FALSE;
   (* CMD.CMD_OUTSRVC:=FALSE;*)
   (* CMD.CMD_INSRVC:=FALSE;*)
    CMD.CMD_b27:=FALSE;
    CMD.CMD_b28:=FALSE;
    CMD.CMD_b29:=FALSE;
    CMD.CMD_b30:=FALSE;
    CMD.CMD_b31:=FALSE;
END_IF;

(* -------------------  блок обробки станів датчиків відкриття/закриття, або їх заміна на логіку*)
IF NOT ACTCFGu.PRM.PRM_ZWRKENBL THEN
    SRUN1:=ACTCFGu.STEP1=2 OR ACTCFGu.STEP1=4;
ELSE
    SRUN1:=RUN.STA_VALB;
END_IF;
IF NOT ACTCFGu.PRM.PRM_PWRENBL THEN
    SPWR1:=true;
ELSE
    SPWR1:=RDY.STA_VALB;
END_IF;
IF NOT ACTCFGu.PRM.PRM_ALMENBL THEN
    SALM1:=FALSE;
ELSE
    SALM1:=ALM.STA_VALB;
END_IF;
IF NOT ACTCFGu.PRM.PRM_ZPOSENBL THEN       (* ЯКЩО НЕМА СИГНАЛ ЗВОРОТНЬОГО ЗВЯЗКУ ПОЛОЖЕННЯ*)
    SPOS1:=CSPD.VAL;                     (* ТО ПОЛОЖЕННЯ ПРИРІВНЮЄМО ЗАДАНОМУ ЗНАЧЕННЮ*)
ELSE
    SPOS1:=SPD.VAL;                     (* ІНАКШЕ БЕРЕЗ ЗНАЧЕННЯ З ДАТЧИКА*)
END_IF;

(*----------------- автомат станів позиції та тривог позиції  *)

CASE ACTCFGu.STEP1 OF
    0:(*ініціалізація*)
        ACTCFGu.STEP1 := 1;
        ACTCFGu.T_STEP1 := 0;
    1, 4, 5: (*кінцеві стани, 1 - невизначений 4 - запущений, 5 - зупинений*)
        IF ((ACTCFGu.STEP1 = 4 AND NOT SRUN1) OR (ACTCFGu.STEP1 = 5 AND SRUN1)) AND NOT STA.STA_MANBX THEN
	    ALMS.ALM_ALMSHFT:=true;
        ELSE
            ALMS.ALM_ALMSHFT:=FALSE;
        END_IF;

        IF SRUN1 AND NOT ALMS.ALM_ALMSHFT THEN
            ACTCFGu.STEP1 := 4;
            CSTRT.STA_VALB:=true;
        END_IF;
        IF NOT SRUN1 AND NOT ALMS.ALM_ALMSHFT THEN
            ACTCFGu.STEP1 := 5;
            CSTRT.STA_VALB:=FALSE;
	    STA.STA_ISREVERS:=FALSE;
        END_IF;
       
    2:  (*запускається*)
        CSTRT.STA_VALB:=true;
        IF SRUN1 THEN
            ACTCFGu.STEP1 := 4; (*у стан запущено*)
            ACTCFGu.T_STEP1 := 0;
        END_IF;
        
        ALMS.ALM_ALMSTRT := FALSE;
        ALMS.ALM_ALMSTP := FALSE;
        
        IF ACTCFGu.T_STEP1 &gt;= (UINT_TO_UDINT(ACTCFGu.T_DEASP)*100) THEN
            ALMS.ALM_ALMSTRT := TRUE;
            ALMS.ALM_ALMSTP := FALSE;
            ACTCFGu.STEP1 := 6; (*у стан заблоковано*)
            ACTCFGu.T_STEP1 := 0;
        END_IF;
    3:  (*зупиняється*)
        CSTRT.STA_VALB:=FALSE;
        IF NOT SRUN1 THEN
	    STA.STA_ISREVERS:=FALSE;
            ACTCFGu.STEP1 := 5;
            ACTCFGu.T_STEP1 := 0;
        END_IF;
        
        ALMS.ALM_ALMCLS := false;
        ALMS.ALM_ALMOPN := FALSE;
          
        IF ACTCFGu.T_STEP1 &gt;= (UINT_TO_UDINT(ACTCFGu.T_DEASP)*100) THEN
            ALMS.ALM_ALMSTP := TRUE;
            ALMS.ALM_ALMSTRT := FALSE;
            ACTCFGu.STEP1 := 6; (*у стан заблоковано*)
            ACTCFGu.T_STEP1 := 0;
        END_IF;
    6: (*заблоковано*)
        CSTRT.STA_VALB:=FALSE;
	STA.STA_ISREVERS:=FALSE;
        IF CMD.CMD_DBLCK THEN
            ACTCFGu.STEP1 := 5; (*у стан зупинено*)
            ACTCFGu.T_STEP1 := 0;
            ALMS.ALM_ALMSTRT:=FALSE;
            ALMS.ALM_ALMSTP:=FALSE;
            ALMS.ALM_ALMINVRTR:=FALSE;
            ALMS.ALM_ALMPWR:=FALSE;
            ALMS.ALM_ALMSHFT:=FALSE;
        END_IF;
    ELSE  (*невизначеність*)
        ACTCFGu.STEP1 := 0;
END_CASE;

STA.STA_ISANALOG:=CSPD.ID&lt;&gt;0;
STA.STA_STOPING :=ACTCFGu.STEP1 = 3;
STA.STA_STRTING :=ACTCFGu.STEP1 = 2;
STA.STA_STOPED  :=ACTCFGu.STEP1 = 5 OR ACTCFGu.STEP1 = 6;
STA.STA_WRKED   :=ACTCFGu.STEP1 = 4;
STA.STA_BLCK    :=ACTCFGu.STEP1 = 6 and not STA.STA_MAINT;


(*----------------------------- керування ВМ*)
IF CMD.CMD_STOP THEN
    CSTRT.STA_VALB:=FALSE;
END_IF;
IF CMD.CMD_REVERS THEN
    CMD.CMD_START:= TRUE; 
    CMD.CMD_STOP:= false;
    STA.STA_ISREVERS:=TRUE;
END_IF;
(*керування start/stop тільки при дозволі керування або тимчасовому розблокуванні*)
IF (CMD.CMD_RESOLUTION OR PLCCFG.STA_PERM.6) AND NOT STA.STA_BLCK THEN
    IF CMD.CMD_START AND ACTCFGu.STEP1 &lt;&gt; 4 THEN
        ACTCFGu.STEP1 := 2;
        ACTCFGu.T_STEP1 := 0;
        ACTCFGu.CNTPER := ACTCFGu.CNTPER + 1;
    END_IF;
    IF CMD.CMD_STOP AND ACTCFGu.STEP1 &lt;&gt; 5 THEN
        ACTCFGu.STEP1 := 3;
        ACTCFGu.T_STEP1 := 0;
    END_IF;
ELSE
    CSTRT.STA_VALB:=FALSE;
END_IF;

IF CMD.CMD_BLCK THEN    (*при команді блокувати перевести в потрібний стан*)
        ACTCFGu.STEP1 := 6;
        ACTCFGu.T_STEP1 := 0;
END_IF;

IF CMD.CMD_OUTSRVC THEN (*при команді вивести з експлуатації перевести в потрібний стан заблоковано і виставляємо відповідний біт*)
        STA.STA_MAINT := true;
        ACTCFGu.STEP1 := 6;
        ACTCFGu.T_STEP1 := 0;
END_IF;

IF CMD.CMD_INSRVC THEN (*при команді ввести з експлуатації перевести в стан зупинено і зкидаємо відповідний біт*)
        STA.STA_MAINT := false;
        ACTCFGu.STEP1 := 5;
        ACTCFGu.T_STEP1 := 0;
END_IF;


(*-------------------- режими*)

STA.STA_FRC :=LSTP.STA_FRC AND LSTP.ID&lt;&gt;0
OR RUN.STA_FRC AND RUN.ID&lt;&gt;0
OR RDY.STA_FRC AND RDY.ID&lt;&gt;0
OR ALM.STA_FRC AND ALM.ID&lt;&gt;0
OR RMT.STA_FRC AND RMT.ID&lt;&gt;0
OR CSTRT.STA_FRC AND CSTRT.ID&lt;&gt;0
OR SPD.STA_FRC AND SPD.ID&lt;&gt;0
OR CSPD.STA_FRC AND CSPD.ID&lt;&gt;0;

IF STA.STA_MAINT THEN (*якщо виведено з експлуатації тривоги не відслідковуємо*)
	ALMS.ALM_ALMSTRT := FALSE;
	ALMS.ALM_ALMSTP := FALSE;
	ALMS.ALM_ALMINVRTR := FALSE;
	ALMS.ALM_ALMPWR := FALSE;
	ALMS.ALM_ALMSHFT := FALSE;
END_IF;

ALMS.ALM_ALMPWR:=NOT SPWR1;
ALMS.ALM_ALM := ALMS.ALM_ALMSTRT OR ALMS.ALM_ALMSTP OR ALMS.ALM_ALMINVRTR OR ALMS.ALM_ALMPWR OR ALMS.ALM_ALMSHFT;
IF ALMS.ALM_ALM AND NOT STA.STA_MANBX AND ACTCFGu.STEP1&lt;&gt;6 THEN
    ACTCFGu.STEP1 := 6;
    ACTCFGu.T_STEP1 := 0;
END_IF;

(*------------------- зведення ксатомних тривог, режимів, бітів*)
IF ALMs.ALM_ALMSTRT THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1;
    IF NOT ACTCFGu.ALM.ALM_ALMSTRT THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;

IF ALMS.ALM_ALMSTP THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1;
    IF NOT ACTCFGu.ALM.ALM_ALMSTP THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMSHFT THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1;
    IF NOT ACTCFGu.ALM.ALM_ALMSHFT THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMINVRTR THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1; 
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1;
    IF NOT ACTCFGu.ALM.ALM_ALMINVRTR THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;
IF ALMS.ALM_ALMPWR THEN
    PLCCFG.ALM_ALM := TRUE;
    ACTCFGu.CNTALM := ACTCFGu.CNTALM + 1;
    PLCCFG.CNTALM:= PLCCFG.CNTALM + 1;
    IF NOT ACTCFGu.ALM.ALM_ALMPWR THEN
        PLCCFG.ALM_NWALM := TRUE;
    END_IF;
END_IF;


IF ACTCFGu.STA.STA_WRKED THEN
    ACTCFGu.TQ_LAST:=ACTCFGu.T_STEP1/60000;
END_IF;

IF ACTCFGu.TQ_LAST&gt;=16#7FFFFFFF THEN
    ACTCFGu.TQ_LAST:=16#7FFFFFFF;
END_IF;

IF ACTCFGu.STA.STA_WRKED THEN
    IF PLCCFG.PLS_P60S THEN
        ACTCFGu.TQ_TOTAL:=ACTCFGu.TQ_TOTAL+1;
    END_IF;
END_IF;

IF ACTCFGu.TQ_TOTAL&gt;=16#7FFFFFFF THEN
    ACTCFGu.TQ_TOTAL:=16#7FFFFFFF;
END_IF;

ACTCFGu.POS := SPOS1;

(*заключна обробка: зведення в PLC.CFG, STA, ALM, CMD, INBUF, SML, dt *)
ACT_POST (ACTCFG := ACTCFGu, STA := STA, ALMs := ALMS, CMD := CMD, dt1 := dt1, ACTBUF := ACTBUF, PLCCFG := PLCCFG);

ACT_to_DRV(DRVCFG:=ACTCFG, DRVHMI:=ACTHMI, ACTCFG:=ACTCFGu); 

(*------------------- вибір джерела завдання*)
IF ACTCFGu.STA.STA_INBUF AND ACTCFGu.STA.STA_DISP THEN
    ACTCFGu.CPOS := ACTBUF.CPOS;
    ACTHMI.CSPD := ACTCFGu.CPOS;
    ACTCFG.CSPD := ACTCFGu.CPOS;
ELSIF NOT ACTCFGu.STA.STA_INBUF AND ACTCFGu.STA.STA_DISP THEN
    ACTCFGu.CPOS := ACTHMI.CSPD;
    ACTHMI.CSPD := ACTCFGu.CPOS;
    ACTCFG.CSPD := ACTCFGu.CPOS;
ELSE
    ACTCFGu.CPOS := ACTCFG.CSPD;
    ACTHMI.CSPD := ACTCFGu.CPOS;
    ACTCFG.CSPD := ACTCFGu.CPOS;
END_IF;
CSPD.VAL:=ACTCFGu.CPOS;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані   *)
   ACTBUFOUT.MSG := 201;

   ACTBUFOUT.T_DEASP := ACTCFG.T_DEASP;

   ACTBUFIN.CMDHMI :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(ACTCFG.CLSID) AND 16#FFF0)=(uint_to_word(ACTBUFIN.CLSID) AND 16#FFF0) AND ACTCFG.ID=ACTBUFIN.ID AND ACTBUFIN.CMDHMI = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані *)
   
   ACTBUFOUT:=ACTBUFIN;

   ACTCFG.T_DEASP := ACTBUFIN.T_DEASP;

   ACTBUFOUT.MSG := 201;

   ACTBUFIN.CMDHMI :=0; 
end_if;  
</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="DRV_to_ACT" version="0.05" dateTime="dt#2022-07-16-10:19:13">
		<comment>PFW приведення DRV до ACT</comment>
		<attribute name="TypeCodeCheckSumString" value="89EC"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="0EDF"></attribute>
		<inOutParameters>
			<variables name="DRVCFG" typeName="DRV_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="DRVHMI" typeName="DRV_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="DRV_to_ACT">
			<STSource>ACTCFG.ID:=      DRVCFG.ID;
ACTCFG.CLSID:=   DRVCFG.CLSID;
ACTCFG.CMD:=     DRVCFG.CMD;
ACTCFG.PRM:=     DRVCFG.PRM;
ACTCFG.T_DEASP:= DRVCFG.T_DEASP;
ACTCFG.POS:=  DRVCFG.SPD;
ACTCFG.CPOS:=  DRVCFG.CSPD;
ACTCFG.STEP1:=   DRVCFG.STEP1;
ACTCFG.CNTPER:=  DRVCFG.CNTPER;
ACTCFG.CNTALM:=  DRVCFG.CNTALM;
ACTCFG.T_STEP1:= DRVCFG.T_STEP1;
ACTCFG.T_PREV:=  DRVCFG.T_PREV;
ACTCFG.TQ_TOTAL:=DRVCFG.TQ_TOTAL;
ACTCFG.TQ_LAST:= DRVCFG.TQ_LAST;


ACTCFG.STA.STA_MAINT :=   DRVCFG.STA_MAINT;
ACTCFG.STA.STA_STOPING:=  DRVCFG.STA_STOPING;
ACTCFG.STA.STA_STRTING:=  DRVCFG.STA_STRTING;
ACTCFG.STA.STA_STOPED:=   DRVCFG.STA_STOPED;
ACTCFG.STA.STA_ISANALOG:= DRVCFG.STA_ISANALOG;
ACTCFG.STA.STA_ISREVERS:= DRVCFG.STA_ISREVERS;
ACTCFG.STA.STA_WRKED:=    DRVCFG.STA_WRKED;
ACTCFG.STA.STA_DISP:=     DRVCFG.STA_DISP;
ACTCFG.STA.STA_MANBX:=    DRVCFG.STA_MANBX;
ACTCFG.STA.STA_INIOTBUF:= DRVCFG.STA_INIOTBUF;
ACTCFG.STA.STA_INBUF:=    DRVCFG.STA_INBUF;
ACTCFG.STA.STA_FRC:=      DRVCFG.STA_FRC;
ACTCFG.STA.STA_SML:=      DRVCFG.STA_SML;
ACTCFG.STA.STA_BLCK:=     DRVCFG.STA_BLCK;

ACTCFG.ALM.ALM_ALMSTRT:=  DRVCFG.ALM_ALMSTRT;
ACTCFG.ALM.ALM_ALMSTP :=  DRVCFG.ALM_ALMSTP;
ACTCFG.ALM.ALM_ALMSHFT:=  DRVCFG.ALM_ALMSHFT;
ACTCFG.ALM.ALM_ALMBELL:=  DRVCFG.ALM_ALMINVRTR;
ACTCFG.ALM.ALM_ALMPWR :=  DRVCFG.ALM_ALMPWR;
ACTCFG.ALM.ALM_ALM    :=  DRVCFG.ALM_ALM;
ACTCFG.ALM.ALM_WRN    :=  DRVCFG.ALM_WRN;
ACTCFG.ALM.ALM_ALMBELL:=  DRVCFG.ALM_ALMBELL;

ACTCFG.CMDHMI:=DRVHMI.CMD;


</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="ACT_to_DRV" version="0.09" dateTime="dt#2022-07-16-19:36:14">
		<comment>PFW приведення ACT до DRV</comment>
		<attribute name="TypeCodeCheckSumString" value="13DC"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="0EDF"></attribute>
		<inOutParameters>
			<variables name="DRVCFG" typeName="DRV_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="DRVHMI" typeName="DRV_HMI">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="ACTCFG" typeName="ACTTR_CFG">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
		</inOutParameters>
		<FBProgram name="ACT_to_DRV">
			<STSource>(*  PACFramework SEControlExpertLIB V1.0.0 *)
DRVCFG.ID:= ACTCFG.ID;
DRVCFG.CLSID:= ACTCFG.CLSID;
DRVCFG.CMD:= ACTCFG.CMD;
DRVCFG.PRM:= ACTCFG.PRM;
DRVCFG.T_DEASP:= ACTCFG.T_DEASP;
DRVCFG.SPD:= ACTCFG.POS;
DRVCFG.CSPD:= ACTCFG.CPOS;
DRVCFG.STEP1:= ACTCFG.STEP1;
DRVCFG.CNTPER:= ACTCFG.CNTPER;
DRVCFG.CNTALM:= ACTCFG.CNTALM;
DRVCFG.T_STEP1:= ACTCFG.T_STEP1;
DRVCFG.T_PREV:= ACTCFG.T_PREV;
DRVCFG.TQ_TOTAL:= ACTCFG.TQ_TOTAL;
DRVCFG.TQ_LAST:= ACTCFG.TQ_LAST;

DRVCFG.STA_b0 :=  false;
DRVCFG.STA_b1 :=  false;
DRVCFG.STA_MAINT :=  ACTCFG.STA.STA_MAINT;
DRVCFG.STA_STOPING := ACTCFG.STA.STA_STOPING;
DRVCFG.STA_STRTING := ACTCFG.STA.STA_STRTING;
DRVCFG.STA_STOPED:=   ACTCFG.STA.STA_STOPED;
DRVCFG.STA_ISANALOG:= ACTCFG.STA.STA_ISANALOG;
DRVCFG.STA_ISREVERS :=  ACTCFG.STA.STA_ISREVERS;
DRVCFG.STA_WRKED:=    ACTCFG.STA.STA_WRKED;
DRVCFG.STA_DISP:=     ACTCFG.STA.STA_DISP;
DRVCFG.STA_MANBX:=    ACTCFG.STA.STA_MANBX;
DRVCFG.STA_INIOTBUF:= ACTCFG.STA.STA_INIOTBUF;
DRVCFG.STA_INBUF:=    ACTCFG.STA.STA_INBUF;
DRVCFG.STA_FRC:=      ACTCFG.STA.STA_FRC;
DRVCFG.STA_SML:=      ACTCFG.STA.STA_SML;
DRVCFG.STA_BLCK:=     ACTCFG.STA.STA_BLCK;

DRVCFG.ALM_ALMSTRT   := ACTCFG.ALM.ALM_ALMSTRT;
DRVCFG.ALM_ALMSTP    := ACTCFG.ALM.ALM_ALMSTP ;
DRVCFG.ALM_ALMSHFT   := ACTCFG.ALM.ALM_ALMSHFT ;
DRVCFG.ALM_ALMINVRTR := ACTCFG.ALM.ALM_ALMBELL;
DRVCFG.ALM_ALMPWR    := ACTCFG.ALM.ALM_ALMPWR;
DRVCFG.ALM_ALM       := ACTCFG.ALM.ALM_ALM;
DRVCFG.ALM_WRN       := ACTCFG.ALM.ALM_WRN;
DRVCFG.ALM_ALMBELL   := ACTCFG.ALM.ALM_ALMBELL;

DRVHMI.CMD:=ACTCFG.CMDHMI;

DRVHMI.STA.0  :=DRVCFG.STA_b0;
DRVHMI.STA.1  :=DRVCFG.STA_b1;
DRVHMI.STA.2  :=DRVCFG.STA_MAINT;
DRVHMI.STA.3  :=DRVCFG.STA_STOPING;
DRVHMI.STA.4  :=DRVCFG.STA_STRTING;
DRVHMI.STA.5  :=DRVCFG.STA_STOPED;
DRVHMI.STA.6  :=DRVCFG.STA_ISANALOG;
DRVHMI.STA.7  :=DRVCFG.STA_ISREVERS;
DRVHMI.STA.8  :=DRVCFG.STA_WRKED;
DRVHMI.STA.9  :=DRVCFG.STA_DISP;
DRVHMI.STA.10 :=DRVCFG.STA_MANBX;
DRVHMI.STA.11 :=DRVCFG.STA_INIOTBUF;
DRVHMI.STA.12 :=DRVCFG.STA_INBUF;
DRVHMI.STA.13 :=DRVCFG.STA_FRC;
DRVHMI.STA.14 :=DRVCFG.STA_SML;
DRVHMI.STA.15 :=DRVCFG.STA_BLCK;

DRVHMI.ALM.0  :=DRVCFG.ALM_ALMSTRT;
DRVHMI.ALM.1  :=DRVCFG.ALM_ALMSTP;
DRVHMI.ALM.2  :=DRVCFG.ALM_ALMSHFT;
DRVHMI.ALM.3  :=DRVCFG.ALM_ALMINVRTR;
DRVHMI.ALM.4  :=DRVCFG.ALM_ALMPWR;
DRVHMI.ALM.5  :=DRVCFG.ALM_b5;
DRVHMI.ALM.6  :=DRVCFG.ALM_ALM;
DRVHMI.ALM.7  :=DRVCFG.ALM_WRN;
DRVHMI.ALM.8  :=DRVCFG.ALM_ALMBELL;
DRVHMI.ALM.9  :=DRVCFG.ALM_b9;
DRVHMI.ALM.10 :=DRVCFG.ALM_b10;
DRVHMI.ALM.11 :=DRVCFG.ALM_b11;
DRVHMI.ALM.12 :=DRVCFG.ALM_b12;
DRVHMI.ALM.13 :=DRVCFG.ALM_b13;
DRVHMI.ALM.14 :=DRVCFG.ALM_b14;
DRVHMI.ALM.15 :=DRVCFG.ALM_b15;


DRVHMI.SPD := REAL_TO_INT(DRVCFG.SPD)*100;

</STSource>
		</FBProgram>
	</FBSource>
	<FBSource nameOfFBType="PLCFN" version="0.24" dateTime="dt#2022-08-29-12:04:50">
		<comment>PFW обробка системної інформації</comment>
		<attribute name="TypeCodeCheckSumString" value="A204"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="FA47"></attribute>
		<inOutParameters>
			<variables name="PLC" typeName="PLC_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</inOutParameters>
		<privateLocalVariables>
			<variables name="TMBITS_PREV" typeName="INT"></variables>
			<variables name="TMBITS_CUR" typeName="INT"></variables>
			<variables name="i" typeName="INT"></variables>
			<variables name="NOW" typeName="DT"></variables>
			<variables name="TM200ms" typeName="TON"></variables>
			<variables name="TM500ms" typeName="TON"></variables>
			<variables name="Display_NTPC" typeName="Display_NTPC"></variables>
			<variables name="Calc_NTPC" typeName="Calc_NTPC"></variables>
			<variables name="STATUS" typeName="INT"></variables>
			<variables name="ms_cur" typeName="UDINT"></variables>
			<variables name="ms_prev" typeName="UDINT"></variables>
		</privateLocalVariables>
		<FBProgram name="PLC_FN">
			<STSource>(* PLC_FN PACFramework SEControlExpertLIB V1.0.0 
Останні зміни 26.07.20 by Oleksanr Pupena
*)
IF PLC.STA_CMDACK THEN
    PLC.CMD := 0;
END_IF;
PLC.STA_CMDACK := (PLC.CMD &lt;&gt; 0 AND NOT PLC.STA_CMDACK);
PLC.STA_SCN1 := %S21;
IF PLC.STA_SCN1 THEN (*при першому скані*)
    PLC.ID := 1;             (*Ідентифікатор завжди 1*)
    PLC.CLSID := 16#2100;    (*Клас завжди 16#2100*)
    PLC.TQ := 0;
    TMBITS_CUR := 0;
    TMBITS_PREV := 0;
    PLC.TQMS := 0;
END_IF;

(*16#301 - включити режим деблокування усіх ВМ; 
16#302 - відключити режим деблокування усіх ВМ;  
16#300 - перемкнути режим деблокування усіх ВМ;*)
CASE PLC.CMD OF
    16#300:(*768*)
        PLC.STA_DBLCKALL := NOT PLC.STA_DBLCKALL;
    16#301:(*769*)
        PLC.STA_DBLCKALL := true;
    16#302:(*770*)
        PLC.STA_DBLCKALL := false;
    ELSE  
        ;
END_CASE;

PLC.STA_PERM.0 := PLC.STA_CON2ERR;
PLC.STA_PERM.1 := PLC.STA_PLC2STOP;
PLC.STA_PERM.2 := PLC.STA_BLK;
PLC.STA_PERM.3 := PLC.STA_ALDIS;
PLC.STA_PERM.4 := PLC.STA_DIOON;
PLC.STA_PERM.5 := PLC.STA_DIOERR;
PLC.STA_PERM.6 := PLC.STA_DBLCKALL;
PLC.STA_PERM.7 := PLC.STA_FRC0 OR PLC.STA_FRC1 OR PLC.STA_FRC2;
PLC.STA_PERM.8 := PLC.STA_SMLALL;
PLC.STA_PERM.9 := PLC.STA_DISP;
PLC.STA_PERM.10 := PLC.STA_FRC2;
PLC.STA_PERM.11 := PLC.STA_FRC1;
PLC.STA_PERM.12 := PLC.STA_SCN1;
PLC.STA_PERM.13 := PLC.STA_FRC0;
PLC.STA_PERM.14 := PLC.STA_SML;
PLC.STA_PERM.15 := PLC.STA_CMDACK;

PLC.ALM1_PERM.0 := PLC.ALM_ALM;
PLC.ALM1_PERM.1 := PLC.ALM_NWALM;
PLC.ALM1_PERM.2 := PLC.ALM_ALMNACK;
PLC.ALM1_PERM.3 := PLC.ALM_WRN;
PLC.ALM1_PERM.4 := PLC.ALM_NWWRN;
PLC.ALM1_PERM.5 := PLC.ALM_WRNNACK;
PLC.ALM1_PERM.6 := PLC.ALM_BAD;
PLC.ALM1_PERM.7 := PLC.ALM_NWBAD;
PLC.ALM1_PERM.8 := PLC.ALM_BADNACK;
PLC.ALM1_PERM.9 := PLC.ALM_EMCYSTP;
PLC.ALM1_PERM.10 := PLC.ALM_STP2RUN;
PLC.ALM1_PERM.11 := PLC.ALM_CON2ERR;
PLC.ALM1_PERM.12 := PLC.ALM_PLC2STOP;
PLC.ALM1_PERM.13 := PLC.ALM_DIOERR;
PLC.ALM1_PERM.14 := PLC.ALM_PLCERR;
PLC.ALM1_PERM.15 := PLC.ALM_CONHIERR;


(*--------------------------------- таймерні біти та лічильники*)
TM200ms (); TM500ms ();
(*плинні значення*)
TMBITS_CUR.0:=%S5; 
TMBITS_CUR.1:=TM200ms.q;
TMBITS_CUR.2:=TM500ms.q;
TMBITS_CUR.3:=%S6;(*sec*)
TMBITS_CUR.7:=%S7;(*min*)

(*відловлювання імпульсів необхідних часових періодів*)
PLC.PLS_P100MS := TMBITS_CUR.0 AND NOT TMBITS_PREV.0; (*100 мс *)
PLC.PLS_P200MS := TMBITS_CUR.1 AND NOT TMBITS_PREV.1; (*200 мс*)
PLC.PLS_P500MS := TMBITS_CUR.2 AND NOT TMBITS_PREV.2; (*500 мс*)
PLC.PLS_P1S := TMBITS_CUR.3 AND NOT TMBITS_PREV.3; (*1 с*)
PLC.PLS_P60S := TMBITS_CUR.7 AND NOT TMBITS_PREV.7; (*1 хв*)
(*підрахунок кількості секунд і хвилин*)
IF PLC.PLS_P1S THEN PLC.TQ := PLC.TQ + 1; END_IF;  (*загальний час з початку 1-го циклу контролера (в секундах)*)
IF PLC.TQ &gt; 16#7FFF_FFFF THEN PLC.TQ := 16#7FFF_FFFF; END_IF;
IF PLC.PLS_P60S AND NOT PLC.STA_SCN1 THEN PLC.TQM := PLC.TQM + 1; END_IF; (*загальний час роботи ПЛК з моменту пуску (в хвилинах)*)
IF PLC.TQM &gt; 16#7FFF_FFFF THEN PLC.TQM := 16#7FFF_FFFF; END_IF;

(*розрахунок інших часових періодів*)
PLC.PLS_P2S := (PLC.TQ MOD 2) = 0 AND PLC.PLS_P1S;(*2 с*)
PLC.PLS_P5S := (PLC.TQ MOD 5) = 0 AND PLC.PLS_P1S;(*5 с*)
PLC.PLS_P10S := (PLC.TQ MOD 10) = 0 AND PLC.PLS_P1S;(*10 с*)

(* меандри *)
PLC.PLS_M1S:=%S6;(*меандр з періодом 2 с (1 с + 1 с) *)
if PLC.PLS_P1S then PLC.PLS_M2S:=not PLC.PLS_M2S; end_if;(*меандр з періодом 2 с (1 с + 1 с) *)

(* астрономічний час *)
RRTC_DT (OUT =&gt; NOW); (*в DT форматі*)
PLC.NOW := DT_TO_ARINT(NOW); (*у вигляді масиву*)

(* початок години *)
PLC.PLS_NEWHR:= (PLC.NOW[1] AND 16#00FF)=0 (*хвилини*) AND PLC.PLS_P60S (*один раз за хвилину*);

(* початок доби*)
PLC.PLS_NEWDAY:= PLC.NOW[1]=0 (*години_хвилини*) AND PLC.PLS_P60S (*один раз за хвилину*);

(*початок зміни*)
IF PLC.SHIFTPARA[0]&lt;1 OR PLC.SHIFTPARA[0]&gt;3 then PLC.SHIFTPARA[0]:=2;END_IF;(*коректність кількості змін*)
PLC.PLS_NEWSHIFT:=FALSE; (*скидуємо біт початку зміни*)   
FOR i:=1 to PLC.SHIFTPARA[0] DO
  (*хоча б одна з устоавок змін спрацювала*)
   PLC.PLS_NEWSHIFT := PLC.PLS_NEWSHIFT OR (PLC.SHIFTPARA[i]=PLC.NOW[1] (*години хвилин*) AND PLC.PLS_P60S (*один раз за хвилину*));  
END_FOR;

(*таймери для тих уставок, на які немає системних меандрів
два рази викликаються для точності
*)
TM200ms (not TMBITS_CUR.1, t#200ms);
TM500ms (not TMBITS_CUR.2, t#500ms);

TMBITS_PREV := TMBITS_CUR;(*збереження попередніх значень*)

(*----------- визначеня зміни*)
IF PLC.SHIFTPARA[0] &gt; 3 OR PLC.SHIFTPARA[0] &lt; 2 THEN
    PLC.SHIFTPARA[0] := 3;
END_IF;(*якщо кількість змін &gt;3 або &lt;1 - робимо 3*)
IF PLC.NOW[1] &gt;= PLC.SHIFTPARA[1] AND (PLC.NOW[1] &lt; PLC.SHIFTPARA[2] OR PLC.SHIFTPARA[2] = 16#0000) THEN (*1-ша зміна*)
    PLC.SHIFTNMB := 1;
ELSE (*2-га або 3-тя*)
    IF PLC.SHIFTPARA[0] = 2 THEN (*якщо в 2 зміни*)
        PLC.SHIFTNMB := 2;
    ELSE (*якщо 3 зміни*)
        IF PLC.NOW[1] &gt;= PLC.SHIFTPARA[2] AND (PLC.NOW[1] &lt; PLC.SHIFTPARA[3] OR PLC.SHIFTPARA[3] = 16#0000) THEN
            PLC.SHIFTNMB := 2;
        ELSE
            PLC.SHIFTNMB := 3;
        END_IF;
    END_IF;
END_IF;
(*----------- *)

RRTC_DT_MS (OUT1 =&gt; Display_NTPC,
            OUT2 =&gt; Calc_NTPC,
            STATUS =&gt; STATUS);
ms_cur:=Calc_NTPC.Seconds*1000+int_to_udint(Calc_NTPC.fraction_Second);
PLC.NOWns := int_to_udint(Display_NTPC.Millisecond)*1000;
(*цикли*)
PLC.TSK_LTIME :=int_to_uint(%sw30);
PLC.TSK_MAXTIME :=int_to_uint(%sw31);
(* лічильник винесено в періодичну задачу 
PLC.TQMS := PLC.TQMS + UINT_TO_UDINT(PLC.TSK_LTIME);(*//лічильник в мс*)

ms_prev:=ms_cur;

(*скидання статусів і тривог*)
PLC.STA_BLK := false;
PLC.STA_ALDIS := false;
PLC.STA_FRC := false;
PLC.STA_SMLALL := false;
PLC.STA_DISP := false;
PLC.STA_FRC2 := false;
PLC.STA_FRC1 := false;
PLC.STA_FRC0 := false;
PLC.STA_SML := false;

PLC.ALM_ALM := 0;
PLC.ALM_NWALM := 0;
PLC.ALM_ALMNACK := 0;
PLC.ALM_WRN := 0;
PLC.ALM_NWWRN := 0;
PLC.ALM_WRNNACK := 0;
PLC.ALM_BAD := 0;
PLC.ALM_NWBAD := 0;
PLC.ALM_BADNACK := 0;
PLC.ALM_EMCYSTP := 0;
PLC.ALM_STP2RUN := 0;
PLC.ALM_CON2ERR := 0;
PLC.ALM_PLC2STOP := 0;
PLC.ALM_DIOERR := 0;
PLC.ALM_PLCERR := 0;
PLC.ALM_CONHIERR := 0;

(*запамятовування лічильників*)
PLC.CNTALM_PERM := PLC.CNTALM;
PLC.CNTWRN_PERM := PLC.CNTWRN;
PLC.CNTBAD_PERM := PLC.CNTBAD;
PLC.CNTFRC_PERM := PLC.CNTFRC;
PLC.CNTMAN_PERM := PLC.CNTMAN;

(*скидання лічильників*)
PLC.CNTALM := 0;
PLC.CNTWRN := 0;
PLC.CNTBAD := 0;
PLC.CNTFRC := 0;
PLC.CNTMAN := 0;
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_dochs" type="SR" task="MAST"></identProgram>
		<STSource>FOR i := 1 TO PLC.DOCNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHDO[i].ID := INT_TO_UINT(i);
        IF CHDO[i].CLSID = 0 THEN CHDO[i].CLSID := 16#0020;END_IF;
    END_IF;
END_FOR;
(*для кожного каналу виклик ФБ з вказівкою змінної каналу*)
CHDOFN (CHCFG := CHDO[1],  CHHMI := CHDO_HMI[1],  PLCCFG := PLC, CHBUF := CH_BUF, RAW =&gt; %M1(*%Q0.1.16*));
</STSource>
	</program>
	<DDTSource DDTName="CH_BUF" version="0.01" dateTime="dt#2022-01-04-12:22:37">
		<comment>PFW буфер для каналів</comment>
		<attribute name="TypeSignatureCheckSumString" value="FD87"></attribute>
		<structure>
			<variables name="ID" typeName="UINT">
				<comment>Унікальний ідентифікатор</comment>
			</variables>
			<variables name="CLSID" typeName="UINT">
				<comment>ідентифікатор класу</comment>
			</variables>
			<variables name="STA" typeName="INT">
				<comment>біти статусу</comment>
			</variables>
			<variables name="CMD" typeName="INT">
				<comment>командне слово</comment>
			</variables>
			<variables name="VAL" typeName="INT">
				<comment>значення змінної</comment>
			</variables>
			<variables name="VARID" typeName="UINT">
				<comment>ID привязаної змінної</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="CHDOFN" version="0.06" dateTime="dt#2022-07-26-10:44:23">
		<comment>PFW обробка каналу DO</comment>
		<attribute name="TypeCodeCheckSumString" value="3E55"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="B92F"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="CHHMI" typeName="CH_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CHBUF" typeName="CH_BUF">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="RAW" typeName="BOOL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="CMD" typeName="INT"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="ULNK" typeName="BOOL"></variables>
			<variables name="MERR" typeName="BOOL"></variables>
			<variables name="BRK" typeName="BOOL"></variables>
			<variables name="SHRT" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="PNG" typeName="BOOL"></variables>
			<variables name="NBD" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
		</privateLocalVariables>
		<FBProgram name="CHDOFN">
			<STSource>
CMD := CHCFG.CMD;
(*розпаковка з STA*)
VRAW := CHCFG.STA_VRAW;
VAL := CHCFG.STA_VALB;
BAD := CHCFG.STA_BAD;(*керується ззовні*)
PNG := CHCFG.STA_PNG;
ULNK := CHCFG.STA_ULNK;
MERR := CHCFG.STA_MERR;(*керується ззовні*)
BRK := CHCFG.STA_BRK;(*керується ззовні*)
SHRT := CHCFG.STA_SHRT;(*керується ззовні*)
NBD := CHCFG.STA_NBD;(*керується ззовні*)
INBUF := CHCFG.STA_INBUF;
FRC := CHCFG.STA_FRC;
SML := CHCFG.STA_SML;
CMDLOAD := CHCFG.STA_CMDLOAD; (*керується бітом*)

INBUF := (CHCFG.ID = CHBUF.ID) AND (CHCFG.CLSID = CHBUF.CLSID);
CMDLOAD := CHHMI.STA.15;
CMD := 0;


(* обробник команд*)
(* широкомовне форсування/дефорсування*) 
IF PLCCFG.CMD=16#4301 THEN
    FRC := true; (*форсувати один/усі об'єкти типу*)
END_IF;
IF PLCCFG.CMD=16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;
(*вибір джерела команди згідно пріоритету*)
IF CMDLOAD THEN (*з HMI CMDLOAD*)
    CMD := 16#0100;  (*// записати в буфер*)
ELSIF INBUF AND CHBUF.CMD &lt;&gt; 0 THEN (*з буферу*)
    CMD := CHBUF.CMD;
ELSIF CHCFG.CMD&lt;&gt;0 THEN
    CMD := CHCFG.CMD;
END_IF;
(*commands*)
CASE CMD OF
    16#1: (*записати 1*)
        IF FRC AND INBUF THEN
            CHBUF.VAL := 1;
        END_IF;
    16#2: (*записати 0*)
        IF FRC AND INBUF THEN
            CHBUF.VAL:=0;
        END_IF;
    16#3: (*TOGGLE*)
        IF FRC AND INBUF THEN
            IF VRAW THEN
                CHBUF.VAL:=0;
            ELSE
                CHBUF.VAL:=1;
            END_IF;
        END_IF;
    16#0100: (*прочитати конфігурацію в буфер*)
        CHBUF.ID:= CHCFG.ID;
        CHBUF.CLSID:=CHCFG.CLSID;
        
        CHBUF.STA.0 := CHCFG.STA_VRAW;
        CHBUF.STA.1 := CHCFG.STA_VALB;
        CHBUF.STA.2 := CHCFG.STA_BAD;
        CHBUF.STA.3 := CHCFG.STA_b3;
        CHBUF.STA.4 := CHCFG.STA_PNG;
        CHBUF.STA.5 := CHCFG.STA_ULNK;
        CHBUF.STA.6 := CHCFG.STA_MERR;
        CHBUF.STA.7 := CHCFG.STA_BRK;
        CHBUF.STA.8 := CHCFG.STA_SHRT;
        CHBUF.STA.9 := CHCFG.STA_NBD;
        CHBUF.STA.10 := CHCFG.STA_b10;
        CHBUF.STA.11 := CHCFG.STA_INIOTBUF;
        CHBUF.STA.12 := CHCFG.STA_INBUF;
        CHBUF.STA.13 := CHCFG.STA_FRC;
        CHBUF.STA.14 := CHCFG.STA_SML;
        CHBUF.STA.15 := CHCFG.STA_CMDLOAD;
        
        CHBUF.VAL:=CHCFG.VAL;
        CHBUF.VARID:=CHCFG.VARID;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*форсувати один/усі об'єкти типу*)
        FRC := true;
    16#0302: (*дефорсувати один/усі об'єкти типу*)
        FRC := false;
END_CASE;

(*запис значення змінної*)
IF FRC AND INBUF THEN (*режим форсування з занятим буфером*)
    CHCFG.VAL := BOOL_TO_INT (CHBUF.VAL&gt;0);
    VRAW := INT_TO_REAL(CHCFG.VAL) &gt; 0.5;
ELSIF FRC AND NOT INBUF THEN (*режим форсування без занятого буферу*)
    ;(*без змін*)
ELSIF NOT FRC THEN (*не режим форсування*)
    VRAW := VAL;
    IF VAL THEN
        CHCFG.VAL := 1;
    ELSE
        CHCFG.VAL := 0;
    END_IF;
END_IF;
RAW := VRAW; (*відправляємо на вихід*)

(*ping-pong*)
ULNK := PNG; (*прийшов ping - є звязок з верхнім рівнем*)
PNG := false; (*скидання біту PNG звязку з врехнім рівнем PONG*)
IF NOT ULNK THEN
    CHCFG.VARID := 0;
END_IF;

(*скидання оброблених команд*)
CMDLOAD := 0;
CMD := 0;


(*загальносистемні біти та лічильники*)
IF FRC THEN
    PLCCFG.STA_FRC0 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;

(*упковка в STA*)
CHCFG.STA_VRAW := VRAW;
CHCFG.STA_VALB := VAL;
CHCFG.STA_BAD:=BAD;(*керується ззовні*)
CHCFG.STA_PNG:=PNG;
CHCFG.STA_ULNK:=ULNK;
CHCFG.STA_MERR:=MERR;(*керується ззовні*)
CHCFG.STA_BRK:=BRK;(*керується ззовні*)
CHCFG.STA_SHRT:=SHRT;(*керується ззовні*)
CHCFG.STA_NBD:=NBD;(*керується ззовні*)
CHCFG.STA_INBUF := INBUF;
CHCFG.STA_FRC := FRC;
CHCFG.STA_SML := SML;
CHCFG.STA_CMDLOAD := CMDLOAD; (*керується бітом*)


CHCFG.CMD := CMD;

CHHMI.STA := CHCFG.STA;
CHHMI.VAL := CHCFG.VAL;

(*оновлення буферу*)
IF INBUF THEN
    CHBUF.STA:= CHCFG.STA;
    CHBUF.VARID := CHCFG.VARID;
    CHBUF.CMD := 0;
    IF NOT FRC THEN
        CHBUF.VAL := CHCFG.VAL;
    END_IF;
END_IF;
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_ndochs" type="SR" task="MAST"></identProgram>
		<STSource>
		</STSource>
	</program>
	<program>
		<identProgram name="A_dovars" type="SR" task="MAST"></identProgram>
		<STSource>DOVARFN(CHCFG := CHDO[VARS.T1_VSLD_COPN.CHID], DOVARCFG := VARS.T1_VSLD_COPN, DOVARHMI := DOH.T1_VSLD_COPN, VARBUF := VARBUF, PLCCFG := PLC, CHDO := CHDO); (*приклад*) 

</STSource>
	</program>
	<DDTSource DDTName="VARS" version="0.04" dateTime="dt#2022-07-16-10:24:48">
		<comment>PFW екземпляри VARs </comment>
		<attribute name="TypeSignatureCheckSumString" value="70DC"></attribute>
		<structure>
			<variables name="T1_LT1" typeName="AIVAR_CFG">
				<comment>рівень T1</comment>
			</variables>
			<variables name="T1_VSLD_SOPN" typeName="DIVAR_CFG">
				<comment>клапан набору Т1 відкритий</comment>
			</variables>
			<variables name="T1_VSLD_COPN" typeName="DOVAR_CFG">
				<comment>клапан набору Т1 відкрити/закрити</comment>
			</variables>
			<variables name="T1_VRHEA_CPOS" typeName="AOVAR_CFG">
				<comment>клапан нагрівання T1</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="DOVARFN" version="0.17" dateTime="dt#2022-07-26-10:44:23">
		<comment>PFW обробка DO</comment>
		<attribute name="TypeCodeCheckSumString" value="351E"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="F214"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="DOVARCFG" typeName="DOVAR_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="DOVARHMI" typeName="DOVAR_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="VARBUF" typeName="VARBUF">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="CHDO" typeName="ARRAY[0..32] OF CH_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="IDMIN" typeName="UINT"></variables>
			<variables name="IDMAX" typeName="UINT"></variables>
			<variables name="VARBUFIN" typeName="VARBUF"></variables>
			<variables name="VARBUFOUT" typeName="VARBUF"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="DLNK" typeName="BOOL"></variables>
			<variables name="ENBL" typeName="BOOL"></variables>
			<variables name="VALPRV" typeName="BOOL"></variables>
			<variables name="MVAL" typeName="BOOL"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="PRM_INVERSE" typeName="BOOL"></variables>
			<variables name="PRM_QALENBL" typeName="BOOL"></variables>
			<variables name="PRM_DSBL" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="CMD" typeName="UINT"></variables>
			<variables name="VARENBL" typeName="BOOL"></variables>
			<variables name="T_STEPMS" typeName="UDINT"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="PRM_STATICMAP" typeName="BOOL"></variables>
		</privateLocalVariables>
		<FBProgram name="DOVARFN">
			<STSource>
(*ініціалізація змінної на першому циклі обробки*)
IF PLCCFG.STA_SCN1 THEN
    DOVARCFG.CLSID := 16#1020; (*присвоєння ідентифікатора класу*)
    DOVARCFG.PRM_DSBL := FALSE; (*активація змінної*)
    DOVARCFG.T_PREV := PLCCFG.TQMS; (*збереження часу виклику*)
    IF DOVARCFG.CHID = 0 THEN (*якщо логіний номер каналу на заданий - записати значення по замовчування *)
        DOVARCFG.CHID := DOVARCFG.CHIDDF;
    END_IF;

    (*запис сирого значення з каналу для подальшої обробки*)
    IF CHCFG.ID &gt; 0 THEN
        CHCFG.STA_VALB := DOVARCFG.STA_VALB;
    ELSE
        CHCFG.STA_VALB := 0;
    END_IF;

    DOVARCFG.T_STEP1 := 0; (*онулення часу кроку*)
    DOVARCFG.STEP1 := 400; (*переведення на крок DO=0*)

    (*визначення діапазонів ідентифікаторів змінної*)
    IF DOVARCFG.ID&gt;0 THEN
    	IF DOVARCFG.ID&lt;IDMIN THEN IDMIN:=DOVARCFG.ID; END_IF;
    	IF DOVARCFG.ID&gt;IDMAX THEN IDMAX:=DOVARCFG.ID; END_IF;
    END_IF;

    RETURN;
END_IF;

(*зчитування статусних бітів з технологічної змінної у внутрішні змінні*)
VRAW := DOVARCFG.STA_VRAW;
VAL := DOVARCFG.STA_VALB;
BAD := DOVARCFG.STA_BAD;
DLNK := DOVARCFG.STA_DLNK;
ENBL := DOVARCFG.STA_ENBL;
VALPRV := DOVARCFG.STA_VALPRV;
MVAL := DOVARCFG.STA_MVAL;
INBUF := DOVARCFG.STA_INBUF;
FRC := DOVARCFG.STA_FRC;
SML := DOVARCFG.STA_SML;
CMDLOAD := DOVARCFG.STA_CMDLOAD;

(*зчитування параметричних бітів з технологічної змінної у внутрішні змінні*)
PRM_INVERSE := DOVARCFG.PRM_INVERSE;
PRM_QALENBL := DOVARCFG.PRM_QALENBL;
PRM_DSBL := DOVARCFG.PRM_DSBL;
PRM_STATICMAP := DOVARCFG.PRM_STATICMAP;

INBUF := (DOVARCFG.ID = VARBUF.ID) AND (DOVARCFG.CLSID = VARBUF.CLSID); (*змінна в буфері якщо співпадає ідентифікатор змінної та ідентифікатор класу*)
CMDLOAD := DOVARHMI.STA.15; (*команда запису в буфер з НМІ змінної*)
CMD := 0; (*онулення внутрішньої команда*)
DLNK := (CHCFG.ID &gt; 0); (*змінна привязана до каналу якщо канал має реальний ідентифікатор (не 0 - не молоко)*)
VARENBL := NOT PRM_DSBL AND DLNK; (*змінна задіяна якщо привязана до каналу і не активний параметр змінна не задіяна*)
VRAW := CHCFG.STA_VALB; (*зчитування сирого значення з каналу*)
T_STEPMS := DOVARCFG.T_STEP1; (*запамятовування часу циклу в мс*)

(*реалізація алгоритму ping-pong*)
IF DLNK THEN
    CHCFG.STA_PNG := true;
    CHCFG.VARID := DOVARCFG.ID;
END_IF;

(*якщо змінна не задіяна не рахуємо час, скидаємо стан*)
IF NOT VARENBL THEN
    DOVARCFG.T_STEP1 := 0;
    DOVARCFG.STEP1 := 400;
END_IF;

(*визначення часу між викликами функції по різниці між мілісікундним лічильником та часом який пройшов з попереднього виклику *)
dT1 := PLCCFG.TQMS - DOVARCFG.T_PREV;

(* широкомовне дефорсування*) 
IF PLCCFG.CMD = 16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;

(*вибір джерела конфігураційної/керівної команди згідно пріоритету якщо команди надійшли одночасно*)
IF CMDLOAD THEN (*команда запису в буфер - команда з НМІ*)
    CMD := 16#0100;
ELSIF INBUF AND VARBUF.CMD &lt;&gt; 0 THEN (*команда з буферу*)
    CMD := VARBUF.CMD;
END_IF;

(*commands*)
CASE CMD OF
    16#0001: (*записати 1*)
        IF FRC AND INBUF THEN
            DOVARCFG.VALI := 1;
            VARBUF.VALR:=1.0;
            VAL := true;
            DOVARCFG.STEP1 := 401;
            DOVARCFG.T_STEP1 := 0;
        END_IF;
    16#0002: (*записати 0*)
        IF FRC AND INBUF THEN
            DOVARCFG.VALI := 0;
            VARBUF.VALR:=0.0;
            VAL := false;
            DOVARCFG.STEP1 := 400;
            DOVARCFG.T_STEP1 := 0;
        END_IF;
    16#0003: (*TOGGLE*)
        IF FRC AND INBUF THEN
            IF DOVARCFG.VALI &gt; 0 THEN
                DOVARCFG.VALI := 0;
                VARBUF.VALR:=0.0;
                VAL := false;
                DOVARCFG.STEP1 := 400;
                DOVARCFG.T_STEP1 := 0;
            ELSE
                DOVARCFG.VALI := 1;
                VARBUF.VALR:=1.0;
                VAL := true;
                DOVARCFG.STEP1 := 401;
                DOVARCFG.T_STEP1 := 0;
            END_IF;
        END_IF;
    16#0100: (*прочитати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів *)
        VARBUF.MSG:=201; 

        (*зчитати ідентифікатор змінної та ідентифікатор класу*)
	VARBUF.ID := DOVARCFG.ID;
        VARBUF.CLSID := DOVARCFG.CLSID;

        (*зчитати бітові параметри*)
        VARBUF.PRM.2 := PRM_INVERSE;
        VARBUF.PRM.6 := PRM_QALENBL;
        VARBUF.PRM.7 := PRM_DSBL;
        VARBUF.PRM.14 := PRM_STATICMAP;
        
        (*зчитати параметри*)
        VARBUF.CHID := DOVARCFG.CHID;

        (*зчитати значення змінної для безударного форсування*)
        VARBUF.VALR := INT_TO_REAL(DOVARCFG.VALI);
        
    16#0101: (*записати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   *)
	VARBUF.MSG:=200; 

        (*записати бітові параметри*)
        PRM_INVERSE := VARBUF.PRM.2;
        PRM_QALENBL := VARBUF.PRM.6;
        PRM_DSBL := VARBUF.PRM.7;
	PRM_STATICMAP := VARBUF.PRM.14;
        
        (*алгоритм для зміни номера логічного каналу при перевірці його на коректність*)
	IF NOT PRM_STATICMAP THEN (* зміна логічного номеру каналу тільки при неактивна статичн адресація*)
           IF VARBUF.CHID&gt;=0 AND VARBUF.CHID &lt;= INT_TO_UINT(PLCCFG.DOCNT) THEN (* якщо логічний номер канал менший за кількість каналів*)
              IF CHDO[VARBUF.CHID].VARID = 0 THEN  (* якщо логічний номер канал нульовий - вільний *)
                 DOVARCFG.CHID := VARBUF.CHID; (* змінити логічний номер каналу *)
              ELSIF VARBUF.CHID &lt;&gt; DOVARCFG.CHID THEN (* інакше вивести помилку про зайнятість каналу *)
                 VARBUF.MSG := 403;(* канал вже зайнятий*)
              END_IF;
           ELSE 
              VARBUF.MSG := 404; (*номер каналу не відповідає діапазону*)
           END_IF;
	ELSIF VARBUF.CHID &lt;&gt; DOVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
           VARBUF.MSG := 405;(* активна статична адресація каналів*)
        END_IF;        
        IF INBUF THEN (*оновити логічний номер каналу після запису якщо змінна ще в буфері*)
           VARBUF.CHID := DOVARCFG.CHID;
        END_IF;
    16#0102: (*записати значення за замовченням*)
        DOVARCFG.CHID := DOVARCFG.CHIDDF;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*ввімкнути форсування*)
        FRC := true;
    16#0302: (*вимкнути форсування*)
        FRC := false;
    16#0311: (* імітувати*)
        SML := true;
    16#0312: (* зняти режим імітації*)
        SML := false;
END_CASE;

(*обробка значень*)
IF FRC THEN (*режим форсування*)
    IF INBUF THEN
        DOVARCFG.VALI := REAL_TO_INT(VARBUF.VALR);
    END_IF;
    VAL := DOVARCFG.VALI &gt; 0;
    IF VAL THEN
        DOVARCFG.STEP1 := 401;
    ELSE
        DOVARCFG.STEP1 := 400;
    END_IF;
ELSE (*обробка нефорсованого значення - нормальна обробка змінної*)
    IF VAL THEN
        DOVARCFG.VALI := 1;
        DOVARCFG.STEP1 := 401;
    ELSE
        DOVARCFG.VALI := 0;
        DOVARCFG.STEP1 := 400;
    END_IF;
END_IF;

(*визначення фронту для оновлення часу стану*)
IF VAL &lt;&gt; VALPRV THEN
    DOVARCFG.T_STEP1 := 0;
END_IF;

(*запис значення на фізичний канал лише при активації змінної*)
IF VARENBL THEN
    IF PRM_INVERSE THEN (*реалізація функції інверсії*)
        VRAW := NOT VAL;
    ELSE
        VRAW := VAL;
    END_IF;
    IF NOT SML THEN (* режим симуляції - вихідне значення не змінюється *)
        CHCFG.STA_VALB := VRAW;
    END_IF;
END_IF;

BAD := CHCFG.STA_BAD AND PRM_QALENBL AND VARENBL AND NOT SML; (*тривога достовірності береться з привязаного фізичного каналу*)

(*передача тривог для змінної PLCCFG для формування загального статусного біта і визначення нової тривоги*)
IF BAD THEN
    PLCCFG.ALM_BAD := true;
    PLCCFG.CNTBAD := PLCCFG.CNTBAD + 1;
    IF NOT DOVARCFG.STA_BAD THEN
        PLCCFG.ALM_NWBAD := true;
    END_IF;
END_IF;

(*передача статусних бітів для змінної PLCCFG для формування загального статусного біта*)
IF FRC THEN
    PLCCFG.STA_FRC1 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;
IF SML THEN
    PLCCFG.STA_SML := true;
END_IF;

(*передача статусних бітів з внутрішніх змінних в технологічну змінну*)
DOVARCFG.STA_VRAW := VRAW;
DOVARCFG.STA_VALB := VAL;
DOVARCFG.STA_BAD := BAD;
DOVARCFG.STA_DLNK := DLNK;
DOVARCFG.STA_ENBL :=  VARENBL;
DOVARCFG.STA_VALPRV:=VAL;
DOVARCFG.STA_MVAL := DOVARCFG.VALI &gt; 0;
DOVARCFG.STA_INBUF := INBUF;
DOVARCFG.STA_FRC := FRC;
DOVARCFG.STA_SML := SML;
DOVARCFG.STA_CMDLOAD := FALSE; (*онулення біта запису в буфер*)

(*передача параметричних бітів з внутрішніх змінних в технологічну змінну*)
DOVARCFG.PRM_INVERSE := PRM_INVERSE;
DOVARCFG.PRM_QALENBL := PRM_QALENBL;
DOVARCFG.PRM_DSBL := PRM_DSBL;
DOVARCFG.PRM_STATICMAP := PRM_STATICMAP;

DOVARHMI.STA := DOVARCFG.STA; (*передача статусних бітів з конфігураційної частини в НМІ*)

DOVARCFG.T_PREV := PLCCFG.TQMS; (*запамятовування часу останнього виклику екземпляра функції*)

(*підрахунок часу стану та обмеження його по верхній межі діапазону*)
DOVARCFG.T_STEP1 := DOVARCFG.T_STEP1 + dT1;
IF DOVARCFG.T_STEP1 &gt; 16#7FFF_FFFF THEN
    DOVARCFG.T_STEP1 := 16#7FFF_FFFF;
END_IF;

(*автоматичне оновлення якщо змінна записана в буфер*)
IF INBUF THEN
    VARBUF.CMD := 0;
    VARBUF.VALR := INT_TO_REAL(DOVARCFG.VALI);
    VARBUF.STA := DOVARCFG.STA;
    VARBUF.STEP1 := DOVARCFG.STEP1;
    VARBUF.T_STEP1 := DOVARCFG.T_STEP1;

(*зчитування статусних бітів фізичного каналу технологічної змінної*)
    VARBUF.CH_CLSID := CHCFG.CLSID;
    VARBUF.CH_STA.0 := CHCFG.STA_VRAW;
    VARBUF.CH_STA.1 := CHCFG.STA_VALB;
    VARBUF.CH_STA.2 := CHCFG.STA_BAD;
    VARBUF.CH_STA.3 := CHCFG.STA_b3;
    VARBUF.CH_STA.4 := CHCFG.STA_PNG;
    VARBUF.CH_STA.5 := CHCFG.STA_ULNK;
    VARBUF.CH_STA.6 := CHCFG.STA_MERR;
    VARBUF.CH_STA.7 := CHCFG.STA_BRK;
    VARBUF.CH_STA.8 := CHCFG.STA_SHRT;
    VARBUF.CH_STA.9 := CHCFG.STA_NBD;
    VARBUF.CH_STA.10 := CHCFG.STA_b10;
    VARBUF.CH_STA.11 := CHCFG.STA_INIOTBUF;
    VARBUF.CH_STA.12 := CHCFG.STA_INBUF;
    VARBUF.CH_STA.13 := CHCFG.STA_FRC;
    VARBUF.CH_STA.14 := CHCFG.STA_SML;
    VARBUF.CH_STA.15 := CHCFG.STA_CMDLOAD;
END_IF;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(DOVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND DOVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   VARBUFOUT.MSG:=201; 

   VARBUFOUT.PRM.2 := DOVARCFG.PRM_INVERSE;
   VARBUFOUT.PRM.6 := DOVARCFG.PRM_QALENBL;
   VARBUFOUT.PRM.7 := DOVARCFG.PRM_DSBL;
   VARBUFOUT.PRM.14 := DOVARCFG.PRM_STATICMAP;
        
   VARBUFOUT.ID := DOVARCFG.ID;
   VARBUFOUT.CLSID := DOVARCFG.CLSID;
   VARBUFOUT.CHID := DOVARCFG.CHID;
   VARBUFOUT.VALR := INT_TO_REAL(DOVARCFG.VALI);

   VARBUFIN.CMD :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(DOVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND DOVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   
   VARBUFOUT:=VARBUFIN;

   DOVARCFG.PRM_INVERSE := VARBUFIN.PRM.2;
   DOVARCFG.PRM_QALENBL := VARBUFIN.PRM.6;
   DOVARCFG.PRM_DSBL := VARBUFIN.PRM.7;
   DOVARCFG.PRM_STATICMAP:=  VARBUFIN.PRM.14;
        
   VARBUFOUT.MSG:=200; 
   IF NOT DOVARCFG.PRM_STATICMAP THEN 
      IF VARBUFIN.CHID&gt;=0 AND VARBUFIN.CHID &lt;= INT_TO_UINT(PLCCFG.DOCNT) THEN
         IF CHDO[VARBUFIN.CHID].VARID = 0 THEN 
            DOVARCFG.CHID := VARBUFIN.CHID;
         ELSIF VARBUFIN.CHID &lt;&gt; DOVARCFG.CHID THEN 
            VARBUFOUT.MSG := 403;(* канал вже зайнятий*)
         END_IF;
      ELSE 
         VARBUFOUT.MSG := 404; (*номер каналу не відповідає діапазону*)
      END_IF;
   ELSIF VARBUFIN.CHID &lt;&gt; DOVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
      VARBUFOUT.MSG := 405;(* активна статична адресація каналів*)
   END_IF; 

   VARBUFIN.CMD :=0; 
end_if;  


</STSource>
		</FBProgram>
	</FBSource>
	<DDTSource DDTName="DOVAR_HMI" version="0.01" dateTime="dt#2022-01-06-17:24:59">
		<comment>PFW структура DOVAR для HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="7BFE"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>статус</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DOH" version="0.02" dateTime="dt#2022-04-26-16:29:55">
		<comment>PFW структура DOVAR</comment>
		<attribute name="TypeSignatureCheckSumString" value="E37A"></attribute>
		<structure>
			<variables name="T1_VSLD_COPN" typeName="DOVAR_HMI">
				<comment>клапан набору Т1 відкрити/закрити</comment>
			</variables>
		</structure>
	</DDTSource>
	<program>
		<identProgram name="A_divars" type="SR" task="MAST"></identProgram>
		<STSource>DIVARFN(CHCFG := CHDI[VARS.T1_VSLD_SOPN.CHID], DIVARCFG := VARS.T1_VSLD_SOPN, DIVARHMI := DIH.T1_VSLD_SOPN, VARBUF := VARBUF, PLCCFG := PLC, CHDI := CHDI); (*приклад*)
</STSource>
	</program>
	<DDTSource DDTName="DIH" version="0.03" dateTime="dt#2022-04-26-16:21:59">
		<comment>PFW екземпляри DIVAR_HMI </comment>
		<attribute name="TypeSignatureCheckSumString" value="7EFB"></attribute>
		<structure>
			<variables name="T1_VSLD_SOPN" typeName="DIVAR_HMI">
				<comment>клапан набору Т1 відкритий</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="DIVAR_HMI" version="0.01" dateTime="dt#2022-01-06-17:23:59">
		<comment>PFW структура DIVAR для HMI </comment>
		<attribute name="TypeSignatureCheckSumString" value="7BFE"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>статус</comment>
			</variables>
		</structure>
	</DDTSource>
	<FBSource nameOfFBType="DIVARFN" version="0.25" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка DI</comment>
		<attribute name="TypeCodeCheckSumString" value="905B"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="D87F"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="DIVARCFG" typeName="DIVAR_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="DIVARHMI" typeName="DIVAR_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="VARBUF" typeName="VARBUF">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="CHDI" typeName="ARRAY[0..32] OF CH_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="IDMIN" typeName="UINT"></variables>
			<variables name="IDMAX" typeName="UINT"></variables>
			<variables name="VARBUFIN" typeName="VARBUF"></variables>
			<variables name="VARBUFOUT" typeName="VARBUF"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="ALDIS" typeName="BOOL"></variables>
			<variables name="DLNK" typeName="BOOL"></variables>
			<variables name="ENBL" typeName="BOOL"></variables>
			<variables name="ALM" typeName="BOOL"></variables>
			<variables name="VALPRV" typeName="BOOL"></variables>
			<variables name="ISALM" typeName="BOOL"></variables>
			<variables name="ISWRN" typeName="BOOL"></variables>
			<variables name="WRN" typeName="BOOL"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="PRM_ISALM" typeName="BOOL"></variables>
			<variables name="PRM_ISWRN" typeName="BOOL"></variables>
			<variables name="PRM_INVERSE" typeName="BOOL"></variables>
			<variables name="PRM_NRMVAL" typeName="BOOL"></variables>
			<variables name="PRM_QALENBL" typeName="BOOL"></variables>
			<variables name="PRM_DSBL" typeName="BOOL"></variables>
			<variables name="VARENBL" typeName="BOOL"></variables>
			<variables name="CMD" typeName="UINT"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="DI" typeName="BOOL"></variables>
			<variables name="T_STEPMS" typeName="UDINT"></variables>
			<variables name="SPDMONON" typeName="BOOL"></variables>
			<variables name="PRM_STATICMAP" typeName="BOOL"></variables>
		</privateLocalVariables>
		<FBProgram name="DIVARFN">
			<STSource>(*DIVARCFG.CLSID 
16#1010 - класичний
16#1011 - з лічильником в полі VALI, не змінюється в цій функції в нормальному режимі*)

(*ініціалізація змінної на першому циклі обробки*)
IF PLCCFG.STA_SCN1 THEN
    DIVARCFG.CLSID := 16#1010; (*присвоєння ідентифікатора класу*)
    DIVARCFG.PRM_DSBL := FALSE;(*активація змінної*)
    DIVARCFG.T_PREV := PLCCFG.TQMS;(*збереження часу виклику*)
    IF DIVARCFG.CHID = 0 THEN (*якщо логіний номер каналу на заданий - записати значення по замовчування *)
        DIVARCFG.CHID := DIVARCFG.CHIDDF;
    END_IF;

    (*запис сирого значення з каналу для подальшої обробки*)
    IF CHCFG.ID &gt; 0 THEN 
        VRAW := CHCFG.STA_VALB;
    ELSE
        VRAW := 0;
    END_IF;
    DIVARCFG.STA_VALPRV := VRAW; 
    DIVARCFG.STA_VRAW := DIVARCFG.STA_VALPRV;
    DIVARCFG.STA_VALB := DIVARCFG.STA_VRAW;
    
    DIVARCFG.T_STEP1 := 0; (*онулення часу кроку*)
    DIVARCFG.STEP1 := 400; (*переведення на крок DI=0*)

    (*визначення діапазонів ідентифікаторів змінної*)
    IF DIVARCFG.ID&gt;0 THEN
    	IF DIVARCFG.ID&lt;IDMIN THEN IDMIN:=DIVARCFG.ID; END_IF;
    	IF DIVARCFG.ID&gt;IDMAX THEN IDMAX:=DIVARCFG.ID; END_IF;
    END_IF;

    RETURN;
END_IF;

(*зчитування статусних бітів з технологічної змінної у внутрішні змінні*)
VRAW := DIVARCFG.STA_VRAW;
VAL := DIVARCFG.STA_VALB;
BAD := DIVARCFG.STA_BAD;
ALDIS := DIVARCFG.STA_ALDIS;
DLNK := DIVARCFG.STA_DLNK;
ENBL := DIVARCFG.STA_ENBL;
ALM := DIVARCFG.STA_ALM;
VALPRV := DIVARCFG.STA_VALPRV;
WRN := DIVARCFG.STA_WRN;
INBUF := DIVARCFG.STA_INBUF;
FRC := DIVARCFG.STA_FRC;
SML := DIVARCFG.STA_SML;
CMDLOAD := DIVARCFG.STA_CMDLOAD;

(*зчитування параметричних бітів з технологічної змінної у внутрішні змінні*)
PRM_ISALM := DIVARCFG.PRM_ISALM;
PRM_ISWRN := DIVARCFG.PRM_ISWRN;
PRM_INVERSE := DIVARCFG.PRM_INVERSE;
PRM_NRMVAL := DIVARCFG.PRM_NRMVAL;
PRM_QALENBL := DIVARCFG.PRM_QALENBL;
PRM_DSBL := DIVARCFG.PRM_DSBL;
PRM_STATICMAP := DIVARCFG.PRM_STATICMAP;

INBUF := (DIVARCFG.ID = VARBUF.ID) AND (DIVARCFG.CLSID = VARBUF.CLSID); (*змінна в буфері якщо співпадає ідентифікатор змінної та ідентифікатор класу*)
CMDLOAD := DIVARHMI.STA.15; (*команда запису в буфер з НМІ змінної*)
CMD := 0; (*онулення внутрішньої команда*)
DLNK := (CHCFG.ID &gt; 0); (*змінна привязана до каналу якщо канал має реальний ідентифікатор (не 0 - не молоко)*)
VARENBL := NOT PRM_DSBL AND DLNK; (*змінна задіяна якщо привязана до каналу і не активний параметр змінна не задіяна*)
VRAW := CHCFG.STA_VALB; (*зчитування сирого значення з каналу*)
T_STEPMS := DIVARCFG.T_STEP1; (*запамятовування часу циклу в мс*)

(*реалізація алгоритму ping-pong*)
IF DLNK THEN
    CHCFG.STA_PNG := true;
    CHCFG.VARID := DIVARCFG.ID;
END_IF;

(*якщо змінна не задіяна не рахуємо час, скидаємо стан і записуємо лише сире значення для змінної*)
IF NOT VARENBL THEN
    DIVARCFG.STA_VRAW := VRAW;
    DIVARCFG.T_STEP1 := 0;
    DIVARCFG.STEP1 := 400;
END_IF;

(*визначення часу між викликами функції по різниці між мілісікундним лічильником та часом який пройшов з попереднього виклику *)
dT1 := PLCCFG.TQMS - DIVARCFG.T_PREV;

(* широкомовне дефорсування*) 
IF PLCCFG.CMD = 16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;

(*вибір джерела конфігураційної/керівної команди згідно пріоритету якщо команди надійшли одночасно*)
IF CMDLOAD THEN (*команда запису в буфер - команда з НМІ*)
    CMD := 16#0100;
ELSIF INBUF AND VARBUF.CMD &lt;&gt; 0 THEN (*команда з буферу*)
    CMD := VARBUF.CMD;
END_IF;

(*commands*)
CASE CMD OF
    16#0001: (*записати 1 - тільки при форсуванні*)
        IF FRC AND INBUF THEN
            DIVARCFG.VALI := 1;
            VAL := true;
            DIVARCFG.STEP1 := 401;
            DIVARCFG.T_STEP1 := 0;
        END_IF;
    16#0002: (*записати 0 - тільки при форсуванні*)
        IF FRC AND INBUF THEN
            DIVARCFG.VALI := 0;
            VAL := false;
            DIVARCFG.STEP1 := 400;
            DIVARCFG.T_STEP1 := 0;
        END_IF;
    16#0003: (*TOGGLE - тільки при форсуванні*)
        IF FRC AND INBUF THEN
            IF DIVARCFG.VALI &gt; 0 THEN
                DIVARCFG.VALI := 0;
                VAL := false;
                DIVARCFG.STEP1 := 400;
                DIVARCFG.T_STEP1 := 0;
            ELSE
                DIVARCFG.VALI := 1;
                VAL := true;
                DIVARCFG.STEP1 := 401;
                DIVARCFG.T_STEP1 := 0;
            END_IF;
        END_IF;
    16#0100: (*прочитати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів *)
        VARBUF.MSG := 201; 
        
	(*зчитати ідентифікатор змінної та ідентифікатор класу*)
	VARBUF.ID := DIVARCFG.ID;
        VARBUF.CLSID := DIVARCFG.CLSID;

	(*зчитати бітові параметри*)
	VARBUF.PRM.0 := PRM_ISALM;
        VARBUF.PRM.1 := PRM_ISWRN;
        VARBUF.PRM.2 := PRM_INVERSE;
        VARBUF.PRM.5 := PRM_NRMVAL;
        VARBUF.PRM.6 := PRM_QALENBL;
        VARBUF.PRM.7 := PRM_DSBL;
	VARBUF.PRM.14 := PRM_STATICMAP;
        
        (*зчитати параметри*)	        
        VARBUF.CHID := DIVARCFG.CHID;
        VARBUF.T_FLTSP := DIVARCFG.T_FLTSP;
        VARBUF.T_DEALL := DIVARCFG.T_DEASP;

        (*зчитати значення змінної для безударного форсування*)
        VARBUF.VALR := INT_TO_REAL(DIVARCFG.VALI);

    16#0101: (*записати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів*)
        VARBUF.MSG:=200;
		
	(*записати бітові параметри*)
        PRM_ISALM := VARBUF.PRM.0;
        PRM_ISWRN := VARBUF.PRM.1;
        PRM_INVERSE := VARBUF.PRM.2;
        PRM_NRMVAL := VARBUF.PRM.5;
        PRM_QALENBL := VARBUF.PRM.6;
        PRM_DSBL := VARBUF.PRM.7;
	PRM_STATICMAP := VARBUF.PRM.14;

        (*записати параметри*)
	DIVARCFG.T_FLTSP := VARBUF.T_FLTSP;
        DIVARCFG.T_DEASP := VARBUF.T_DEALL;

        (*алгоритм для зміни номера логічного каналу при перевірці його на коректність*)
        IF NOT PRM_STATICMAP THEN (* зміна логічного номеру каналу тільки при неактивна статичн адресація*)
	   IF VARBUF.CHID&gt;=0 AND VARBUF.CHID &lt;= INT_TO_UINT(PLCCFG.DICNT) THEN (* якщо логічний номер канал менший за кількість каналів*)
              IF CHDI[VARBUF.CHID].VARID = 0 THEN (* якщо логічний номер канал нульовий - вільний *)
                 DIVARCFG.CHID := VARBUF.CHID; (* змінити логічний номер каналу *)
              ELSIF VARBUF.CHID &lt;&gt; DIVARCFG.CHID THEN (* інакше вивести помилку про зайнятість каналу *)
                 VARBUF.MSG := 403;(* канал вже зайнятий*)
              END_IF;
           ELSE 
              VARBUF.MSG := 404; (*номер каналу не відповідає діапазону*)
           END_IF;
        ELSIF VARBUF.CHID &lt;&gt; DIVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
           VARBUF.MSG := 405;(* активна статична адресація каналів*)
        END_IF;
        IF INBUF THEN (*оновити логічний номер каналу після запису якщо змінна ще в буфері*)
           VARBUF.CHID := DIVARCFG.CHID;
        END_IF;
    16#0102: (*записати значення за замовченням*)
        DIVARCFG.CHID := DIVARCFG.CHIDDF;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*ввімкнути форсування*)
        FRC := true;
    16#0302: (*вимкнути форсування*)
        FRC := false;
    16#0311: (* імітувати*)
        SML := true;
    16#0312: (* зняти режим імітації*)
        SML := false;
END_CASE;

(*обробка значень*)
IF NOT FRC AND NOT SML THEN (*обробка нефорсованого значення - нормальна обробка змінної*)
    IF PRM_INVERSE THEN (*реалізація функції інверсії*)
        DI := NOT VRAW;
    ELSE
        DI := VRAW;
    END_IF;
    (*обробка автомату станів та фільтрації змінної*)
    CASE DIVARCFG.STEP1 OF
        400:(*DI =0*)
            IF DI THEN
                DIVARCFG.STEP1 := 401;
                DIVARCFG.T_STEP1 := 0;
            END_IF;
            IF T_STEPMS &gt;= UINT_TO_UDINT(DIVARCFG.T_FLTSP) THEN
                VAL := FALSE;
            END_IF;
        401:(*DI =1*)
            IF NOT DI THEN
                DIVARCFG.STEP1 := 400;
                DIVARCFG.T_STEP1 := 0;
            END_IF;
            IF T_STEPMS &gt;= UINT_TO_UDINT(DIVARCFG.T_FLTSP) THEN
                VAL := true;
            END_IF;
        ELSE
            DIVARCFG.STEP1 := 400;
            DIVARCFG.T_STEP1 := 0;
    END_CASE;
    (*якщо це не DI з лічильником*)
    IF DIVARCFG.CLSID &lt;&gt; 16#1011 THEN
        DIVARCFG.VALI := BOOL_TO_INT (VAL);
    END_IF;
ELSE (* обробка без фільтрації та інверсії*) 
    IF FRC THEN  (*при форсування значення береться з VALI*)
        (*якщо це не DI з лічильником*)
        IF DIVARCFG.CLSID &lt;&gt; 16#1011 THEN
            VAL := INT_TO_BOOL (DIVARCFG.VALI);
        END_IF;
    ELSIF SML THEN (*в режимі імітації VAL змінюється ззовні а VALI береться з нього*)     
        (*якщо це не DI з лічильником*)
        IF DIVARCFG.CLSID &lt;&gt; 16#1011 THEN
            DIVARCFG.VALI := BOOL_TO_INT (VAL);
        END_IF;
    END_IF;
   (*обробка автомату станів при форсування - фільтрація відсутня*)
    CASE DIVARCFG.STEP1 OF
        400:(*DI =0*)
            IF VAL THEN
                DIVARCFG.STEP1 := 401;
                DIVARCFG.T_STEP1 := 0;
            END_IF;
        401:(*DI =1*)
            IF NOT VAL THEN
                DIVARCFG.STEP1 := 400;
                DIVARCFG.T_STEP1 := 0;
            END_IF;
        ELSE
            DIVARCFG.STEP1 := 400;
            DIVARCFG.T_STEP1 := 0;
    END_CASE;
END_IF;

(*обробка тривог - тривоги активні лише при активації змінної*)
IF VARENBL AND DIVARCFG.T_STEP1 &gt;= UINT_TO_UDINT(DIVARCFG.T_DEASP) * 100 THEN (*затримка тривоги задається в 0.1 с*)
    ALM := NOT (PRM_NRMVAL = VAL) AND PRM_ISALM;
    WRN := NOT (PRM_NRMVAL = VAL) AND PRM_ISWRN;
ELSE
    ALM := false;
    WRN := false;
END_IF;

BAD := CHCFG.STA_BAD AND PRM_QALENBL AND NOT SML; (*тривога достовірності береться з привязаного фізичного каналу*)

(*передача тривог для змінної PLCCFG для формування загального статусного біта і визначення нової тривоги*)
IF BAD THEN
    PLCCFG.ALM_BAD := true;
    PLCCFG.CNTBAD := PLCCFG.CNTBAD + 1;
    IF NOT DIVARCFG.STA_BAD THEN
        PLCCFG.ALM_NWBAD := true;
    END_IF;
END_IF;

IF ALM THEN
    PLCCFG.ALM_ALM := true;
    PLCCFG.CNTALM := PLCCFG.CNTALM + 1;
    IF NOT DIVARCFG.STA_ALM THEN
        PLCCFG.ALM_NWALM := true;
    END_IF;
END_IF;

IF WRN THEN
    PLCCFG.ALM_WRN := true;
    PLCCFG.CNTWRN := PLCCFG.CNTWRN + 1;
    IF NOT DIVARCFG.STA_WRN THEN
        PLCCFG.ALM_NWWRN := true;
    END_IF;
END_IF;

(*передача статусних бітів для змінної PLCCFG для формування загального статусного біта*)
IF FRC THEN
    PLCCFG.STA_FRC1 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;
IF SML THEN
    PLCCFG.STA_SML := true;
END_IF;

(*якщо змінна налаштована як технологічна тривога чи попередження передача цієї інформації в статусні біти технологічної змінної*)
ISALM := PRM_ISALM;
ISWRN := PRM_ISWRN;

(*передача статусних бітів з внутрішніх змінних в технологічну змінну*)
DIVARCFG.STA_VRAW := VRAW;
DIVARCFG.STA_VALB := VAL;
DIVARCFG.STA_BAD := BAD;
DIVARCFG.STA_ALDIS := ALDIS;
DIVARCFG.STA_DLNK := DLNK;
DIVARCFG.STA_ENBL := VARENBL;
DIVARCFG.STA_ALM := ALM;
DIVARCFG.STA_VALPRV := VALPRV;
DIVARCFG.STA_ISALM := ISALM;
DIVARCFG.STA_SPDMONON:= SPDMONON;
DIVARCFG.STA_ISWRN := ISWRN;
DIVARCFG.STA_WRN := WRN;
DIVARCFG.STA_INBUF := INBUF;
DIVARCFG.STA_FRC := FRC;
DIVARCFG.STA_SML := SML;
DIVARCFG.STA_CMDLOAD := FALSE;(*онулення біта запису в буфер*)

(*передача параметричних бітів з внутрішніх змінних в технологічну змінну*)
DIVARCFG.PRM_ISALM := PRM_ISALM;
DIVARCFG.PRM_ISWRN := PRM_ISWRN;
DIVARCFG.PRM_INVERSE := PRM_INVERSE;
DIVARCFG.PRM_NRMVAL := PRM_NRMVAL;
DIVARCFG.PRM_QALENBL := PRM_QALENBL;
DIVARCFG.PRM_DSBL := PRM_DSBL;
DIVARCFG.PRM_STATICMAP := PRM_STATICMAP;

DIVARHMI.STA := DIVARCFG.STA;(*передача статусних бітів з конфігураційної частини в НМІ*)

DIVARCFG.T_PREV := PLCCFG.TQMS;(*запамятовування часу останнього виклику екземпляра функції*)

(*підрахунок часу стану та обмеження його по верхній межі діапазону*)
DIVARCFG.T_STEP1 := DIVARCFG.T_STEP1 + dT1; 
IF DIVARCFG.T_STEP1 &gt; 16#7FFF_FFFF THEN
    DIVARCFG.T_STEP1 := 16#7FFF_FFFF;
END_IF;

(*автоматичне оновлення якщо змінна записана в буфер*)
IF INBUF THEN
    VARBUF.CMD := 0;
    VARBUF.VALR := INT_TO_REAL(DIVARCFG.VALI);
    VARBUF.STA := DIVARCFG.STA;
    VARBUF.STEP1 := DIVARCFG.STEP1;
    VARBUF.T_STEP1 := DIVARCFG.T_STEP1;

(*зчитування статусних бітів фізичного каналу технологічної змінної*)
    VARBUF.CH_CLSID := CHCFG.CLSID;
    VARBUF.CH_STA.0 := CHCFG.STA_VRAW;
    VARBUF.CH_STA.1 := CHCFG.STA_VALB;
    VARBUF.CH_STA.2 := CHCFG.STA_BAD;
    VARBUF.CH_STA.3 := CHCFG.STA_b3;
    VARBUF.CH_STA.4 := CHCFG.STA_PNG;
    VARBUF.CH_STA.5 := CHCFG.STA_ULNK;
    VARBUF.CH_STA.6 := CHCFG.STA_MERR;
    VARBUF.CH_STA.7 := CHCFG.STA_BRK;
    VARBUF.CH_STA.8 := CHCFG.STA_SHRT;
    VARBUF.CH_STA.9 := CHCFG.STA_NBD;
    VARBUF.CH_STA.10 := CHCFG.STA_b10;
    VARBUF.CH_STA.11 := CHCFG.STA_INIOTBUF;
    VARBUF.CH_STA.12 := CHCFG.STA_INBUF;
    VARBUF.CH_STA.13 := CHCFG.STA_FRC;
    VARBUF.CH_STA.14 := CHCFG.STA_SML;
    VARBUF.CH_STA.15 := CHCFG.STA_CMDLOAD;
END_IF;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(DIVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND DIVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   VARBUFOUT.MSG := 201;

   VARBUFOUT.PRM.0 := DIVARCFG.PRM_ISALM;
   VARBUFOUT.PRM.1 := DIVARCFG.PRM_ISWRN;
   VARBUFOUT.PRM.2 := DIVARCFG.PRM_INVERSE;
   VARBUFOUT.PRM.5 := DIVARCFG.PRM_NRMVAL;
   VARBUFOUT.PRM.6 := DIVARCFG.PRM_QALENBL;
   VARBUFOUT.PRM.7 := DIVARCFG.PRM_DSBL;
   VARBUFOUT.PRM.14 := DIVARCFG.PRM_STATICMAP;
          
   VARBUFOUT.ID := DIVARCFG.ID;
   VARBUFOUT.CLSID := DIVARCFG.CLSID;
   VARBUFOUT.CHID := DIVARCFG.CHID;
   VARBUFOUT.VALR := INT_TO_REAL(DIVARCFG.VALI);
   VARBUFOUT.T_FLTSP := DIVARCFG.T_FLTSP;
   VARBUFOUT.T_DEALL := DIVARCFG.T_DEASP;
 
   VARBUFIN.CMD :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(DIVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND DIVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   
   VARBUFOUT:=VARBUFIN;
    
   DIVARCFG.PRM_ISALM := VARBUFIN.PRM.0;
   DIVARCFG.PRM_ISWRN := VARBUFIN.PRM.1;
   DIVARCFG.PRM_INVERSE := VARBUFIN.PRM.2;
   DIVARCFG.PRM_NRMVAL := VARBUFIN.PRM.5;
   DIVARCFG.PRM_QALENBL := VARBUFIN.PRM.6;
   DIVARCFG.PRM_DSBL := VARBUFIN.PRM.7;
   DIVARCFG.PRM_STATICMAP := VARBUFIN.PRM.14;

   DIVARCFG.T_FLTSP := VARBUF.T_FLTSP;
   DIVARCFG.T_DEASP := VARBUF.T_DEALL;

   VARBUFOUT.MSG:=200;
   IF NOT DIVARCFG.PRM_STATICMAP THEN 
      IF VARBUFIN.CHID&gt;=0 AND VARBUFIN.CHID &lt;= INT_TO_UINT(PLCCFG.DICNT) THEN
         IF CHDI[VARBUFIN.CHID].VARID = 0 THEN 
            DIVARCFG.CHID := VARBUFIN.CHID;
         ELSIF VARBUFIN.CHID &lt;&gt; DIVARCFG.CHID THEN 
            VARBUFOUT.MSG := 403;(* канал вже зайнятий*)
         END_IF;
      ELSE 
         VARBUFOUT.MSG := 404; (*номер каналу не відповідає діапазону*)
      END_IF;
   ELSIF VARBUFIN.CHID &lt;&gt; DIVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
      VARBUFOUT.MSG := 405;(* активна статична адресація каналів*)
   END_IF;

   VARBUFIN.CMD :=0; 
end_if;  


</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_aovars" type="SR" task="MAST"></identProgram>
		<STSource>AOVARFN(CHCFG := CHAO[VARS.T1_VRHEA_CPOS.CHID], AOVARCFG := VARS.T1_VRHEA_CPOS, AOVARHMI := AOH.T1_VRHEA_CPOS, VARBUF := VARBUF, PLCCFG := PLC, CHAO := CHAO); (*приклад*) 

</STSource>
	</program>
	<FBSource nameOfFBType="AOVARFN" version="0.29" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка AO</comment>
		<attribute name="TypeCodeCheckSumString" value="6105"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="351C"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
			<variables name="AOVARCFG" typeName="AOVAR_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="AOVARHMI" typeName="AOVAR_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="VARBUF" typeName="VARBUF">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
			<variables name="CHAO" typeName="ARRAY[0..4] OF CH_CFG">
				<attribute name="PositionPin" value="6"></attribute>
			</variables>
		</inOutParameters>
		<publicLocalVariables>
			<variables name="IDMIN" typeName="UINT"></variables>
			<variables name="IDMAX" typeName="UINT"></variables>
			<variables name="VARBUFIN" typeName="VARBUF"></variables>
			<variables name="VARBUFOUT" typeName="VARBUF"></variables>
		</publicLocalVariables>
		<privateLocalVariables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="ALDIS" typeName="BOOL"></variables>
			<variables name="DLNK" typeName="BOOL"></variables>
			<variables name="ENBL" typeName="BOOL"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="PRM_QALENBL" typeName="BOOL"></variables>
			<variables name="PRM_DSBL" typeName="BOOL"></variables>
			<variables name="PRM_PWLENBL" typeName="BOOL"></variables>
			<variables name="CMD" typeName="UINT"></variables>
			<variables name="VARENBL" typeName="BOOL"></variables>
			<variables name="VRAW" typeName="INT"></variables>
			<variables name="T_STEPMS" typeName="UDINT"></variables>
			<variables name="dT1" typeName="UDINT"></variables>
			<variables name="VAL" typeName="REAL"></variables>
			<variables name="VAL1PROC" typeName="REAL"></variables>
			<variables name="tempBAD" typeName="BOOL"></variables>
			<variables name="TDEAQALSP" typeName="INT"></variables>
			<variables name="VALPROC" typeName="REAL"></variables>
			<variables name="VALFLT" typeName="REAL"></variables>
			<variables name="tmpuint" typeName="INT"></variables>
			<variables name="STA_SCL" typeName="INT"></variables>
			<variables name="PRM_SCL" typeName="INT"></variables>
			<variables name="A_FLTR" typeName="A_FLTR"></variables>
			<variables name="SCALING" typeName="SCALING"></variables>
			<variables name="INT_TO_SIGU" typeName="INT_TO_SIGU"></variables>
		</privateLocalVariables>
		<FBProgram name="AOVARFN">
			<STSource>(*ініціалізація змінної на першому циклі обробки*)
IF PLCCFG.STA_SCN1 THEN
    AOVARCFG.CLSID := 16#1040; (*присвоєння ідентифікатора класу*)
    AOVARCFG.PRM_DSBL := FALSE; (*активація змінної*)
    AOVARCFG.PRM_QALENBL := true; (*активація тривог перевірки якості даних*)
    AOVARCFG.T_PREV := PLCCFG.TQMS; (*збереження часу виклику*)
    IF AOVARCFG.CHID = 0 THEN (*якщо логіний номер каналу на заданий - записати значення по замовчування *)
        AOVARCFG.CHID := AOVARCFG.CHIDDF;
    END_IF;

    (*запис сирого значення з каналу для подальшої обробки*)
    IF CHCFG.ID &gt; 0 THEN
        CHCFG.VAL := AOVARCFG.VRAW;
    ELSE
        CHCFG.VAL := 0;
    END_IF;

    AOVARCFG.T_STEP1 := 0; (*онулення часу кроку*)
    AOVARCFG.STEP1 := 100; (*переведення на крок норми*)

    (*визначення діапазонів ідентифікаторів змінної*)
    IF AOVARCFG.ID&gt;0 THEN
    	IF AOVARCFG.ID&lt;IDMIN THEN IDMIN:=AOVARCFG.ID; END_IF;
    	IF AOVARCFG.ID&gt;IDMAX THEN IDMAX:=AOVARCFG.ID; END_IF;
    END_IF;
    RETURN;
END_IF;

(*зчитування статусних бітів з технологічної змінної у внутрішні змінні*)
BAD := AOVARCFG.STA_BAD;
ALDIS := AOVARCFG.STA_ALDIS;
DLNK := AOVARCFG.STA_DLNK;
ENBL := AOVARCFG.STA_ENBL;
INBUF := AOVARCFG.STA_INBUF;
FRC := AOVARCFG.STA_FRC;
SML := AOVARCFG.STA_SML;
CMDLOAD := AOVARCFG.STA_CMDLOAD;

INBUF := (AOVARCFG.ID = VARBUF.ID) AND (AOVARCFG.CLSID = VARBUF.CLSID); (*змінна в буфері якщо співпадає ідентифікатор змінної та ідентифікатор класу*)
CMDLOAD := AOVARHMI.STA.15;  (*команда запису в буфер з НМІ змінної*)
CMD := 0; (*онулення внутрішньої команда*)
DLNK := (CHCFG.ID &gt; 0); (*змінна привязана до каналу якщо канал має реальний ідентифікатор (не 0 - не молоко)*)
VARENBL := NOT AOVARCFG.PRM_DSBL AND DLNK;(*змінна задіяна якщо привязана до каналу і не активний параметр змінна не задіяна*)

T_STEPMS := AOVARCFG.T_STEP1; (*запамятовування часу циклу в мс*)
VAL := AOVARCFG.VAL; (*зчитування значення з технологічної змінної у внутрішню дляя подальшої обробки*)
VRAW := AOVARCFG.VRAW; (*зчитування сирого значення з каналу*)

(*реалізація алгоритму ping-pong*)
IF DLNK THEN
    CHCFG.STA_PNG := true;
    CHCFG.VARID := AOVARCFG.ID;
END_IF;

(*якщо змінна не задіяна не рахуємо час, скидаємо стан *)
IF NOT VARENBL THEN
    AOVARCFG.T_STEP1 := 0;
    AOVARCFG.STEP1 := 400;
END_IF;

(*визначення часу між викликами функції по різниці між мілісікундним лічильником та часом який пройшов з попереднього виклику *)
dT1 := PLCCFG.TQMS - AOVARCFG.T_PREV;

(* широкомовне дефорсування*) 
IF PLCCFG.CMD = 16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;

(*вибір джерела конфігураційної/керівної команди згідно пріоритету якщо команди надійшли одночасно*)
IF CMDLOAD THEN (*команда запису в буфер - команда з НМІ*)
    CMD := 16#0100;
ELSIF INBUF AND VARBUF.CMD &lt;&gt; 0 THEN (*команда з буферу*)
    CMD := VARBUF.CMD;
END_IF;

(*commands*)
CASE CMD OF
    16#0001: (*записати максимум діапазону*)
        IF FRC AND INBUF THEN
            AOVARCFG.VALFRC := AOVARCFG.HIENG;
            VAL := AOVARCFG.HIENG;
            AOVARCFG.STEP1 := 100;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    16#0002: (*записати мінімум діапазону*)
        IF FRC AND INBUF THEN
            AOVARCFG.VALFRC := AOVARCFG.LOENG;
            VAL := AOVARCFG.LOENG;
            AOVARCFG.STEP1 := 100;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    16#0003: (*записати середину діапазону*)
        IF FRC AND INBUF THEN
            AOVARCFG.VALFRC := (AOVARCFG.HIENG - AOVARCFG.LOENG) / 2.0;
            VAL := (AOVARCFG.HIENG - AOVARCFG.LOENG) / 2.0;
            AOVARCFG.STEP1 := 100;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    16#0100: (*прочитати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів *)
        VARBUF.MSG := 201; 

        (*зчитати ідентифікатор змінної та ідентифікатор класу*)
        VARBUF.ID := AOVARCFG.ID;
        VARBUF.CLSID := AOVARCFG.CLSID;

        (*зчитати бітові параметри*)
        VARBUF.PRM.6 := AOVARCFG.PRM_QALENBL;
        VARBUF.PRM.7 := AOVARCFG.PRM_DSBL;
        VARBUF.PRM.8 := AOVARCFG.PRM_PWLENBL;
        VARBUF.PRM.14 := AOVARCFG.PRM_STATICMAP;
        VARBUF.PRM.15 := AOVARCFG.PRM_NORAW;
        
        (*зчитати параметри*)
        VARBUF.CHID := AOVARCFG.CHID;
        VARBUF.LORAW := AOVARCFG.LORAW;
        VARBUF.HIRAW := AOVARCFG.HIRAW;
        VARBUF.LOENG := AOVARCFG.LOENG;
        VARBUF.HIENG := AOVARCFG.HIENG;
        VARBUF.MVAL := AOVARCFG.MVAL;
        VARBUF.T_FLTSP := AOVARCFG.T_FLT;

        (*зчитати значення змінної для безударного форсування*)
        VARBUF.VALR := AOVARCFG.VALFRC;
        
    16#0101: (*записати конфігурацію*)
        (* MSG 200-Ok 400-Error
        // 200 - Дані записані
        // 201 - Дані прочитані 
        // 403 - канал вже зайнятий 
        // 404 - номер каналу не відповідає діапазону   
	// 405 - активна статична адресація каналів*)
        VARBUF.MSG:=200;        
	
	(*записати бітові параметри*)
	AOVARCFG.PRM_QALENBL := VARBUF.PRM.6;
        AOVARCFG.PRM_DSBL := VARBUF.PRM.7;
        AOVARCFG.PRM_PWLENBL := VARBUF.PRM.8;
	AOVARCFG.PRM_STATICMAP := VARBUF.PRM.14;
        AOVARCFG.PRM_NORAW := VARBUF.PRM.15;
        
	(*записати параметри*)
        AOVARCFG.LORAW := VARBUF.LORAW;
        AOVARCFG.HIRAW := VARBUF.HIRAW;
        AOVARCFG.LOENG := VARBUF.LOENG;
        AOVARCFG.HIENG := VARBUF.HIENG;
        AOVARCFG.MVAL := VARBUF.MVAL;
        AOVARCFG.T_FLT := VARBUF.T_FLTSP;
        
        IF NOT AOVARCFG.PRM_STATICMAP THEN (* зміна логічного номеру каналу тільки при неактивна статичн адресація*)
            IF VARBUF.CHID&gt;=0 AND VARBUF.CHID &lt;= INT_TO_UINT(PLCCFG.AOCNT) THEN (* якщо логічний номер канал менший за кількість каналів*)
                IF CHAO[VARBUF.CHID].VARID = 0 THEN (* якщо логічний номер канал нульовий - вільний *) 
                    AOVARCFG.CHID := VARBUF.CHID; (* змінити логічний номер каналу *)
                ELSIF VARBUF.CHID &lt;&gt; AOVARCFG.CHID THEN  (* інакше вивести помилку про зайнятість каналу *)
                    VARBUF.MSG := 403;(* канал вже зайнятий*)
                END_IF;
            ELSE 
                VARBUF.MSG := 404; (*номер каналу не відповідає діапазону*)
            END_IF;
        ELSIF VARBUF.CHID &lt;&gt; AOVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
           VARBUF.MSG := 405;(* активна статична адресація каналів*)
        END_IF;
        IF INBUF THEN (*оновити логічний номер каналу після запису якщо змінна ще в буфері*)
            VARBUF.CHID := AOVARCFG.CHID;
        END_IF;
        
        
    16#0102: (*записати значення за замовченням*)
        AOVARCFG.CHID := AOVARCFG.CHIDDF;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*ввімкнути форсування*)
        FRC := true;
    16#0302: (*вимкнути форсування*)
        FRC := false;
    16#0311: (* імітувати*)
        SML := true;
    16#0312: (* зняти режим імітації*)
        SML := false;
END_CASE;

(*перевірка на коректність діапазонів*)
IF ABS (AOVARCFG.HIRAW - AOVARCFG.LORAW) &lt; 1 THEN
    AOVARCFG.LORAW := 0;
    AOVARCFG.HIRAW := 10000;
END_IF;
IF ABS(AOVARCFG.HIENG - AOVARCFG.LOENG) &lt; 0.00001 THEN
    AOVARCFG.LOENG := 0.0;
    AOVARCFG.HIENG := 100.0;
END_IF;

(*визначення 1% від шкали*)
VAL1PROC := INT_TO_REAL(AOVARCFG.HIRAW - AOVARCFG.LORAW) / 100.0; 
IF VAL1PROC = 0.0 THEN
   VAL1PROC := 1.0;
END_IF;

(*val*)
IF FRC THEN (*режим форсування*)
    IF INBUF THEN
        AOVARCFG.VALFRC := VARBUF.VALR;
    END_IF;
    VAL := AOVARCFG.VALFRC;
ELSE
    AOVARCFG.VALFRC := VAL;
END_IF;

IF VARENBL THEN
  (*якщо попереднього значення виходить за діапазон вводимо обмеження діапазону*)
  IF AOVARCFG.VALPRV&lt;AOVARCFG.LOENG THEN AOVARCFG.VALPRV:=AOVARCFG.LOENG; END_IF;
  IF AOVARCFG.VALPRV&gt;AOVARCFG.HIENG THEN AOVARCFG.VALPRV:=AOVARCFG.HIENG; END_IF;

  (*фільтрація*)
  IF AOVARCFG.T_FLT &lt;= 0 THEN (*час фільтрації не може бути нульовим*)
   AOVARCFG.T_FLT := 1;
  END_IF;
  A_FLTR (IN := VAL, dT1 := dT1, T_FLT := UINT_TO_UDINT(AOVARCFG.T_FLT), PRM := tmpuint, STA := tmpuint, VALPRV := AOVARCFG.VALPRV, A_FLTR =&gt; VALFLT);

  (*масштабування*)
  PRM_SCL:=0;STA_SCL:=0;
  PRM_SCL.0 := false;(*//квадратнокоренева залежність, X0  *)
  PRM_SCL.1 := FALSE;(*//обмежувати вихідну величину, X1 *)  
  SCALING (IN := VALFLT, in_min := AOVARCFG.LOENG, in_max := AOVARCFG.HIENG, out_min := INT_TO_REAL(AOVARCFG.LORAW), out_max := INT_TO_REAL(AOVARCFG.HIRAW), STA := STA_SCL, PRM := PRM_SCL);
  IF NOT AOVARCFG.PRM_NORAW THEN (*якщо маштабування не відімкнено*)
     VRAW := REAL_TO_INT(SCALING.SCALING); (*в сире значення записується маштабована величина*)
  ELSE
     VRAW := REAL_TO_INT(VALFLT); (*інакше значення не маштабується*)
  END_IF;

  IF NOT SML THEN (* режим симуляції - вихідне значення не змінюється *)
     CHCFG.VAL := VRAW;
  END_IF;
END_IF;

(*обробка тривог - недостовірність каналу*)
tempBAD := CHCFG.STA_BAD AND AOVARCFG.PRM_QALENBL AND VARENBL AND NOT SML;
TDEAQALSP := 10;     (* час затримки на виникнення тривог бед в 0.1 с*)

CASE AOVARCFG.STEP1 OF
    0:(*init*)
        AOVARCFG.STEP1 := 100;
        AOVARCFG.T_STEP1 := 0;
    100:(*norma*)
        BAD := false;
        IF tempBAD THEN
            AOVARCFG.STEP1 := 150;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    150:(*norma to BAD*)
        IF AOVARCFG.T_STEP1 &gt; INT_TO_UDINT(TDEAQALSP) THEN
            AOVARCFG.STEP1 := 200;
            AOVARCFG.T_STEP1 := 0;
        ELSIF NOT tempBAD THEN
            AOVARCFG.STEP1 := 100;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    200:(*BAD*)
        BAD := true;
        IF NOT tempBAD AND AOVARCFG.T_STEP1 &gt; INT_TO_UDINT(TDEAQALSP) THEN
            AOVARCFG.STEP1 := 100;
            AOVARCFG.T_STEP1 := 0;
        END_IF;
    ELSE
        AOVARCFG.STEP1 := 0;
END_CASE;

(*передача тривог для змінної PLCCFG для формування загального статусного біта і визначення нової тривоги*)
IF BAD THEN
    PLCCFG.ALM_BAD := true;
    PLCCFG.CNTBAD := PLCCFG.CNTBAD + 1;
    IF NOT AOVARCFG.STA_BAD THEN
        PLCCFG.ALM_NWBAD := true;
    END_IF;
END_IF;

(*передача статусних бітів для змінної PLCCFG для формування загального статусного біта*)
IF FRC THEN
    PLCCFG.STA_FRC1 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;
IF SML THEN
    PLCCFG.STA_SML := true;
END_IF;

CMDLOAD := FALSE;

(*передача статусних бітів з внутрішніх змінних в технологічну змінну*)
AOVARCFG.STA_BAD := BAD;
AOVARCFG.STA_ALDIS := ALDIS;
AOVARCFG.STA_DLNK := DLNK;
AOVARCFG.STA_ENBL := VARENBL;
AOVARCFG.STA_INBUF := INBUF;
AOVARCFG.STA_FRC := FRC;
AOVARCFG.STA_SML := SML;
AOVARCFG.STA_CMDLOAD :=  FALSE;

(*значення у % та обмеження*)
IF VAL1PROC = 0.0 THEN
    VAL1PROC := 1.0;
END_IF;
VALPROC := INT_TO_REAL(CHCFG.VAL - AOVARCFG.LORAW) / VAL1PROC;
IF VALPROC &lt; 0.0 THEN
    VALPROC := 0.0;
END_IF;
IF VALPROC &gt; 100.0 THEN
    VALPROC := 100.0;
END_IF;

(*передача значення з внутрішніх змінних в технологічну змінну*)
AOVARCFG.VAL := VAL;
AOVARCFG.VRAW := VRAW;
AOVARCFG.VALPROC := REAL_TO_INT(VALPROC*256.0) AND 16#FF00;(*по аналогії з AIVAR*)

(*передача значення в HMI частину*)
AOVARHMI.STA := AOVARCFG.STA;
AOVARHMI.VAL := VAL;
AOVARHMI.VALPROC := AOVARCFG.VALPROC;

AOVARCFG.T_PREV := PLCCFG.TQMS;(*запамятовування часу останнього виклику екземпляра функції*)

(*підрахунок часу стану та обмеження його по верхній межі діапазону*)
AOVARCFG.T_STEP1 := AOVARCFG.T_STEP1 + dT1;
IF AOVARCFG.T_STEP1 &gt; 16#7FFF_FFFF THEN
    AOVARCFG.T_STEP1 := 16#7FFF_FFFF;
END_IF;

(*автоматичне оновлення якщо змінна записана в буфер*)
IF INBUF THEN
    VARBUF.CMD := 0;
    VARBUF.STA := AOVARHMI.STA;
    VARBUF.VRAWR := INT_TO_REAL(VRAW);
    VARBUF.VALR := VAL;
    VARBUF.VALPROC := AOVARCFG.VALPROC;
    VARBUF.STEP1 := AOVARCFG.STEP1;
    VARBUF.T_STEP1 := AOVARCFG.T_STEP1;

    (*зчитування статусних бітів фізичного каналу технологічної змінної*)    
    VARBUF.CH_CLSID := CHCFG.CLSID;
    VARBUF.CH_STA.0 := CHCFG.STA_VRAW;
    VARBUF.CH_STA.1 := CHCFG.STA_VALB;
    VARBUF.CH_STA.2 := CHCFG.STA_BAD;
    VARBUF.CH_STA.3 := CHCFG.STA_b3;
    VARBUF.CH_STA.4 := CHCFG.STA_PNG;
    VARBUF.CH_STA.5 := CHCFG.STA_ULNK;
    VARBUF.CH_STA.6 := CHCFG.STA_MERR;
    VARBUF.CH_STA.7 := CHCFG.STA_BRK;
    VARBUF.CH_STA.8 := CHCFG.STA_SHRT;
    VARBUF.CH_STA.9 := CHCFG.STA_NBD;
    VARBUF.CH_STA.10 := CHCFG.STA_b10;
    VARBUF.CH_STA.11 := CHCFG.STA_INIOTBUF;
    VARBUF.CH_STA.12 := CHCFG.STA_INBUF;
    VARBUF.CH_STA.13 := CHCFG.STA_FRC;
    VARBUF.CH_STA.14 := CHCFG.STA_SML;
    VARBUF.CH_STA.15 := CHCFG.STA_CMDLOAD;

    (*функція обрахунку фізичного значення сигналу в мА,В і т.д*)
    INT_TO_SIGU (CLSID := CHCFG.CLSID, 	VALINT := VRAW, INT_TO_SIGU =&gt; VARBUF.CH_VALSIG);
END_IF;

(*реалізація читання конфігураційних даних в буфер out*)
IF (uint_to_word(AOVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND AOVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#100 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   VARBUFOUT.MSG := 201;

   VARBUFOUT.PRM.6 := AOVARCFG.PRM_QALENBL;
   VARBUFOUT.PRM.7 := AOVARCFG.PRM_DSBL;
   VARBUFOUT.PRM.8 := AOVARCFG.PRM_PWLENBL;
   VARBUFOUT.PRM.14 := AOVARCFG.PRM_STATICMAP;
   VARBUFOUT.PRM.15 := AOVARCFG.PRM_NORAW;
        
   VARBUFOUT.ID := AOVARCFG.ID;
   VARBUFOUT.CLSID := AOVARCFG.CLSID;
   VARBUFOUT.CHID := AOVARCFG.CHID;
   VARBUFOUT.VALR := AOVARCFG.VALFRC;
        
   VARBUFOUT.LORAW := AOVARCFG.LORAW;
   VARBUFOUT.HIRAW := AOVARCFG.HIRAW;
   VARBUFOUT.LOENG := AOVARCFG.LOENG;
   VARBUFOUT.HIENG := AOVARCFG.HIENG;
   VARBUFOUT.MVAL := AOVARCFG.MVAL;
   VARBUFOUT.T_FLTSP := AOVARCFG.T_FLT;

   VARBUFIN.CMD :=0; 
end_if;  

(*реалізація запису конфігураційних даних з буфер in в технологічну змінну*)
IF (uint_to_word(AOVARCFG.CLSID) AND 16#FFF0)=(uint_to_word(VARBUFIN.CLSID) AND 16#FFF0) AND AOVARCFG.ID=VARBUFIN.ID AND VARBUFIN.CMD = 16#101 then
   (* MSG 200-Ok 400-Error
   // 200 - Дані записані
   // 201 - Дані прочитані 
   // 403 - канал вже зайнятий 
   // 404 - номер каналу не відповідає діапазону   *)
   
   VARBUFOUT:=VARBUFIN;

   AOVARCFG.PRM_QALENBL := VARBUFIN.PRM.6;
   AOVARCFG.PRM_DSBL := VARBUFIN.PRM.7;
   AOVARCFG.PRM_PWLENBL := VARBUFIN.PRM.8;
   AOVARCFG.PRM_STATICMAP := VARBUFIN.PRM.14;
   AOVARCFG.PRM_NORAW := VARBUFIN.PRM.15;
        
   AOVARCFG.LORAW := VARBUFIN.LORAW;
   AOVARCFG.HIRAW := VARBUFIN.HIRAW;
   AOVARCFG.LOENG := VARBUFIN.LOENG;
   AOVARCFG.HIENG := VARBUFIN.HIENG;
   AOVARCFG.MVAL := VARBUFIN.MVAL;
   AOVARCFG.T_FLT := VARBUFIN.T_FLTSP;
        
   (*перевіряти незайнятість каналу треба в функції контролю буферу *)
   VARBUFOUT.MSG:=200; 
   IF NOT AOVARCFG.PRM_STATICMAP THEN 
      IF VARBUFIN.CHID&gt;=0 AND VARBUFIN.CHID &lt;= INT_TO_UINT(PLCCFG.AOCNT) THEN
         IF CHAO[VARBUFIN.CHID].VARID = 0 THEN 
            AOVARCFG.CHID := VARBUFIN.CHID;
         ELSIF VARBUFIN.CHID &lt;&gt; AOVARCFG.CHID THEN 
            VARBUFOUT.MSG := 403;(* канал вже зайнятий*)
         END_IF;
      ELSE 
         VARBUFOUT.MSG := 404; (*номер каналу не відповідає діапазону*)
      END_IF;
   ELSIF VARBUFIN.CHID &lt;&gt; AOVARCFG.CHID THEN (* інакше вивести помилку активна статична адресація каналів *)
      VARBUFOUT.MSG := 405;(* активна статична адресація каналів*)
   END_IF;
   VARBUFIN.CMD :=0; 
end_if;  
</STSource>
		</FBProgram>
	</FBSource>
	<DDTSource DDTName="AOVAR_HMI" version="0.01" dateTime="dt#2022-01-06-17:23:18">
		<comment>PFW структура AOVAR для HMI</comment>
		<attribute name="TypeSignatureCheckSumString" value="92BD"></attribute>
		<structure>
			<variables name="STA" typeName="INT">
				<comment>біти стану</comment>
			</variables>
			<variables name="VALPROC" typeName="INT">
				<comment>значення у % від шкали вимірювання (0-10000)</comment>
			</variables>
			<variables name="VAL" typeName="REAL">
				<comment>масштабоване значення</comment>
			</variables>
		</structure>
	</DDTSource>
	<DDTSource DDTName="AOH" version="0.02" dateTime="dt#2022-04-26-16:21:58">
		<comment>PFW екземпляри AOVAR_HMI  </comment>
		<attribute name="TypeSignatureCheckSumString" value="34C0"></attribute>
		<structure>
			<variables name="T1_VRHEA_CPOS" typeName="AOVAR_HMI">
				<comment>клапан нагрівання T1</comment>
			</variables>
		</structure>
	</DDTSource>
	<program>
		<identProgram name="A_initvars" type="SR" task="MAST"></identProgram>
		<STSource>VARS.T1_LT1.ID:=1; VARS.T1_LT1.CHID:=1; VARS.T1_LT1.CHIDDF:=1;
VARS.T1_VSLD_SOPN.ID:=10001; VARS.T1_VSLD_SOPN.CHID:=1; VARS.T1_VSLD_SOPN.CHIDDF:=1;
VARS.T1_VSLD_COPN.ID:=20001; VARS.T1_VSLD_COPN.CHID:=1; VARS.T1_VSLD_COPN.CHIDDF:=1;
VARS.T1_VRHEA_CPOS.ID:=5001; VARS.T1_VRHEA_CPOS.CHID:=1; VARS.T1_VRHEA_CPOS.CHIDDF:=1;
</STSource>
	</program>
	<program>
		<identProgram name="A_aivars" type="SR" task="MAST"></identProgram>
		<STSource>AIVARFN(CHCFG := CHAI[VARS.T1_LT1.CHID], AIVARCFG := VARS.T1_LT1, AIVARHMI := AIH.T1_LT1, VARBUF := VARBUF, PLCCFG := PLC, CHAI := CHAI); (*приклад*)

</STSource>
	</program>
	<DDTSource DDTName="AIH" version="0.03" dateTime="dt#2022-04-26-16:21:57">
		<comment>PFW екземпляри AIVAR_HMI </comment>
		<attribute name="TypeSignatureCheckSumString" value="91A7"></attribute>
		<structure>
			<variables name="T1_LT1" typeName="AIVAR_HMI">
				<comment>рівень T1</comment>
			</variables>
		</structure>
	</DDTSource>
	<program>
		<identProgram name="A_naichs" type="SR" task="MAST"></identProgram>
		<STSource>
		</STSource>
	</program>
	<program>
		<identProgram name="A_aichs" type="SR" task="MAST"></identProgram>
		<STSource>FOR i := 1 TO PLC.AICNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHAI[i].ID := INT_TO_UINT(i);
        IF CHAI[i].CLSID = 0 THEN CHAI[i].CLSID := 16#0030;END_IF;
    END_IF;
END_FOR;
(*для кожного каналу виклик ФБ з вказівкою змінної каналу*)
CHAIFN (RAWINT := %MW0(*%IW0.2.0*), CHCFG := CHAI[1], CHHMI := CHAI_HMI[1], PLCCFG := PLC, CHBUF := CH_BUF);
</STSource>
	</program>
	<FBSource nameOfFBType="CHAIFN" version="0.11" dateTime="dt#2022-07-26-10:44:22">
		<comment>PFW обробка каналу AI</comment>
		<attribute name="TypeCodeCheckSumString" value="8E69"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="B99E"></attribute>
		<inputParameters>
			<variables name="RAWINT" typeName="INT">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="CHHMI" typeName="CH_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CHBUF" typeName="CH_BUF">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<privateLocalVariables>
			<variables name="CMD" typeName="INT"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="ULNK" typeName="BOOL"></variables>
			<variables name="MERR" typeName="BOOL"></variables>
			<variables name="BRK" typeName="BOOL"></variables>
			<variables name="SHRT" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="PNG" typeName="BOOL"></variables>
			<variables name="NBD" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="MIN" typeName="INT"></variables>
			<variables name="MAX" typeName="INT"></variables>
			<variables name="MIDLE" typeName="INT"></variables>
		</privateLocalVariables>
		<FBProgram name="CHAIFN">
			<STSource>MIN:=0;
MAX:=10000;
MIDLE:=5000;



CMD := CHCFG.CMD;
(*розпаковка з STA*)
VRAW := CHCFG.STA_VRAW;
VAL := CHCFG.STA_VALB;
BAD := CHCFG.STA_BAD;(*керується ззовні*)
PNG := CHCFG.STA_PNG;
ULNK := CHCFG.STA_ULNK;
MERR := CHCFG.STA_MERR;(*керується ззовні*)
BRK := CHCFG.STA_BRK;(*керується ззовні*)
SHRT := CHCFG.STA_SHRT;(*керується ззовні*)
NBD := CHCFG.STA_NBD;(*керується ззовні*)
INBUF := CHCFG.STA_INBUF;
FRC := CHCFG.STA_FRC;
SML := CHCFG.STA_SML;
CMDLOAD := CHCFG.STA_CMDLOAD; (*керується бітом*)

INBUF := (CHCFG.ID = CHBUF.ID) AND (CHCFG.CLSID = CHBUF.CLSID);
CMDLOAD := CHHMI.STA.15;
CMD := 0;

(* обробник команд*)
(* широкомовне форсування/дефорсування*) 
IF PLCCFG.CMD=16#4301 THEN
    FRC := true; (*форсувати один/усі об'єкти типу*)
END_IF;
IF PLCCFG.CMD=16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;
(*вибір джерела команди згідно пріоритету*)
IF CMDLOAD THEN (*з HMI CMDLOAD*)
    CMD := 16#0100;  (*// записати в буфер*)
ELSIF INBUF AND CHBUF.CMD &lt;&gt; 0 THEN (*з буферу*)
    CMD := CHBUF.CMD;
ELSIF CHCFG.CMD&lt;&gt;0 THEN
    CMD := CHCFG.CMD;
END_IF;

(*commands*)
CASE CMD OF
    16#1: (*записати MAX*)
        IF FRC AND INBUF THEN
            CHBUF.VAL := MAX;
        END_IF;
    16#2: (*записати MIN*)
        IF FRC AND INBUF THEN
            CHBUF.VAL:=MIN;
        END_IF;
    16#3: (*TOGGLE*)
        IF FRC AND INBUF THEN
            CHBUF.VAL := MIDLE;
        END_IF;
    16#0100: (*прочитати конфігурацію в буфер*)
        CHBUF.ID:= CHCFG.ID;
        CHBUF.CLSID:=CHCFG.CLSID;
        
        CHBUF.STA.0 := CHCFG.STA_VRAW;
        CHBUF.STA.1 := CHCFG.STA_VALB;
        CHBUF.STA.2 := CHCFG.STA_BAD;
        CHBUF.STA.3 := CHCFG.STA_b3;
        CHBUF.STA.4 := CHCFG.STA_PNG;
        CHBUF.STA.5 := CHCFG.STA_ULNK;
        CHBUF.STA.6 := CHCFG.STA_MERR;
        CHBUF.STA.7 := CHCFG.STA_BRK;
        CHBUF.STA.8 := CHCFG.STA_SHRT;
        CHBUF.STA.9 := CHCFG.STA_NBD;
        CHBUF.STA.10 := CHCFG.STA_b10;
        CHBUF.STA.11 := CHCFG.STA_INIOTBUF;
        CHBUF.STA.12 := CHCFG.STA_INBUF;
        CHBUF.STA.13 := CHCFG.STA_FRC;
        CHBUF.STA.14 := CHCFG.STA_SML;
        CHBUF.STA.15 := CHCFG.STA_CMDLOAD;
        
        CHBUF.VAL:=CHCFG.VAL;
        CHBUF.VARID:=CHCFG.VARID;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#301: (*форсувати один/усі об'єкти типу*)
        FRC := true;
    16#302: (*дефорсувати один/усі об'єкти типу*)
        FRC := false;
END_CASE;

(*запис значення змінної*)
IF FRC AND INBUF THEN (*режим форсування з занятим буфером*)
    CHCFG.VAL := CHBUF.VAL;
ELSIF FRC AND NOT INBUF THEN (*режим форсування без занятого буферу*)
    ;(*без змін*)
ELSIF NOT FRC THEN (*не режим форсування*)
    CHCFG.VAL  := RAWINT;
END_IF;

(*ping-pong*)
ULNK := PNG; (*прийшов ping - є звязок з верхнім рівнем*)
PNG := false; (*скидання біту PNG звязку з врехнім рівнем PONG*)
IF NOT ULNK THEN
    CHCFG.VARID := 0;
END_IF;

(*скидання оброблених команд*)
CMDLOAD := 0;
CMD := 0;

(*загальносистемні біти та лічильники*)
IF FRC THEN
    PLCCFG.STA_FRC0 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;

BAD:= BRK OR SHRT;

(*упковка в STA*)
CHCFG.STA_VRAW := RAWINT&gt;0;
CHCFG.STA_VALB:=CHCFG.VAL&gt;0;
CHCFG.STA_BAD:=BAD;(*керується ззовні*)
CHCFG.STA_PNG:=PNG;
CHCFG.STA_ULNK:=ULNK;
CHCFG.STA_MERR:=MERR;(*керується ззовні*)
CHCFG.STA_BRK:=BRK;(*керується ззовні*)
CHCFG.STA_SHRT:=SHRT;(*керується ззовні*)
CHCFG.STA_NBD:=NBD;(*керується ззовні*)
CHCFG.STA_INBUF := INBUF;
CHCFG.STA_FRC := FRC;
CHCFG.STA_SML := SML;
CHCFG.STA_CMDLOAD := CMDLOAD; (*керується бітом*)


CHCFG.CMD := CMD;

CHHMI.STA := CHCFG.STA;
CHHMI.VAL := CHCFG.VAL;

(*оновлення буферу*)
IF INBUF THEN
    CHBUF.STA:= CHCFG.STA;
    CHBUF.VARID := CHCFG.VARID;
    CHBUF.CMD := 0;
    IF NOT FRC THEN
        CHBUF.VAL := CHCFG.VAL;
    END_IF;
END_IF;
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_plcmaps" type="SR" task="MAST"></identProgram>
		<STSource>(*кількість каналів та модулів*)
PLC.DICNT := 32;
PLC.DOCNT := 32;
PLC.AICNT := 8;
PLC.AOCNT := 4;
PLC.MODULSCNT := 4;

(*завантажити в буфер підмодуль 0 модуля 0*)
MODULES[0].STA.11 := true;
(*0.1-DDM3202K*)
(*типи 1- DICH, 2- DOCH, 3- AICH, 4 – AOCH, 5 - COM*)
MODULES[0].TYPE1 := 16#1200; (*DI+DO*)
(*кількість каналів на кожен Submodule, комбінація в 16-ковому форматі 
- 1 (16#XYZQ) X - для першого субмодуля*)
MODULES[0].CHCNTS := 16#ff00;(*16 + 16*)
MODULES[0].STRTNMB[0] := 1;(*DI*)
MODULES[0].STRTNMB[1] := 1;(*DO*)
MODULES[0].STRTNMB[2] := 0;
MODULES[0].STRTNMB[3] := 0;

(*0.2-AMM0600*)
MODULES[1].TYPE1 := 16#3400;(*AI + AO*) 
MODULES[1].CHCNTS := 16#3100;(*16 + 16*)
MODULES[1].STRTNMB[0] := 1;(*AI*)
MODULES[1].STRTNMB[1] := 1;(*AO*)
MODULES[1].STRTNMB[2] := 0;
MODULES[1].STRTNMB[3] := 0;

(*0.3-DDM3202K*)
MODULES[2].TYPE1 := 16#1200; 
MODULES[2].CHCNTS := 16#ff00;
MODULES[2].STRTNMB[0] := 17;
MODULES[2].STRTNMB[1] := 17;
MODULES[2].STRTNMB[2] := 0;
MODULES[2].STRTNMB[3] := 0;

(*0.4-AMM0600*)
MODULES[3].TYPE1 := 16#3400; 
MODULES[3].CHCNTS := 16#3100;
MODULES[3].STRTNMB[0] := 5;
MODULES[3].STRTNMB[1] := 3;
MODULES[3].STRTNMB[2] := 0;
MODULES[3].STRTNMB[3] := 0;
</STSource>
	</program>
	<program>
		<identProgram name="A_dichs" type="SR" task="MAST"></identProgram>
		<STSource>FOR i := 1 TO PLC.DICNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHDI[i].ID := INT_TO_UINT(i);
        IF CHDI[i].CLSID = 0 THEN CHDI[i].CLSID := 16#0010;END_IF;
    END_IF;
END_FOR;
(*для кожного каналу виклик ФБ з вказівкою змінної каналу*)
CHDIFN (RAW := %M0(*%i0.1.0*),  CHCFG := CHDI[1],  CHHMI := CHDI_HMI[1],  PLCCFG := PLC, CHBUF := CH_BUF);
</STSource>
	</program>
	<FBSource nameOfFBType="CHDIFN" version="0.07" dateTime="dt#2022-07-26-10:44:23">
		<comment>PFW обробка каналу DI</comment>
		<attribute name="TypeCodeCheckSumString" value="C9FC"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="0BB1"></attribute>
		<inputParameters>
			<variables name="RAW" typeName="BOOL">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</inputParameters>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="CHHMI" typeName="CH_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CHBUF" typeName="CH_BUF">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<privateLocalVariables>
			<variables name="CMD" typeName="INT"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="ULNK" typeName="BOOL"></variables>
			<variables name="MERR" typeName="BOOL"></variables>
			<variables name="BRK" typeName="BOOL"></variables>
			<variables name="SHRT" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="PNG" typeName="BOOL"></variables>
			<variables name="NBD" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
		</privateLocalVariables>
		<FBProgram name="CHDIFN">
			<STSource>CMD := CHCFG.CMD;
(*розпаковка з STA*)
VRAW := CHCFG.STA_VRAW;
VAL := CHCFG.STA_VALB;
BAD := CHCFG.STA_BAD;(*керується ззовні*)
PNG := CHCFG.STA_PNG;
ULNK := CHCFG.STA_ULNK;
MERR := CHCFG.STA_MERR;(*керується ззовні*)
BRK := CHCFG.STA_BRK;(*керується ззовні*)
SHRT := CHCFG.STA_SHRT;(*керується ззовні*)
NBD := CHCFG.STA_NBD;(*керується ззовні*)
INBUF := CHCFG.STA_INBUF;
FRC := CHCFG.STA_FRC;
SML := CHCFG.STA_SML;
CMDLOAD := CHCFG.STA_CMDLOAD; (*керується бітом*)

INBUF := (CHCFG.ID = CHBUF.ID) AND (CHCFG.CLSID = CHBUF.CLSID);
CMDLOAD := CHHMI.STA.15;
CMD := 0;

(* обробник команд*)
(* широкомовне форсування/дефорсування*) 
IF PLCCFG.CMD=16#4301 THEN
    FRC := true; (*форсувати один/усі об'єкти типу*)
END_IF;
IF PLCCFG.CMD=16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;
(*вибір джерела команди згідно пріоритету*)
IF CMDLOAD THEN (*з HMI CMDLOAD*)
    CMD := 16#0100;  (*// записати в буфер*)
ELSIF INBUF AND CHBUF.CMD &lt;&gt; 0 THEN (*з буферу*)
    CMD := CHBUF.CMD;
ELSIF CHCFG.CMD&lt;&gt;0 THEN
    CMD := CHCFG.CMD;
END_IF;
(*commands*)
CASE CMD OF
    16#1: (*записати 1*)
        IF FRC AND INBUF THEN
            CHBUF.VAL := 1;
        END_IF;
    16#2: (*записати 0*)
        IF FRC AND INBUF THEN
            CHBUF.VAL:=0;
        END_IF;
    16#3: (*TOGGLE*)
        IF FRC AND INBUF THEN
            IF VAL THEN
                CHBUF.VAL:=0;
            ELSE
                CHBUF.VAL:=1;
            END_IF;
        END_IF;
    16#0100: (*прочитати конфігурацію в буфер*)
        CHBUF.ID:= CHCFG.ID;
        CHBUF.CLSID:=CHCFG.CLSID;
        
        CHBUF.STA.0 := CHCFG.STA_VRAW;
        CHBUF.STA.1 := CHCFG.STA_VALB;
        CHBUF.STA.2 := CHCFG.STA_BAD;
        CHBUF.STA.3 := CHCFG.STA_b3;
        CHBUF.STA.4 := CHCFG.STA_PNG;
        CHBUF.STA.5 := CHCFG.STA_ULNK;
        CHBUF.STA.6 := CHCFG.STA_MERR;
        CHBUF.STA.7 := CHCFG.STA_BRK;
        CHBUF.STA.8 := CHCFG.STA_SHRT;
        CHBUF.STA.9 := CHCFG.STA_NBD;
        CHBUF.STA.10 := CHCFG.STA_b10;
        CHBUF.STA.11 := CHCFG.STA_INIOTBUF;
        CHBUF.STA.12 := CHCFG.STA_INBUF;
        CHBUF.STA.13 := CHCFG.STA_FRC;
        CHBUF.STA.14 := CHCFG.STA_SML;
        CHBUF.STA.15 := CHCFG.STA_CMDLOAD;
        
        CHBUF.VAL:=CHCFG.VAL;
        CHBUF.VARID:=CHCFG.VARID;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#0301: (*форсувати один/усі об'єкти типу*)
        FRC := true;
    16#0302: (*дефорсувати один/усі об'єкти типу*)
        FRC := false;
END_CASE;

(*запис значення змінної*)
IF FRC AND INBUF THEN (*режим форсування з занятим буфером*)
    CHCFG.VAL := BOOL_TO_INT (CHBUF.VAL&gt;0);
    VAL := INT_TO_REAL(CHCFG.VAL) &gt; 0.5;
ELSIF FRC AND NOT INBUF THEN (*режим форсування без занятого буферу*)
    ;(*без змін*)
ELSIF SML THEN (*режим імітації*)
    ;(*//нічого не робимо, значення змінюється ззовні алгоритму 28.10.2021 Пупена*)
ELSIF NOT FRC THEN (*не режим форсування*)
    VAL := RAW;
    IF RAW THEN
        CHCFG.VAL := 1;
    ELSE
        CHCFG.VAL := 0;
    END_IF;
END_IF;

(*ping-pong*)
ULNK := PNG; (*прийшов ping - є звязок з верхнім рівнем*)
PNG := false; (*скидання біту PNG звязку з врехнім рівнем PONG*)
IF NOT ULNK THEN
    CHCFG.VARID := 0;
END_IF;

(*скидання оброблених команд*)
CMDLOAD := 0;
CMD := 0;


(*загальносистемні біти та лічильники*)
IF FRC THEN
    PLCCFG.STA_FRC0 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;

(*упковка в STA*)
CHCFG.STA_VRAW := RAW;
CHCFG.STA_VALB:=VAL;
CHCFG.STA_BAD:=BAD;(*керується ззовні*)
CHCFG.STA_PNG:=PNG;
CHCFG.STA_ULNK:=ULNK;
CHCFG.STA_MERR:=MERR;(*керується ззовні*)
CHCFG.STA_BRK:=BRK;(*керується ззовні*)
CHCFG.STA_SHRT:=SHRT;(*керується ззовні*)
CHCFG.STA_NBD:=NBD;(*керується ззовні*)
CHCFG.STA_INBUF := INBUF;
CHCFG.STA_FRC := FRC;
CHCFG.STA_SML := SML;
CHCFG.STA_CMDLOAD := CMDLOAD; (*керується бітом*)


CHCFG.CMD := CMD;

CHHMI.STA := CHCFG.STA;
CHHMI.VAL := CHCFG.VAL;

(*оновлення буферу*)
IF INBUF THEN
    CHBUF.STA:= CHCFG.STA;
    CHBUF.VARID := CHCFG.VARID;
    CHBUF.CMD := 0;
    IF NOT FRC THEN
        CHBUF.VAL := CHCFG.VAL;
    END_IF;
END_IF;
</STSource>
		</FBProgram>
	</FBSource>
	<program>
		<identProgram name="A_aochs" type="SR" task="MAST"></identProgram>
		<STSource>FOR i := 1 TO PLC.AOCNT DO
    (*на першому циклі ініціалізуємо змінні ID + CLSID*)
    IF PLC.STA_SCN1 THEN
        CHAO[i].ID := INT_TO_UINT(i);
        IF CHAO[i].CLSID = 0 THEN CHAO[i].CLSID := 16#0040;END_IF;
    END_IF;
END_FOR;
(*для кожного каналу виклик ФБ з вказівкою змінної каналу*)
CHAOFN (CHCFG := CHAO[1], CHHMI := CHAO_HMI[1], PLCCFG := PLC, CHBUF := CH_BUF, RAWINT =&gt; %MW0(*%QW0.2.4*));
</STSource>
	</program>
	<FBSource nameOfFBType="CHAOFN" version="0.07" dateTime="dt#2022-07-26-10:44:23">
		<comment>PFW обробка каналу AO</comment>
		<attribute name="TypeCodeCheckSumString" value="D7B2"></attribute>
		<attribute name="TypeSignatureCheckSumString" value="CE5F"></attribute>
		<inOutParameters>
			<variables name="CHCFG" typeName="CH_CFG">
				<attribute name="PositionPin" value="2"></attribute>
			</variables>
			<variables name="CHHMI" typeName="CH_HMI">
				<attribute name="PositionPin" value="3"></attribute>
			</variables>
			<variables name="PLCCFG" typeName="PLC_CFG">
				<attribute name="PositionPin" value="4"></attribute>
			</variables>
			<variables name="CHBUF" typeName="CH_BUF">
				<attribute name="PositionPin" value="5"></attribute>
			</variables>
		</inOutParameters>
		<outputParameters>
			<variables name="RAWINT" typeName="INT">
				<attribute name="PositionPin" value="1"></attribute>
			</variables>
		</outputParameters>
		<privateLocalVariables>
			<variables name="CMD" typeName="INT"></variables>
			<variables name="INBUF" typeName="BOOL"></variables>
			<variables name="ULNK" typeName="BOOL"></variables>
			<variables name="MERR" typeName="BOOL"></variables>
			<variables name="BRK" typeName="BOOL"></variables>
			<variables name="SHRT" typeName="BOOL"></variables>
			<variables name="SML" typeName="BOOL"></variables>
			<variables name="FRC" typeName="BOOL"></variables>
			<variables name="BAD" typeName="BOOL"></variables>
			<variables name="VRAW" typeName="BOOL"></variables>
			<variables name="VAL" typeName="BOOL"></variables>
			<variables name="PNG" typeName="BOOL"></variables>
			<variables name="NBD" typeName="BOOL"></variables>
			<variables name="CMDLOAD" typeName="BOOL"></variables>
			<variables name="MIN" typeName="INT"></variables>
			<variables name="MAX" typeName="INT"></variables>
			<variables name="MIDLE" typeName="INT"></variables>
		</privateLocalVariables>
		<FBProgram name="CHAOFN">
			<STSource>MIN:=0;
MAX:=10000;
MIDLE:=5000;


CMD := CHCFG.CMD;
(*розпаковка з STA*)
VRAW := CHCFG.STA_VRAW;
VAL := CHCFG.STA_VALB;
BAD := CHCFG.STA_BAD;(*керується ззовні*)
PNG := CHCFG.STA_PNG;
ULNK := CHCFG.STA_ULNK;
MERR := CHCFG.STA_MERR;(*керується ззовні*)
BRK := CHCFG.STA_BRK;(*керується ззовні*)
SHRT := CHCFG.STA_SHRT;(*керується ззовні*)
NBD := CHCFG.STA_NBD;(*керується ззовні*)
INBUF := CHCFG.STA_INBUF;
FRC := CHCFG.STA_FRC;
SML := CHCFG.STA_SML;
CMDLOAD := CHCFG.STA_CMDLOAD; (*керується бітом*)

INBUF := (CHCFG.ID = CHBUF.ID) AND (CHCFG.CLSID = CHBUF.CLSID);
CMDLOAD := CHHMI.STA.15;
CMD := 0;

(* обробник команд*)
(* широкомовне форсування/дефорсування*) 
IF PLCCFG.CMD=16#4301 THEN
    FRC := true; (*форсувати один/усі об'єкти типу*)
END_IF;
IF PLCCFG.CMD=16#4302 THEN
    FRC := false; (*дефорсувати об'єкт типу*)
END_IF;
(*вибір джерела команди згідно пріоритету*)
IF CMDLOAD THEN (*з HMI CMDLOAD*)
    CMD := 16#0100;  (*// записати в буфер*)
ELSIF INBUF AND CHBUF.CMD &lt;&gt; 0 THEN (*з буферу*)
    CMD := CHBUF.CMD;
ELSIF CHCFG.CMD&lt;&gt;0 THEN
    CMD := CHCFG.CMD;
END_IF;
(*commands*)
CASE CMD OF
    16#1: (*записати MAX*)
        IF FRC AND INBUF THEN
            RAWINT := MAX;
        END_IF;
    16#2: (*записати MIN*)
        IF FRC AND INBUF THEN
            RAWINT:=MIN;
        END_IF;
    16#3: (*TOGGLE*)
        IF FRC AND INBUF THEN
            RAWINT := MIDLE;
        END_IF;
    16#0100: (*прочитати конфігурацію в буфер*)
        CHBUF.ID:= CHCFG.ID;
        CHBUF.CLSID:=CHCFG.CLSID;
        
        CHBUF.STA.0 := CHCFG.STA_VRAW;
        CHBUF.STA.1 := CHCFG.STA_VALB;
        CHBUF.STA.2 := CHCFG.STA_BAD;
        CHBUF.STA.3 := CHCFG.STA_b3;
        CHBUF.STA.4 := CHCFG.STA_PNG;
        CHBUF.STA.5 := CHCFG.STA_ULNK;
        CHBUF.STA.6 := CHCFG.STA_MERR;
        CHBUF.STA.7 := CHCFG.STA_BRK;
        CHBUF.STA.8 := CHCFG.STA_SHRT;
        CHBUF.STA.9 := CHCFG.STA_NBD;
        CHBUF.STA.10 := CHCFG.STA_b10;
        CHBUF.STA.11 := CHCFG.STA_INIOTBUF;
        CHBUF.STA.12 := CHCFG.STA_INBUF;
        CHBUF.STA.13 := CHCFG.STA_FRC;
        CHBUF.STA.14 := CHCFG.STA_SML;
        CHBUF.STA.15 := CHCFG.STA_CMDLOAD;
        
        CHBUF.VAL:=CHCFG.VAL;
        CHBUF.VARID:=CHCFG.VARID;
    16#0300: (*перемкнути форсування*)
        FRC := NOT FRC;
    16#301: (*форсувати один/усі об'єкти типу*)
        FRC := true;
    16#302: (*дефорсувати один/усі об'єкти типу*)
        FRC := false;
END_CASE;

(*запис значення змінної*)
IF FRC AND INBUF THEN (*режим форсування з занятим буфером*)
    RAWINT := CHBUF.VAL;
ELSIF FRC AND NOT INBUF THEN (*режим форсування без занятого буферу*)
    ;(*без змін*)
ELSIF NOT FRC THEN (*не режим форсування*)
    RAWINT := CHCFG.VAL;
END_IF;

(*ping-pong*)
ULNK := PNG; (*прийшов ping - є звязок з верхнім рівнем*)
PNG := false; (*скидання біту PNG звязку з врехнім рівнем PONG*)
IF NOT ULNK THEN
    CHCFG.VARID := 0;
END_IF;

(*скидання оброблених команд*)
CMDLOAD := 0;
CMD := 0;

(*загальносистемні біти та лічильники*)
IF FRC THEN
    PLCCFG.STA_FRC0 := true;
    PLCCFG.CNTFRC := PLCCFG.CNTFRC + 1;
END_IF;


(*упковка в STA*)
CHCFG.STA_VRAW := RAWINT&gt;0;
CHCFG.STA_VALB:=CHCFG.VAL&gt;0;
CHCFG.STA_BAD:=BAD;(*керується ззовні*)
CHCFG.STA_PNG:=PNG;
CHCFG.STA_ULNK:=ULNK;
CHCFG.STA_MERR:=MERR;(*керується ззовні*)
CHCFG.STA_BRK:=BRK;(*керується ззовні*)
CHCFG.STA_SHRT:=SHRT;(*керується ззовні*)
CHCFG.STA_NBD:=NBD;(*керується ззовні*)
CHCFG.STA_INBUF := INBUF;
CHCFG.STA_FRC := FRC;
CHCFG.STA_SML := SML;
CHCFG.STA_CMDLOAD := CMDLOAD; (*керується бітом*)


CHCFG.CMD := CMD;

CHHMI.STA := CHCFG.STA;
CHHMI.VAL := RAWINT;

(*оновлення буферу*)
IF INBUF THEN
    CHBUF.STA:= CHCFG.STA;
    CHBUF.VARID := CHCFG.VARID;
    CHBUF.CMD := 0;
    IF NOT FRC THEN
        CHBUF.VAL := CHCFG.VAL;
    END_IF;
END_IF;
</STSource>
		</FBProgram>
	</FBSource>
</STExchangeFile>
