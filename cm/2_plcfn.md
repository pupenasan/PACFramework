# Клас PLC: програмований контролер 

**CLSID=16#21xx**

## Загальний опис

Екземпляри класу PLC є центральними координуючими модулями керування, які відповідають за організацію загально-контролерних функцій, зокрема (але не обмежено ними):

-   виконання загальнокотролерних функцій, якщо вони не пов'язані з якоюсь частиною процесу а саме з усім обладнанням;
-    контроль статусів для всього контролеру (наявності блокувань, форсувань, ручних режимів, перший скан, імітації хоча б одного елементу) зокрема для відображення його на HMI;
-    контроль стану тривог для всього контролеру (наявності аварій, попереджень, помилок каналів, вияв нових тривог, наявність непідтверджених тривог);
-    обробка загальної сигналізації, наприклад апаратних світлових та звукових сигналізаторів (ревун, сирена і т.п.) та їх квітування;
-    обробка тривог пов'язаних безпосередньо з ПЛК (наприклад, перевищений час періоду циклу)
-    генерування інтервальних бітових імпульсів, меандрів;
-    ведення статистичних даних (за необхідності);
-    розрахунок інтегральних показників, в т.ч. загальний час роботи з останнього пуску, загальний час роботи з першого пуску, час останньої зупинки/пуску ПЛК і т.п.
-    формування загальних технологічних повідомлень оператору;
-    отримання широкомовних команд для інших об'єктів 

Клас PLC теоретично можна віднести до CM LVL2, але відокремлюється від нього у описі у зв'язку з його базовим положенням відносно реалізації інших класів в каркасі.  

## Рекомендації щодо використання в HMI

Рекомендується реалізувати компонент для відображення бітів стану. Приклад індикації стану ПЛК показаний на рис.1. 

У даному випадку:

- М – це наявність хоча б одного виконавчого механізму в ручному режимі, темно-синій 
- F – наявність хоча б одного форсування, темно-синій
- S – наявність хоча б одного об'єкта (CM/EM/UNIT) в режимі імітації, блакитний 
- W – наявність хоча б однієї тривоги рівня "попередження" (моргає при неквітованій), жовтий 
- A – наявність хоча б однієї тривоги рівня "аварія" (моргає при неквітованій), червоний. 
- E – наявність хоча б однієї тривоги рівня "недостовірність" (моргає при неквітованій), рожевий. 

Додатково також варто під статусами тривоги показувати 

- кількість тривог кожного рівня

- кількість форсувань

Додатковими бітами статусу для відображення також можуть бути: 

- наявність хоча б одного біта недостовірності, 
- наявність хоча б однієї відключеної змінної (виведеної з обслуговування), 
- "процедура технологічної комірки в роботі/паузі/утримання", 
- "апарат в роботі/паузі/утримання", 
- "CIP в роботі/паузі/утримання".

За можливості варто використати стан тривоги (відображення червоним) `STP` - "ПЛК у стопі".

![Приклад індикації стану ПЛК](media/2_11.png)

_рис.1. Приклад індикації стану ПЛК_

Слід звернути увагу, що біти стану `STA` та тривог `ALM1`, `ALM2` скидаються у функції `PLC_FN`. Для забезпечення доступу до стану ПЛК та тривог у будь який момент часу а не тільки між викликами задач рекомендується використовувати  поля `STA_PERM` та `ALM1_PERM`.

## Функція PLCFN

### Функціональні вимоги 

Функція обробки PLCFN обробляє обов'язкові загальні контролерні дії.  

- підтвердження широкомовних команд (пропускає через себе широкомовну команду на один цикл)
- фіксує перший скан задачі - на один цикл виставляє відповідний біт в 1 при першому скані
- реалізовує бітові імпульси та меандри (див. CFG) які можуть використовуватися в тій же задачі (TASK) де запускається функція
- веде загальний час з початку 1-го циклу контролера (в секундах)
- веде загальний час роботи ПЛК з моменту пуску (в хвилинах)
- показує астрономічний час в форматі BCD
- показує початок години, доби, 
- показує початок зміни (за замовчування 8-годинна зміна)
- скидає біти тривог та деякі статусні біти, які "збираються" по всьому циклу від процедурного та базового керування (див. PLC_CFG)
- скидає лічильники тривог і деяких статусних слів 
- показує плинний (останній час задачі і максимальний в мс)

Функція обробки PLCFN може також обробляти наступні загальні контролерні дії.  

- формування інших меандрів
- керування загальною звуковою сигналізацією
- ведення додаткової загальної статистики
- контроль (керування сигналізацією) обміну з іншими/іншими ПЛК
- контроль (керування сигналізацією) обміну з DIO (розподілена периферія) 

### Вимоги щодо реалізації інтерфейсу

Може бути реалізована як функція, або функціональний блок (за необхідності збереження проміжних даних). На вході INOUT вона приймає аргумент `PLC_CFG`, може додатково приймати `PLC_HMI` за необхідності. 

Як правило для PLC достатньо одного екземпляру `PLCFN` і можна обійтися тільки однією структурою `PLC_CFG`. Однак з метою зменшення навантаження на комунікацію і забезпечення командного вводу параметрів (коли оператор спочатку змінює конфігуровані значення в буфер а потім записує їх в змінну) можна виділити змінні `PLC_HMI` та `PLC_BUF`. У каркасі це не описується правилами.

Для бітових представлень рекомендується використовувати `INT` замість `UINT`. У платформі UNITY/CotrolExpert тільки до INT можна звертатися до бітів через крапку. У TIA WinCC тільки INT може використовуватися для тривог. 

### Вимоги щодо реалізації програми користувача

На будь якій мові програмування. 

### Вимоги щодо використання

**Функція обробки PLCFN повинна запускатися на початку основної задачі.** Це необхідно для правильної обробки бітів статусу та тривог. Тому за необхідності використання структури в інших задачах, необхідно чітко зважити усі механізми. На практиці це інколи забувається, і приводить до небажаних наслідків. 

```pascal
PLCFN (PLC_CFG);
```

Додатково може знадобитися:

- конфігурування системних бітів для першого скану, меандрів тощо
- добавлення додаткових параметрів до інтерфейсу (наприклад PLC_HMI, PLC_BUF)

**Робота функції передбачає виконання усіх інших функцій каркасу в тому самому циклі задачі!**

## Структура та змінна PLC_CFG

### Опис структури

Наведена нижче структура адаптована під імпорт в формат CSV з урахуванням можливості подальшого перетворення у зручний для платформи формат:

name - ім'я параметру

type - тип параметру

adr - зміщення відповідно до початку структури (в 16-бітних словах)

bit - номер біта в 16-бітній структурі

descr - опис 

| name        | type               | adr  | bit  | descr                                                        |
| ----------- | ------------------ | ---- | ---- | ------------------------------------------------------------ |
| ID          | UINT               | 0    |      | Унікальний ідентифікатор, наприклад для ідентифікації PLC    |
| CLSID       | UINT               | 1    |      | 16#21xx                                                      |
| STA         | UINT               | 2    |      | Може бути набір біт типу PLC_STA                             |
| ACON2ERR    | BOOL               | 2    | 0    | =1 - є помилка звязку з сусідні ПЛК в парі (для теплого резерування) |
| APLC2STOP   | BOOL               | 2    | 1    | =1 - спарений ПЛК в стопі (для теплого резерування)          |
| BLK         | BOOL               | 2    | 2    | =1 – є хоча б один заблокований ВМ                           |
| ALDIS       | BOOL               | 2    | 3    | =1 – є хоча б одна відключена тривога                        |
| DIOON       | BOOL               | 2    | 4    | =1 - йде опитування по мережі (MODBUS або аналогічній) засобів віддаленого вводу/виводу |
| DIOERR      | BOOL               | 2    | 5    | =1 - є помилка на DIO                                        |
| DBLCKALL    | BOOL               | 2    | 6    | =1 - усі приводи розблоковані                                |
| FRC         | BOOL               | 2    | 7    | =1 – хоча б одна змінна форсована (або ручний режим) на будь якому рівні |
| SMLALL      | BOOL               | 2    | 8    | =1 – все в режимі в імітації, примушує усі CM перейти в режим імітації |
| DISP        | BOOL               | 2    | 9    | =1 – хоча б один елемент в режимі ручного управління         |
| FRC2        | BOOL               | 2    | 10   | =1 – є хоча б один форсований керівний елемент (рівня 2), клапан, двигун |
| FRC1        | BOOL               | 2    | 11   | =1 – хоча б одна змінна форсована (рівня 1)                  |
| SCN1        | BOOL               | 2    | 12   | =1 – перший скан                                             |
| FRC0        | BOOL               | 2    | 13   | =1 – хоча б одна змінна форсована (рівня 0)                  |
| SML         | BOOL               | 2    | 14   | =1 – хоча б один об’єкт в режимі імітації                    |
| CMDACK      | BOOL               | 2    | 15   | =0 - підтвердження команди, команда пройшла через весь цикл задачі і отримана усіма |
| CMD         | UINT               | 3    |      | Команди з HMI:16#0100 – прочитати конфігурацію;16#0101 – записати конфігурацію; 16#301 - включити режим деблокування усіх ВМ; 16#302 - відключити режим деблокування усіх ВМ;  16#300 - перемкнути режим деблокування усіх ВМ;      16#0111 – синхронізувати час з верхнім рівнем; 16#0301 – вимкнути сирену; 16#0302 – увімкнути сирену; 16#4101 – записати конфігурація за замовченням для усіх змінних DIVAR; 16#4102 – записати конфігурація за замовченням для усіх змінних AIVAR; 16#4103 – записати конфігурація за замовченням для усіх змінних DOVAR; 16#4104 – записати конфігурація за замовченням для усіх змінних AOVAR;16#4301 – форсувати всі об'єкти LVL0; 16#4302 – дефорсувати всі об'єкти LVL0;16#4303 – форсувати всі об'єкти LVL1;16#4304 – дефорсувати всі об'єкти LVL1 |
| CMDPRG      | UINT               | 4    |      | Команди з програмного керування (побітові)                   |
| PRM1        | UINT               | 5    |      | дискретні параметри (проектно залежні)                       |
| PRM2        | UINT               | 6    |      | дискретні параметри (проектно залежні)                       |
| PLS         | UINT               | 7    |      | Може бути набір біт типу PLS                                 |
| P100MS      | BOOL               | 7    | 0    | імпульс на один цикл основної задачі з періодичністю 100 мс (адекватно працюватиме тільки для циклів <50ms) |
| P200MS      | BOOL               | 7    | 1    | 200 мс (адекватно працюватиме тільки для циклів <100ms)      |
| P500MS      | BOOL               | 7    | 2    | 500 мс (адекватно працюватиме тільки для циклів <250ms)      |
| P1S         | BOOL               | 7    | 3    | 1 с                                                          |
| P2S         | BOOL               | 7    | 4    | 2 с                                                          |
| P5S         | BOOL               | 7    | 5    | 5 с                                                          |
| P10S        | BOOL               | 7    | 6    | 10 с                                                         |
| P60S        | BOOL               | 7    | 7    | 1 хв                                                         |
| M1S         | BOOL               | 7    | 8    | меандр з періодом 1 с (0.5 с + 0.5 с)                        |
| M2S         | BOOL               | 7    | 9    | меандр з періодом 2 с (1 с + 1 с)                            |
| plsb10      | BOOL               | 7    | 10   | резерв                                                       |
| plsb11      | BOOL               | 7    | 11   | резерв                                                       |
| NEWMIN      | BOOL               | 7    | 12   | =1 (на один цикл основної задачі) – початок хвилини          |
| NEWHR       | BOOL               | 7    | 13   | =1 (на один цикл основної задачі) – початок години           |
| NEWDAY      | BOOL               | 7    | 14   | =1 (на один цикл основної задачі) – початок доби             |
| NEWSHIFT    | BOOL               | 7    | 15   | =1 (на один цикл основної задачі) – початок зміни            |
| ALM1        | INT                | 8    |      | Може бути типу PLC_ALM1                                      |
| ALM         | BOOL               | 8    | 0    | =1, є хоча б одна тривога аварійного рівня                   |
| NWALM       | BOOL               | 8    | 1    | =1, нова тривога аварійного рівня                            |
| ALMNACK     | BOOL               | 8    | 2    | =1, є неквітовані тривоги                                    |
| WRN         | BOOL               | 8    | 3    | =1, є хоча б одна тривога попереджувального рівня            |
| NWWRN       | BOOL               | 8    | 4    | =1, нова тривога попереджувального рівня                     |
| WRNNACK     | BOOL               | 8    | 5    | =1, є неквітовані попередження                               |
| BAD         | BOOL               | 8    | 6    | =1, є хоча б одна тривога недостовірності                    |
| NWBAD       | BOOL               | 8    | 7    | =1, нова тривога недостовірності                             |
| BADNACK     | BOOL               | 8    | 8    | =1, є неквітовані тривоги недостовірності                    |
| EMCYSTP     | BOOL               | 8    | 9    | =1, аварійний зупин (грибок)                                 |
| STP2RUN     | BOOL               | 8    | 10   | =1, момент переходу з аварійного зупину в роботу             |
| CON2ERR     | BOOL               | 8    | 11   | =1 - є помилка звязку з сусідні ПЛК в парі (для теплого резерування) |
| PLC2STOP    | BOOL               | 8    | 12   | =1 - спарений ПЛК в стопі (для теплого резерування)          |
| DIOERR      | BOOL               | 8    | 13   | =1 - є помилка DIO                                           |
| PLCERR      | BOOL               | 8    | 14   | =1 – є апаратна помилка (ПЛК)                                |
| CONHIERR    | BOOL               | 8    | 15   | =1 - є помилка звязку з верхним рівнем (ПЛК)                 |
| ALM2        | INT                | 9    |      | використовується за необхідності                             |
| STEP1       | INT                | 10   |      | крок основної програми                                       |
| T_STEP1     | INT                | 11   |      | час кроку основної програми обробки, в (с)                   |
| MSG         | UDINT              | 12   |      | для формування повідомлень, може бути як бітовим (32 повідомлення), так і числовим (за номером); передбачається, що повідомлення буде скидуватися в 0 автоматично через певний час (не менш ніж 2 інтервали опитування з HMI) |
| TQ          | UDINT              | 14   |      | загальний час з початку 1-го циклу контролера (в секундах)   |
| TQM         | UDINT              | 16   |      | загальний час роботи ПЛК з моменту пуску (в хвилинах), потребує збереження в Retentive |
| DICNT       | UINT               | 18   |      | кількість наявних каналів DI                                 |
| DOCNT       | UINT               | 19   |      | кількість наявних каналів DO                                 |
| AICNT       | UINT               | 20   |      | кількість наявних каналів AI                                 |
| AOCNT       | UINT               | 21   |      | кількість наявних каналів AO                                 |
| NOW         | ARRAY[0..3] of INT | 22   |      | плинний час астрономічний час в BCD форматі: NOW[0] seconds,-- (16#ss,--);NOW[1] hour, minute (16#hhmm);NOW[2] month, day (16#mmdd); NOW[3] year (16#yyyy) |
| SHIFTPARA   | ARRAY[0..3] of INT | 26   |      | Години передачі змін (2 або 3 зміни):SHIFT[0] – кількість змін; SHIFT[1] – передача 1-ї зміни (BCD 16#hhmm); SHIFT[2] – передача 2-ї зміни (BCD 16#hhmm); SHIFT[3] – передача 3-ї зміни (BCD 16#hhmm) |
| SHIFTNMB    | UINT               | 30   |      | номер активної зміни                                         |
| CNTALM      | UINT               | 31   |      | лічильник кількості активних тривог "аварія"                 |
| CNTWRN      | UINT               | 32   |      | лічильник кількості активних тривог "попередження"           |
| CNTBAD      | UINT               | 33   |      | лічильник кількості активних тривог "недостовірність"        |
| CNTFRC      | UINT               | 34   |      | лічильник кількості форсованих об'єктів                      |
| CNTMAN      | UINT               | 35   |      | лічильник кількості ВМ в ручному режимі                      |
| TSK_LTIME   | UINT               | 36   |      | плинний (останній) час задачі в мілісекундах                 |
| TSK_MAXTIME | UINT               | 37   |      | максимальний час задачі в мілісекундах                       |
| STA_PERM    | UINT               | 38   |      | повторює STA, який був на початку виклику функції            |
| ALM1_PERM   | UINT               | 39   |      | повторює ALM1, який був на початку виклику функції           |
| CNTALM_PERM | UINT               | 40   |      | кількість активних тривог "аварія"                           |
| CNTWRN_PERM | UINT               | 41   |      | кількість активних тривог "попередження"                     |
| CNTBAD_PERM | UINT               | 42   |      | кількість активних тривог "недостовірність"                  |
| CNTFRC_PERM | UINT               | 43   |      | кількість форсованих об'єктів                                |
| CNTMAN_PERM | UINT               | 44   |      | кількість ВМ в ручному режимі                                |
| MODULSCNT   | INT                | 45   |      | кількість модулів                                            |
| NOWns       | UDINT              | 46   |      | нс (наносекунди) для плинного астрономічного часу            |
| TQMS        | UDINT              | 48   |      | мілісекундний лічильник, скидається при старті або після переповнення |

### Використання змінних типу PLC_CFG

Для кожного ПЛК створюється по одній змінній типу PLC_CFG. Вона використовується в якості аргументу для усіх функцій та функціональних блоків, які реалізовують процедурне та базове керування. Якщо з функції або ФБ з середини дозволяється викликати глобальні дані, для покращення читабельності можна в інтерфейс цих функцій змінну не включати.   

PLC_CFG можна використовувати в розподіленому керуванні (декілька ПЛК) для обміну між ПЛК їх загальним статусом/командами, що може спростити їх координацію. У такому випадку, наявність буферних змінних і унікального ID може бути використано для конфігурування/контролю декількох ПЛК з одного HMI, через ПЛК-проксі. Так, наприклад, змінна TQ може бути використана для контролю за станом ПЛК або зв'язку з ним, адже якщо ця змінна не змінюється протягом тривалого часу, цей ПЛК знаходиться в стопі або недоступний (щось на кшталт heart_beat).

Деякі біти полів STA, та усі біти ALM1, ALM2 скидаються на початку задачі функцією PLCFN. Це зроблено для того, щоб будь який з CM/EM/Unit міг виставити біт в 1, тим самим сигналізуючи про твердження "хоча б один".

Поле MSG – може бути використано для формування повідомлень оператору, на кшталт – не можу виконати команду. Таке поле може бути і в інших структурах CM/EM/UNIT, тоді воно повинно бути в структурі HMI. Як варіант економії ресурсів може бути одне поле MSG на всі повідомлення. Якщо це поле буде бітовим, то повідомлення не будуть перекриватися, однак їх кількість буде обмежено 32 на весь ПЛК. Тим не менше, кількість полів MSG можна збільшувати до необхідного. Враховуючи, що повідомлення формуються по тригеру, їх необхідно "очищувати", що може бути зроблено за таймером або з самого HMI, як приймача повідомлення (наприклад додатковою командою ACKMSG – прийняв повідомлення). Механізми очищення виробляються для конкретного випадку.

## Тестування PLCFN 

Цей пункт описує методику перевірки функції PLCFN в ручному та/або автоматизованому режимі. 

### Перелік тестів

| Номер | Назва                                                        | Коли перевіряти                                              | Примітки |
| ----- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1     | перший скан                                                  | після реалізації функції                                     |          |
| 2     | астрономічний час                                            | після реалізації функції                                     |          |
| 3     | лічильники роботи ПЛК: загальний і зі старту                 | після реалізації функції                                     |          |
| 4     | бітові імпульси                                              | після реалізації функції, у кінці проекту на реальному ПК, щоб перевірити адекватність |          |
| 5     | бітові меандри                                               | після реалізації функції, у кінці проекту на реальному ПК, щоб перевірити адекватність |          |
| 6     | імпульси початку години, доби                                | після реалізації функції                                     |          |
| 7     | скидування бітів статусів та лічильників тривог, статусів та збереження їх в змінних `_PERM` | після розгортання базових обєктів каркасу LVL0-LVL2          |          |
| 8     | зміни: номер активної зміни, початок зміни                   | після реалізації функції                                     |          |
| 9     | відображення мінімального та максимального часу циклу        | після реалізації функції                                     |          |
| 10    | обнулення команд через один цикл                             | після реалізації функції                                     |          |

### 1 Тест першого скану

- перед запуском перевірки ПЛК повинен бути в СТОП
- перед викликом функції PLCFN повинна інкрементуватися змінна-лічильник циклів `TST_CCLS`, яка перед запуском ПЛК, повинна =0
- після виклику функції PLCFN при умові, що біт SCN1=TRUE:
  - збільшувати змінну `TST_SCN1CLC` (кількість викликів "першого циклу") на 1 
  - присвоїти змінній `TST_NBCLC := TST_CCLS` (останній номер циклу при спрацюванні біта першого циклу)

```pascal
TST_CCLS := TST_CCLS + 1;
PLCFN(PLC);
if PLC.SCN1 then
   TST_SCN1CLC := TST_SCN1CLC + 1;
   TST_NBCLC := TST_CCLS;
end_if;
```

- після запуску ПЛК `TST_CCLS` повинен збільшуватися, а  `TST_SCN1CLC=1`, `TST_NBCLC=1`

| Крок | дія для перевірки                       | результат                                         |
| ---- | --------------------------------------- | ------------------------------------------------- |
| 1    | обнулити тестові змінні за необхідності |                                                   |
| 2    | запустити ПЛК (імітатор)                |                                                   |
| 3    | перевірити змінні                       | TST_CCLS збільшується, TST_SCN1CLC=1, TST_NBCLC=1 |

### 2 Тест астрономічного часу

Перевіряється рівність дати часу відповідним полям структури NOW у форматі BCD.

### 3 Тест лічильників роботи ПЛК

Лічильник `TQM` не повинен обнулятися при перезапуску ПЛК, а `TQ` повинен. Реалізація `TQM` потребує збереження її в енергонезалежній пам'яті без обнулення при запуску. 

Загальна методика передбачає запуск ПЛК, перевірку `TQ` та `TQM` через кілька хвилин роботи. `TQ` повинен збільшуватися з кожною секундою, `TQM` з кожною хвилиною (або на початку хвилини, це не особиво впливає на точність). При зупинці і запуску ПЛК, лічильник `TQ` має обнулитися і запуститися заново. `TQM` повинен продовжити рахувати з того самого значення. 

Точність `TQ` перевіряється астрономічним годинником. 

Перевіряється чи час циклу дорівнює різниці часів реального часу між двома викликами.

### 4 Тест бітових імпульсів

- Перевіряється робота бітових імпульсів `P100MS`, `P200MS`, `P500MS`, `P1S`, `P2S`, `P5S`, `P10S`, `P60S`. Імпульси повинні спрацьовувати на один цикл з вказаною періодичністю. Враховуючи прив'язаність до обладнання коректність роботи може гарантуватися тільки на реальному залізі.
- Повторну перевірку варто робити  після реалізації всієї програми користувача, так як об'єм програми впливає на час циклу.   

- Для кожного імпульсу вводиться по одному тестовому лічильнику `TST_P100MS`, `TST_P200MS`, `TST_P500MS`, `TST_P1S`, `TST_P2S`, `TST_P5S`, `TST_P10S`, `TST_P60S`. Також вводиться додаткова змінна `TST_PLSON`, яка забезпечує інтервал тестування. Дана змінна включається для запуску тестування і відключається автоматично при зупинці тестування. 


- Для тестування використовується змінна `TQ` як показник часу. Але точніше буде використовувати системний час. Перевіряється проходження 121 с. Оцінюється приблизна кількість спрацювань з урахуванням похибки.


Якщо кількість імпульсів відрізняється від показника в таблиці, наведеній нижче:

- перевірити правильність реалізації
- якщо реалізація правильна, то очевидно час циклу більше за 2 інтервали бітового імпульсу, треба оцінювати доцільність використання цих бітів в програмі користувача або перевіряти їх на реальному ПЛК (якщо був використаний до цього імітатор)    

Таблиця. Тестові показники для бітових імпульсів.

| Лічильник  | Значення (може відрізнятися) |
| ---------- | ---------------------------- |
| TST_P100MS | 1210                         |
| TST_P200MS | 605                          |
| TST_P500MS | 240                          |
| TST_P1S    | 120-121                      |
| TST_P2S    | 60                           |
| TST_P5S    | 24                           |
| TST_P10S   | 12                           |
| TST_P60S   | 2                            |

```pascal
PLCFN(PLC);
if TST_PLSON then
  if PLC.P100MS then TST_P100MS := TST_P100MS+1; end_if; 
  if PLC.P200MS then TST_P200MS := TST_P200MS +1; end_if;
  if PLC.P500MS then TST_P500MS := TST_P500MS +1; end_if;
  if PLC.P1S then TST_P1S := TST_P1S +1; end_if;
  if PLC.P2S then TST_P2S := TST_P2S +1; end_if;
  if PLC.P5S then TST_P5S := TST_P5S + 1; end_if;
  if PLC.P10S then TST_P10S := TST_P10S + 1; end_if;
  if PLC.P60S then TST_P60S := TST_P60S + 1; end_if;
  if PLC.TQ-TEST_TQPREV>=121 then 
     TST_PLSON:=false;
  end_if; 
else 
  TEST_TQPREV := PLC.TQ;
end_if;
```

| Крок | дія для перевірки                                       | результат                                               |
| ---- | ------------------------------------------------------- | ------------------------------------------------------- |
| 1    | обнулити тестові змінні за необхідності                 |                                                         |
| 2    | запустити ПЛК (імітатор), виставити  `TST_PLSON:=TRUE;` |                                                         |
| 3    | перевірити змінні                                       | результат повинен бути як в таблиці тестових показників |

### 5 Тест бітових меандрів

Перевіряються бітові меандри `M1S` та `M2S`. Найпростіше їх перевірити візуально. Їх призначення виключно для локальних засобів ЛМІ (наприклад лампи), тому візуальна перевірка є достатньою.

### 6 Тест імпульсів початку години та доби

Цей тест потребує зміни значення часу в ПЛК або імітаторі.

Перевірка зміни години `NEWHR` перевіряється на першій хвилині (спрацьовує один раз на першій хвилині), доби `NEWDAY` - на першій хвилині першої години доби (спрацьовує один раз на першій хвилині). 

Змінна `TST_CHHRCNT` збільшується на 1 при зміні години, `TST_CHDAYCNT` при зміні доби.

### 7 Тест скидування бітів статусів та лічильників тривог і статусів

Усі біти тривог а також біти статусів повинні бути обнулені після виклику функції. Змінні "_PERM" (`STA_PERM` та `ALM1_PERM`) зберігають значення до наступного виклику функції.

Усі лічильники повинні бути скинуті.

### 8 Перевірка зміни

Перевірка на адекватну поведінку, якщо кількість змін `SHIFT[0]` буде некоректною.

Перевірити переключення на кожну зміну.

### 9 Тест відображення мінімального та максимального часу циклу

Перевірити співпадіння мінімального та максимального значення часу задачі

### 10 Обнулення команд через один цикл

 Перевірити проходження команд принаймні протягом одного циклу. Це потрібно для відловлення широкомовних команд. 

Після виклику функції вставляється лічильник коли `PLC.CMD<>0`. Якщо лічильник збільшується на 1 після кожного виклику команди - все нормально. 

## Реалізація мультизадачності 

to do

Наразі не реалізовано.

Примітки:

•	добавити окремі контексти для кожної задачі (див структуру в верху)
 •	в усі об’єкти добавити змінну TASK – номер задачі, до якого він прив’язаний
 •	у випадку одної задачі – всю послідовність винести в TASK, яку викликати в MAST (UNITY PRO??????)
 •	в кожну функцію передавати номер задачі
 •	на початку кожної функції перевіряти чи задача до її екземпляру (по параметру TASK), якщо ні – вихід з виконання
 •	передача номеру задачі знизу-догори  CHCFG.TASK -> VARCFG.TASK -> LVL2.TASK
 •	для LVL3 означується в програмі при розробці

#### TASK

| Атрибут      | Тип      | Біт  | Опис                                           |
| ------------ | -------- | ---- | ---------------------------------------------- |
| ID           | UINT     |      | Унікальний ідентифікатор                       |
| CLSID        | UINT     |      |                                                |
| STA[0..7]    | UINT     |      |                                                |
| PLS[0..7]    | INT      |      |                                                |
| ALM[0..7]    | INT      |      |                                                |
| ALM2[0..7]   | INT      |      |                                                |
| T_SCAN[0..7] | UDINT    |      | час останньої обробки задачі                   |
| T_MIN[0..7]  | UDINT    |      | час останньої обробки задачі                   |
| T_MAX[0..7]  | UDINT    |      | час останньої обробки задачі                   |
| T_PREV[0..7] | UDINT??? |      | час попереднього виклику задачі ??? реалізація |
| REZ          | INT      |      | резерв                                         |

