# Клас CHAI (аналоговий вхідний канал)

## Класи

Загальний шаблон для усіх класів **CLSID=16#003x**. Рекомендується наступні значення класів:  

- 16#0030 (48) - загальний клас без означення типу сигналу
- 16#0031 (49) - 4..20 mA
- 16#0032 (50) - 0..20 mA
- 16#0033 (51) - 0..10 V
- 16#0034 (52) - термометр опору (без означення типу)
- 16#0035 (53) - термопара (без означення типу) 

Інші класи задаються при необхідності.

## Загальний опис

Реалізує функцію роботи з фізичним дискретним входом на локальному ПЛК або розподіленому засобі вводу/виводу.

Структура змінних CH_CFG та CH_HMI наведена в [структурі класів ](2_lvl0.md)

## Функція CHAIFN

### Функціональні вимоги 

- Загальні функціональні вимоги описані у вимогах до [класів LVL0 ](2_lvl0.md).
- Функція повинна передбачати значення MIN та MAX для можливості простого керування при форсованому значенні. Розділення на MIN та MAX можуть визначатися підкласом CHAIFN.

### Вимоги щодо реалізації інтерфейсу

Вимоги описані щодо реалізації інтерфейсу описані у вимогах до [класів LVL0 ](2_lvl0.md)

### Вимоги щодо реалізації програми користувача

Приклад TIA portal

```pascal
//робота з буфером IOT
"CHIOTFN"(CHCFG:=#CHCFG, RAWINT:=#tmp);

#STA := #CHCFG.STA;
#CMD := #CHCFG.CMD;
(*розпаковка з STA*)
#VRAW := #STA.VRAW;
#VAL := #STA.VALB;
#BAD := #STA.BAD;(*керується ззовні*)
#PNG := #STA.PNG;
#ULNK := #STA.ULNK;
#MERR := #STA.MERR;(*керується ззовні*)
#BRK := #STA.BRK;(*керується ззовні*)
#SHRT := #STA.SHRT;(*керується ззовні*)
#NBD := #STA.NBD;(*керується ззовні*)
#INBUF := #STA.INBUF;
#FRC := #STA.FRC;
#SML := #STA.SML;
#CMDLOAD := #STA.CMDLOAD; (*керується бітом*)
#INBUF := (#CHCFG.ID = "BUF".CHBUF.ID) AND (#CHCFG.CLSID = "BUF".CHBUF.CLSID);
#CMDLOAD := #CHHMI.STA.%X15;
#CMD := 0;

(* обробник команд*)
(* широкомовне форсування/дефорсування*) 
IF "SYS".PLCCFG.CMD=16#4301 THEN
    #FRC := true; (*форсувати один/усі об'єкти типу*)
END_IF;
IF "SYS".PLCCFG.CMD=16#4302 THEN
    #FRC := false; (*дефорсувати об'єкт типу*)
END_IF;

(*вибір джерела команди згідно пріоритету*)
IF #CMDLOAD THEN (*з HMI CMDLOAD*)
    #CMD := 16#0100;  // записати в буфер
ELSIF #INBUF AND "BUF".CHBUF.CMD <> 0 THEN (*з буферу*)
    #CMD := "BUF".CHBUF.CMD;
ELSIF #CHCFG.CMD<>0 THEN
    #CMD := #CHCFG.CMD;
END_IF;

(*commands*)
CASE #CMD OF
    16#0001: (*записати MAX*)
        IF #FRC AND #INBUF THEN
            "BUF".CHBUF.VAL := #MAX;
        END_IF;
    16#0002: (*записати MIN*)
        IF #FRC AND #INBUF THEN
            "BUF".CHBUF.VAL:=#MIN;
        END_IF;
    16#0003: (*виставлення половини з діапазону*)
        IF #FRC AND #INBUF THEN
            "BUF".CHBUF.VAL := #MIDLE;
        END_IF;
    16#0100: (*прочитати конфігурацію в буфер*)
        "BUF".CHBUF.ID:= #CHCFG.ID;
        "BUF".CHBUF.CLSID:=#CHCFG.CLSID;
        
        "BUF".CHBUF.STA.%X0 := #CHCFG.STA.VRAW;
        "BUF".CHBUF.STA.%X1 := #CHCFG.STA.VALB;
        "BUF".CHBUF.STA.%X2 := #CHCFG.STA.BAD;
        "BUF".CHBUF.STA.%X3 := #CHCFG.STA.b3;
        "BUF".CHBUF.STA.%X4 := #CHCFG.STA.PNG;
        "BUF".CHBUF.STA.%X5 := #CHCFG.STA.ULNK;
        "BUF".CHBUF.STA.%X6 := #CHCFG.STA.MERR;
        "BUF".CHBUF.STA.%X7 := #CHCFG.STA.BRK;
        "BUF".CHBUF.STA.%X8 := #CHCFG.STA.SHRT;
        "BUF".CHBUF.STA.%X9 := #CHCFG.STA.NBD;
        "BUF".CHBUF.STA.%X10 := #CHCFG.STA.b10;
        "BUF".CHBUF.STA.%X11 := #CHCFG.STA.INIOTBUF;
        "BUF".CHBUF.STA.%X12 := #CHCFG.STA.INBUF;
        "BUF".CHBUF.STA.%X13 := #CHCFG.STA.FRC;
        "BUF".CHBUF.STA.%X14 := #CHCFG.STA.SML;
        "BUF".CHBUF.STA.%X15 := #CHCFG.STA.CMDLOAD;
        
        "BUF".CHBUF.VAL:=#CHCFG.VAL;
        "BUF".CHBUF.VARID:=#CHCFG.VARID;
    16#0300: (*перемкнути форсування*)
        #FRC := NOT #FRC;
    16#0301: (*ввімкнути форсування*)
        #FRC := true;
    16#0302: (*вимкнути форсування*)
        #FRC := false;
END_CASE;

(*запис значення змінної*)
IF #FRC AND #INBUF THEN (*режим форсування з занятим буфером*)
    #CHCFG.VAL := "BUF".CHBUF.VAL;
ELSIF #FRC AND NOT #INBUF THEN (*режим форсування без занятого буферу*)
    ;(*без змін*)
ELSIF NOT #FRC THEN (*не режим форсування*)
    #CHCFG.VAL  := #RAWINT;
END_IF;

(*ping-pong*)
#ULNK := #PNG; (*прийшов ping - є звязок з верхнім рівнем*)
#PNG := false; (*скидання біту PNG звязку з врехнім рівнем PONG*)
IF NOT #ULNK THEN
    #CHCFG.VARID := 0;
END_IF;

(*скидання оброблених команд*)
#CMDLOAD := 0;
#CMD := 0;

(*загальносистемні біти та лічильники*)
IF #FRC THEN
    "SYS".PLCCFG.STA.FRC0 := true;
    "SYS".PLCCFG.CNTFRC := "SYS".PLCCFG.CNTFRC + 1;
END_IF;

#BAD:= #BRK OR #SHRT;

(*упковка в STA*)
#STA.VRAW := #RAWINT>0;
#STA.VALB:=#CHCFG.VAL>0;
#STA.BAD:=#BAD;(*керується ззовні*)
#STA.PNG:=#PNG;
#STA.ULNK:=#ULNK;
#STA.MERR:=#MERR;(*керується ззовні*)
#STA.BRK:=#BRK;(*керується ззовні*)
#STA.SHRT:=#SHRT;(*керується ззовні*)
#STA.NBD:=#NBD;(*керується ззовні*)
#STA.INBUF := #INBUF;
#STA.FRC := #FRC;
#STA.SML := #SML;
#STA.CMDLOAD := #CMDLOAD; (*керується бітом*)

#CHCFG.STA := #STA;
#CHCFG.CMD := #CMD;

(*упаковка в INT*)
#STAINT.%X0 := #VRAW;
#STAINT.%X1 := #VAL;
#STAINT.%X2 := #BAD;
//#STAINT.%X3 := #b3;
#STAINT.%X4 := #PNG;
#STAINT.%X5 := #ULNK;
#STAINT.%X6 := #MERR;
#STAINT.%X7 := #BRK;
#STAINT.%X8 := #SHRT;
#STAINT.%X9 := #NBD;
//#STAINT.%X10 := #b10;
#STAINT.%X11 := #STA.INIOTBUF;
#STAINT.%X12 := #INBUF;
#STAINT.%X13 := #FRC;
#STAINT.%X14 := #SML;
#STAINT.%X15 := FALSE;

#CHHMI.STA := #STAINT;
#CHHMI.VAL := #CHCFG.VAL;

(*оновлення буферу*)
IF #INBUF THEN
    "BUF".CHBUF.STA:= #STAINT;
    "BUF".CHBUF.VARID := #CHCFG.VARID;
    "BUF".CHBUF.CMD := 0;
    IF NOT #FRC THEN
        "BUF".CHBUF.VAL := #CHCFG.VAL;
    END_IF;
END_IF;
```



### Вимоги щодо використання

Використовуються перед викликом VAR. 

## Тестування CHAIFN

Цей пункт описує методику перевірки особливих функцій CHAIFN. Інші тести описані в  [описі класу LVL0 ](2_lvl0.md)

### Перелік тестів

Перелік наведений  [в описі класу LVL0 ](2_lvl0.md)

### 1   Присвоєння ID та CLSID при старті

- перед запуском перевірки ПЛК повинен бути в СТОП
- після запуску усім каналам, використаним в програмі повинні бути присвоєні ID та CLSID

### 2   Команди прив'язування до буферу

| Номер кроку | Дія для перевірки                                           | Очікуваний результат                                         | Примітки |
| ----------- | ----------------------------------------------------------- | ------------------------------------------------------------ | -------- |
| 1           | змінити STA.X15=1 для однієї зі змінних CH_HMI              | у CHBUF повинно завантажитися весь зміст CH_CFG<br />для CH_HMI повинен STA.X15 = 0 <br />для CH_HMI, CH_CFG та CH_BUF повине STA.12(INBUF)=1 |          |
| 2           | змінити значення змінної (наприклад для DICH - вхідної RAW) | відповідне значення зміниться у CH_HMI, CH_CFG та CH_BUF     |          |
| 3           | змінити STA.X15=1 для іншої змінної CH_HMI                  | у CHBUF повинно завантажитися весь зміст CH_CFG іншої змінної |          |
| 4           | повторити п.1 командою CH_CFG.CMD=16#100                    | у CHBUF повинно завантажитися весь зміст CH_CFG<br />для CH_HMI повинен STA.X15 = 0 <br />для CH_HMI, CH_CFG та CH_BUF повине STA.12(INBUF)=1<br /> змінна CH_CFG.CMD повинна обнулитись |          |

### 3 Робота в нефорсованому режимі

Перевірка значень повинно проходити як для CH_HMI, CH_CFG так і  CH_BUF

| Номер кроку | Дія для перевірки                                           | Очікуваний результат                                         | Примітки                              |
| ----------- | ----------------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------- |
| 1           | прив'язати тестову змінну до буферу                         | у CHBUF повинно завантажитися весь зміст CH_CFG              |                                       |
| 2           | змінити значення змінної (наприклад для DICH - вхідної RAW) | для CH_HMI, CH_CFG та CH_BUF повинне змінитися плинне значення змінної і значення сирої змінної (для `CHDI` і `CHDO`) | див деталі в тестах конкретного класу |
| 3           | повторити п.2 з іншим значенням                             |                                                              |                                       |

### 4 Робота в режимі форсування

Перевірка значень повинно проходити як для CH_HMI, CH_CFG так і  CH_BUF

| Номер кроку | Дія для перевірки                                            | Очікуваний результат                                         | Примітки                                                     |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1           | прив'язати тестову змінну до буферу                          | у CHBUF повинно завантажитися весь зміст CH_CFG              |                                                              |
| 2           | змінити значення вхідної величини на 0                       | значення повинно змінитися як в тесті 3                      | вхідна величина для DICH. AICH - `RAW` , для DOCH, AOCH - `VAL` |
| 3           | відправити команду форсування CHBUF.CMD=16#0301              | біт FRC повинен дорівнювати 1                                |                                                              |
| 4           | змінити значення вхідної величини                            | значення вихідної величини повинно залишитися без змін       | вхідна величина для DICH. AICH - `RAW` , для DOCH, AOCH - `VAL` |
| 5           | відправити команду 16#0001 (записати 1/MAX)                  | значення повинно змінитися на 1/MAX                          |                                                              |
| 6           | відправити команду 16#0002 (записати 0/MIN)                  | значення повинно змінитися на 0/MIN                          |                                                              |
| 7           | відправити команду 16#0003 (TOGGLE/виставлення половини з діапазону) | значення повинно змінитися на протилежне/записатися половина діапазону |                                                              |
| 8           | змінити значення `CHBUF.VAL`                                 | значення повинно змінитися на вказане                        | для дискретних, все що більше 0 дорвінює 1                   |
| 9           | відправити команду дефорсування CHBUF.CMD=16#0302            | біт FRC повинен дорівнювати 0                                |                                                              |
| 10          | відправити команду перемикання форсування 16#0300, повторити кілька разів, залишити в режимі форсування | біт FRC повинен перемкнутися на протилежне                   |                                                              |
| 11          | перевести в режим форсування кілька змінних                  | біт FRC відповідних змінних повинен дорівнювати 1            |                                                              |
| 12          | перевірити значення змінних PLC.STA_PERM і PLC.CNTFRC_PERM   | повинні PLC.STA_PERM.X13=1,  PLC.CNTFRC_PERM дорівнювати кількості зафорсованих змінних |                                                              |
| 13          | зняти з режиму форсування усі змінні                         | повинні PLC.STA_PERM.X13=0,  PLC.CNTFRC_PERM=0               |                                                              |

### 5 Перевірка ping-pong

- для запуску тесту використовується змінна, наприклад для `CHDI`  `TST_CHDIPNGON`
- номер каналу задається  `TST_CHDIPNGID`
- після виклику функцій обробника каналів застосовується виклик тестової функції, в якій йде зміна значення одного з `CH_CFG.PNG` 

```pascal
IF TST_CHDIPNGON THEN
    CHDI[TST_CHDIPNGID].STA.PNG := true;
    CHDI[TST_CHDIPNGID].VARID := TST_CHDIPNGID;
END_IF;
```

| Номер кроку | Дія для перевірки                                            | Очікуваний результат                                         | Примітки |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1           | записати якесь значення  в `CH_CFG.VARID`                    | повинно обнулитися, так як змінна не прив'язані              |          |
| 2           | задати значення `TST_CHDIPNGID` в межах існуючих каналів, задати `TST_CHDIPNGON=TRUE` | для вказаної змінної:`CH_CFG.VARID` повинен дорівнювати вказаному значенню, повинен `CH_CFG.ULNK=TRUE` |          |
| 3           | змінити значення `TST_CHDIPNGID` в межах існуючих каналів, задати `TST_CHDIPNGON=TRUE` | попередній канал повинен обнулити `CH_CFG.VARID` і`CH_CFG.ULNK` для вказаного каналу повинен бути результат як в кроці 2 |          |
| 4           | задати `TST_CHDIPNGON=false`                                 | попередній канал повинен обнулити `CH_CFG.VARID` і`CH_CFG.ULNK` |          |

### 6 Відправка широкомовних команд на форсування і дефорсування

| Номер кроку | Дія для перевірки                                            | Очікуваний результат                                         | Примітки |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
| 1           | відправити широкомовну команду на форсування усіх змінних PLC.CMD=16#4301 | біт FRC усіх змінних повинен дорівнювати 1, PLC.CNTFRC_PERM=кількості змінних |          |
| 2           | відправити широкомовну команду на дефорсування усіх змінних PLC.CMD=16#4302 | біт FRC усіх змінних повинен дорівнювати 0, PLC.CNTFRC_PERM=0 |          |
