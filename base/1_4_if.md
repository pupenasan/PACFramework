## 1.4 Загальні вимоги до реалізації інтерфейсу програмних блоків PAC Framework

### Структура інтерфейсу функцій/процедур та функціональних блоків

Кожна функція/процедура/ФБ що реалізовує CM, включає внутрішні дані про стан та інтерфейсні дані для інших підсистем (наприклад SCADA/HMI).

Інтерфейсні дані діляться на 2 типи:

-   дані реального часу (RT HMI)

-   конфігураційні дані (CFG)

Дані реального часу вміщують усю необхідну інформацію для постійного контролю стану CM та керування, в тому числі:

-   для відображення на HMI

-   для підсистем Alarm

-   для Trend та Log

-   для керування станом CM (у тому числі керування конфігурацією)

Конфігураційні дані вміщують (CFG) всю інформацію, необхідну для налаштування роботи CM. Обмін конфігураційними даним відбувається при:

-   налаштуванні/перевірки параметрів CM

-   поглибленої діагностики роботи CM

-   використання сервісних режимів роботи CM (форсування, імітація, виведення з обслуговування)

### Змінні HMI (HMI), конфігураційні (CFG) змінні та робота з буфером

За причини великої кількості конфігураційних даних їх трафік з іншими підсистемами бажано звести до мінімуму. Це зменшує завантаження на комунікації і зменшує вартість систем SCADA, що використовують ліцензування на базі кількості тегів. Для цього, обмін даними між SCADA/HMI та PLC конфігураційними даними можна реалізувати через проміжний буфер, спільний для всіх типів CM одного типу (див. 1.2.5).

Розділення даних на реального часу (надалі просто **HMI**) та конфігураційних (**CFG**) є необов'язковим і потребує дублювання певних даних на контролері. Розділення може також супроводжуватися необхідністю жорсткого розподілу доступу з боку SCADA/HMI.

Тип конфігураційних змінних, які необхідно зберігати в ПЛК може відрізнятися від типу буферної змінної, що використовується для транспорту. Буферна змінна, як правило містить заздалегідь більше полів, щоб використовуватися для транспортування даних різного типу того ж рівня.

### Змінні стану (STA) та команд (CMD) 

Дані HMI CM можуть включати слова:

-   **STA** - слово статусу (16-біт), що включає бітові набори для всіх автоматів станів (STATUS) та режимів (MODES) CM

-   **CMD** - слово керування (16-біт), що призначене для керування станом та режимами CM, а також його конфігуруванням; кожна команда кодується окремим числовим значенням унікальним в межах всіх типів CM

16-бітний формат слова вибраний з урахуванням сумісності з більшістю сучасних платформ IEC 61131-3. **Слово команди (CMD) повинно обнулятися безпосередньо в місці призначення. Таким чином команду обнулює той CM, якому вона призначена. Винятком може бути ситуація, коли команди є широкомовними, тоді необхідно передбачити механізм обнуління команди після отримання їх усіма отримувачами.**

Для забезпечення ієрархічності керування усі внутрішні змінні, що відповідають за CM, які використовуються в інших CM/EM/UNIT передаються туди як INOUT, або за посиланням. Це значно економить пам\'ять контролеру.

Для зручності, конфігураційні дані можуть також включати в себе STA та CMD (надалі STA_CFG та CMD_CFG), які використовуються тільки в програмі ПЛК. Таким чином STA, що передається в HMI (надалі STA_HMI) копіює конфігураційний STA і не може бути змінений (read only), а CMD що передається з HMI (надалі CMD_HMI) є саме командою оператору, і відповідно до цього обробляється. Змінні CMD_CFG та STA_CFG можуть бути бітовими структурами.  

Враховуючи, що для CM каналів (LVL0) та технологічних змінних (LVL1) може використовуватися тільки одна команда \"прочитати конфігурацію\" (READ\_CFG, вона ж пов\'язує CM з буфером) для економії тегів SCADA/HMI можна об\'єднати біти STA та CMD в одну змінну STA (STA_HMI), один з бітів якої буде змінюватися в HMI для команди зчитування. Така конфігурація була неодноразово перевірена і показала свою працездатність та доцільність.

Конфігураційні дані CM, що входять до певної групи повинні мати **ID** (ідентифікатор об'єкту в групі) та **CLSID** (ідентифікатор класу об\'єкту), за якими до них можна звертатися через загальний буфер. **Буфер** передбачає доступ до конфігураційних даних елемента (CM) за його номером. Буфер є змінною загального користування, яка загальнодоступна для всіх функцій або екземплярів функціональних блоків. Обробкою буферу займається той екземпляр CM, номер якого співпадає з номером в буфері. Таким чином при команді читання (READ_CFG) буфер оновлюється даними CM_CFG в тому числі ID та CLSID. Таким чином читання приводить до зв'язування CM з буфером.

Каркас передбачає використання широкомовних команд. Усі широкомовні команди передаються через CMD класу PLC (див. клас PLC). Ці команди приймаються всіма об'єктами типу, а не тільки тим, який володіє буфером. Це може знадобитися, наприклад для функцій:

-   встановлення конфігурації за замовченням;

-   встановлення/виключення режим імітації;

-   встановлення всіх об'єктів класу в ручний/автомат

-   ...

Широкомовні команди можуть мати формат 4XXX(HEX), тобто з одиничним 14-м бітом. Враховуючи що команду повинен прийняти кожен елемент типу CM, вона повинна обнулятися тільки після повного проходження циклу ПЛК (передбачається що всі CM обробляються в межах одного циклу). Деталі реалізації див. клас PLC.

Команди (CMD) для CM рівнів LVL0 та LVL1 слугують тільки для обміну між SCADA/HMI та контролерами, або обміну між пристроями. Команди рівня LVL2 і вище, використовуються і в програмі користувача. У цьому випадку повинні враховуватися команди з різних джерел CMD\_HMI (SCADA/HMI), CMD\_BUF (буферний) та CMD_CFG (програмний). Пріоритетність тієї чи іншої команди може залежати від режиму роботи CM, типу команди (наприклад читання в буфер пріоритет ніше за команду керування або навпаки).

### Вимоги до типів даних

Для обміну з HMI рекомендується використовувати наступні типи даних:

-   INT/UINT (16)

-   DINT/UDINT (32)

-   REAL (32)

-   ARRAY of INT/DINT/REAL

Для обміну з HMI не рекомендується використовувати BOOL-еву область пам\'яті, та окремі змінні типу BOOL. Рекомендується використовувати бітові набори (але не структури), наприклад біти STA. Замість типу TIME можна використати UDINT (мс) або перетворити його в REAL. Інші типи рекомендується використовувати тільки як виняток, якщо перетворення в наведені типи не може бути виконано.

Бажано забезпечувати вирівнювання на рівні 4 байтів.

Забезпечення вказаних вимог зробить можливість легкого перенесення елементів каркасу між різними платформами.

[Розділ](README.md)